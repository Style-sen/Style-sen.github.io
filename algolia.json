[{"categories":null,"content":" 1. WHY 建立自己的知识体系框架； 此处维护一张目录，1. 开头对应具体的文章。 【核心的知识储备➕风口技术】 2. HOW 使用markdown语法编写。 可以使用markmap插件导出html文件，嵌入到markdown文件中iframe（嵌套网页）。 3. FOCUS 学习 极客时间 《如何成为学习高手》（4） 如何成为学习高手。（F） ","date":"2017-08-20","objectID":"/about/about/:0:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.1. 项目管理 学习 极客时间 雷蓓蓓（网易）《项目管理实战20讲》（侧重于互联网项目）（完） 如何管理一个项目。（F） ","date":"2017-08-20","objectID":"/about/about/:1:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.1.1. 归档 编写软件项目需求分析文档。（F） 编写软件项目设计方案文档。（F） 注释规范（Doxygen）。（F） ","date":"2017-08-20","objectID":"/about/about/:1:1","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.1.2. 方法和工具 3.1.2.1. git git的使用。（F） gitlab配置CI/CD。（F） gitlab的CI/CD创建镜像。（F） 3.1.2.2. 文档协作 Seafile和Onlyoffice搭建多人协作在线文档编辑。(F) Nextcloud和Onlyoffice搭建多人协作在线文档。 ","date":"2017-08-20","objectID":"/about/about/:1:2","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.2. HARDWARE 常用电路。 常用器件。(F) ","date":"2017-08-20","objectID":"/about/about/:2:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.2.1. 电机 学习 B站 硬石科技的视频教程《基于STM32的电机》 直流无刷电机的驱动和控制。（F） VESC开源电机项目学习。（F） MikroKopter开源电机项目学习。（F） ","date":"2017-08-20","objectID":"/about/about/:2:1","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.2.2. STM32 软件开发。(F) ","date":"2017-08-20","objectID":"/about/about/:2:2","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3. PROGRAM ","date":"2017-08-20","objectID":"/about/about/:3:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.1. 跨语言 学习《代码大全》 编码方式（转为字节流处理） 开源协议。（F） 基本数据类型。（F） 编码规范。（F） 3.3.1.1. 数据结构和算法 学习 书籍 《数据结构算法与应用C++》 3.3.1.2. 设计模式 学习 极客时间 王争 《设计模式之美》 学习 网站 https://refactoringguru.cn/ 学习 GoF的《设计模式：可复用面向对象软件的基础》（收藏） 思想原则；（F） 创建型；（F） 结构型；（F） 行为型。（F） 跨设备。(F) 3.3.1.3. 架构 学习《架构整洁之道》 学习 电子书《开源软件架构》https://aosabook.org/en/index.html 学习 电子书 《Software Architecture Patterns》 3.3.1.3.1. 500 Lines or Less DBDB: Dog Bed Database。（F） 3.3.1.3.2. The Performance of Open Source Applications 3.3.1.3.3. The Architecture of Open Source Applications（上） nginx。（M） 3.3.1.3.4. The Architecture of Open Source Applications（下） 3.3.1.3.5. 其他开源项目 sqlitestudio项目源码分析。（F） qtcreater项目源码分析。（F） ","date":"2017-08-20","objectID":"/about/about/:3:1","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.2. C/C++ 学习C++核心准则 [注] 1. 全部（包括嵌入式和PC）使用C当然是最好的（nginx，sqlite，linux），但是在开发复杂项目的时候，C没有C++的优势（可读性、可复用性）。 2. 在嵌入式linux中，应用开发使用C++，但是只是使用C with class（如Guilite）。 3. 在嵌入式领域，尽量不使用STL，可以使用c实现复杂的数据结构和算法（难度较大）。 4. 在PC和服务器领域，则可以全面拥抱C++标准库（STL）/QSTL（QT）。 C-C++基础知识拾遗。（F） C++面向对象。（F） C-C++标准库。（F） C-C++第三方库。（F） C++核心准则。（F） C++跨平台。（F） 3.3.2.1. STL STL简介； STL中map的使用； ","date":"2017-08-20","objectID":"/about/about/:3:2","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.3. Python 学习《极客时间》零基础学python。（完） 学习《极客时间》Python核心技术与实战。（） 开始一个python应用。（F） python数据类型。（F） python语法。（F） 内建函数。（F） 面向对象。（F） 标准库。（F） 并发编程。（F） 网络编程。（F） Kivy应用（Windows,Linux,Android,IOS,MAC OS）. 3.3.3.1. Python第三方库 第三方库（总）。（F） scapy。（F） pandas。（F） 3.3.3.1.1. WEB框架 3.3.3.1.2. 桌面应用(包括图形和客户端) 打包应用和开源协议。（F） python+qt.(F) 1. [pyqt](https://www.riverbankcomputing.com/software/pyqt/) 2. [Qt for Python](https://doc.qt.io/qtforpython/) 3.3.3.1.3. 数据分析 ","date":"2017-08-20","objectID":"/about/about/:3:3","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.4. JS/TS WebApi接口。（F） JS混淆加密。 WEB插件。（F） JS内置对象。（F） 3.3.4.1. VUE VUE生态（原理简介及扩展简介） VUE基础 3.3.4.2. 可视化 Echarts应用。（F） ","date":"2017-08-20","objectID":"/about/about/:3:4","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.5. LUA（集成nginx） lua基础知识 lua调用Nginx接口 lua常用模块。（F） lua与C/C++相互调用 ","date":"2017-08-20","objectID":"/about/about/:3:5","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.6. GO（使用GO开发嵌入式） ","date":"2017-08-20","objectID":"/about/about/:3:6","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.7. SQL SQL。（F） ","date":"2017-08-20","objectID":"/about/about/:3:7","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.3.8. MarkDown MarkDown基本语法。(F) ","date":"2017-08-20","objectID":"/about/about/:3:8","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4. PLAT（即框架） 软件框架是一个抽象的概念，是提供了通用的软件功能，可以通过用户编写代码有选择地改变，从而提供特定的软件应用。 软件框架提供了【构建和部署应用程序】的标准方式。软件框架是一个通用的、可重用的软件环境，它提供特定的功能，作为大型软件平台的一部分，以促进软件应用程序、产品和解决方案的开发。 软件框架可能包括辅助程序、编译器、代码库、工具集API，汇集了所有不同的组件，便于一个项目或系统的开发。 ","date":"2017-08-20","objectID":"/about/about/:4:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.1. 编译 GCC。（F） 构建框架（跨平台）。（F） ","date":"2017-08-20","objectID":"/about/about/:4:1","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.2. 嵌入式系统 状态机。（F） 3.4.2.1. Alios Things 3.4.2.2. BabyOS适用MCU裸机开发项目 3.4.2.3. ChibiOS 3.4.2.4. djyOS 3.4.2.5. RT-Thread 3.4.2.6. SylixOS 3.4.2.7. Huawei LiteOS 3.4.2.8. Nuttx 3.4.2.9. Qnx 3.4.2.10. VxWorks 3.4.2.11. RTX 3.4.2.12. mbed OS 3.4.2.13. FreeRTOS 3.4.2.14. eCos 3.4.2.15. uc/OS-II 3.4.2.16. uClinux ","date":"2017-08-20","objectID":"/about/about/:4:2","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.3. Linux/Embeded【系统】 Linux下常用命令和库函数。（F） 调试和性能分析。（F） Linux下进程守护。 Linux下shell编程。（F） Linux系统定制（Yocto）。 3.4.3.1. Linux应用程序编程 学习 极客时间《网络编程实战》() 学习 书籍 《UNIX环境高级编程》 系统调用和标准库的封装（底层）。（F） 网络编程。（M） 3.4.3.2. Linux驱动程序编程 学习 书籍 《嵌入式Linux应用开发完全手册》 字符设备驱动。（F） 3.4.3.3. Linux方案实例（业务场景） Linux下应用网页升级； Linux双机备份； LinuxRPC开发; linux 如何通过读取GPIO状态来实现失电检测读取gpio状态的两种方式; 时钟同步；（F） 3.4.3.3.1. Linux应用日志管理 参考 3.4.3.4. OpenWrt（学习lua和web界面） ","date":"2017-08-20","objectID":"/about/about/:4:3","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.4. windows Dependency Walker 2.2可以查看一个应用程序所依赖的库。 ","date":"2017-08-20","objectID":"/about/about/:4:4","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.5. Qt【图形】 QT下载安装与配置及概览。（F） QT IFW。（F） 使用QT CREATER开发跨平台应用。（F） ","date":"2017-08-20","objectID":"/about/about/:4:5","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.6. 数据库 实时数据库，内存数据库，关系型数据库概念及比较。（F） redis.（F） sqlite.（F） ","date":"2017-08-20","objectID":"/about/about/:4:6","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.7. web服务器 学习 罗剑峰 《Nginx完全开发指南》 nginx使用和源码分析。（F） ","date":"2017-08-20","objectID":"/about/about/:4:7","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.8. 中间件（消息系统，rpc） zeromq–\u003enanomsg–\u003enng无代理消息传递（异步）。（F） syslogd–\u003esyslog-ng日志守护进程.(F) Grpc（同步）。（F） ","date":"2017-08-20","objectID":"/about/about/:4:8","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.9. docker ","date":"2017-08-20","objectID":"/about/about/:4:9","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.10. Unity 使用 Unity Editor 可创建 2D 和 3D 游戏、应用程序和体验。 ","date":"2017-08-20","objectID":"/about/about/:4:10","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.11. macchina.io边缘计算网关 Macchina.io Edge是一种丰富的软件框架，可快速构建在基于Linux的设备上运行的IoT设备应用程序。Macchina.io Edge实现了启用Web的，安全，模块化和可扩展的JavaScript和C ++运行时环境，并提供即时使用和行业经过验证的软件构建块。这些使能设备与各种传感器，其他设备和云服务交谈，并在边缘设备或本地网络内本地处理，分析和过滤传感器数据。 GPL开源协议。 ","date":"2017-08-20","objectID":"/about/about/:4:11","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.4.12. 其他平台 LuatOS运行在嵌入式硬件,用户编写lua代码就可完成各种功能. AGL汽车级Linux ROS机器人操作系统。 ","date":"2017-08-20","objectID":"/about/about/:4:12","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.5. 协议规范 modbus协议（M）。 iec61850MZ Automation GmbH iec60870libIEC61850 / lib60870-5 ","date":"2017-08-20","objectID":"/about/about/:5:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"3.6. 生产力工具(TOOLS) VS CODE。（F） Visual Studio。（F） CHROME。（F） 语雀。 Xmind。 截图工具-Flameshot Freeplane免费的思维导图软件。 vi非vim。（F） 命令行终端（SHELL）。（F） WireShark.(F) ","date":"2017-08-20","objectID":"/about/about/:6:0","tags":null,"title":"关于","uri":"/about/about/"},{"categories":null,"content":"1. UDP ","date":"2022-01-14","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["PLAT","LINUX","应用"],"title":"PLAT-LINUX-应用-网络编程","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"1.1. 原理分析 现象：使用UDP发送一包数据给服务端，收到一包ICMP报文（Port unreachable），由服务端返回。 原因：接收UDP报文的服务器对应的端口没有开启UDP服务器。并不是端口没有开启服务，而是没有开启UDP服务，如果开启了TCP服务，照样也会回port unreachable。 Linux内核原理 ","date":"2022-01-14","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:1","tags":["PLAT","LINUX","应用"],"title":"PLAT-LINUX-应用-网络编程","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"QCustomPlot 基于GPL。 ","date":"2022-01-12","objectID":"/post/plat-qt-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/:1:0","tags":["PLAT","QT"],"title":"PLAT QT 第三方模块","uri":"/post/plat-qt-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"用C++进行跨平台和可移植开发的注意事项 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:0:0","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"1. 需求 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:1:0","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2. 跨平台的注意事项 下面总结的是底层代码，如果要移植C/C++的界面，先找到一套跨平台的界面框架吧，否则这基本上是不可能变成的任务。 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:0","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2.1. 编译器 使用最适合平台的编译器。 windows：MSVC(推荐)或者MinGW with GCC,【QtCreater都可以使用，所以开发qt库可以使用QtCreater项目】 linux：GCC 把编译器的警告级别调高； 不要轻易忽略编译器的警告信息。 异常 new分配内存失败，有可能三种可能： 1、返回空指针； 2、抛出异常； 3、进程立即终止。 如果你希望你的代码具有较好的移植性，你就得把这三种情况都考虑到。 硬件体系相关 1. C++中基本类型的大小（占用的字节数）会随着CPU字长的变化而变化。要表示一个int占用的字节数,应该写“sizeof(int)”.指针的大小。 2. 【大小端】编写的应用程序中涉及网络通讯，一定要在记得进行主机序和网络序的翻译；如果涉及跨机器传输二进制文件，也要记得进行类似的转换。 3. 【内存对齐】简单来说，出于CPU处理上的性能考虑，结构体中的数据不是紧挨着的，而是要空开一些间隔。凡是计算结构体大小的地方，都老老实实写上sizeof()。 4. 【移位操作】对于有符号整数的右移操作，有些系统默认使用算数右移（最高的符号位不变），有些默认使用逻辑右移（最高的符号位补0）。所以，不要对有符号整数进行右移操作。顺便说一下，即使没有移植性问题，代码中也尽量少用移位运算符。 保证每个代码文件(CPP,H)的结尾都有单独的没有任何内容的一行, 这在CC/GCC/G++编译器下能减少很多警告. 使用跨平台的Make系统(Cmake)。 源代码文件的编码。一般使用utf-8（without BOM）最好。很多IDE对UTF-8编码的识别不好，可以加上BOM来帮助识别。文件名最好用全小写。 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:1","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2.2. C++语法 尽量使用标准C++的原子数据类型, 避免使用被重新定义过的类型. 或者自己重新重定义一套。 尽量所有代码都按照C++标准来编写. char如果考虑跨平台，需要明确指定是signed或者unsigned，因为不同平台直接声明char，会导致signed或者unsigned的不确定性。 【宽字符】在Windows中，wchar_t占两个字节，Linux中占四个字节。 Linux里面没有stricmp函数，在Linux下面是strcasecmp函数比较字符串。 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:2","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2.3. 操作系统 文件系统上的差异： 1. 目录分隔符的差异；`正斜线“/”（比较通用）而不要使用反斜线“\\”（仅在Windows可用）`. 2. 路径大小写敏感的差异；`linux敏感windows不敏感，都是小写` 3. 路径中禁用字符的差异; 4. 文件命名要规范：`尽量只使用字母和数字，不使用保留字，禁止创建大小写不同,但名字相同的代码文件`。 5. 代码中涉及FS操作，`尽量使用现成的库(boost::filesystem)`. 6. 换行符的差异：`Windows同时使用CR和LF；Linux和大部分的Unix使用LF；苹果的Mac系列使用CR.`如果涉及跨不同系统传输文本文件，要考虑进行适当的处理。 7. 文件搜索路径的差异：`在Windows下，如果要执行文件或者加载动态库，一般会搜索当前目录；而Posix系统则不尽然。所以如果你的应用涉及到启动进程或加载动态库，就要小心这个差异。` 8. 动态库的差异：`如果你的应用程序使用动态库，强烈建议动态库导出标准C风格的函数（尽量不要导出类）。如果在Posix系统中加载动态库，切记慎用RTLD_GLOBAL标志位。这个标志位会Enable全局符号表，有可能会导致多个动态库之间的符号名冲突（一旦碰到这种事，会出现匪夷所思的运行时错误，极难调试）。` 9. 【默认栈大小】不同的操作系统，栈的默认大小差别很大，从几十KB（据说Symbian只有12K，真抠门）到几MB不等. 由于C++开发的模块大部分是后台模块，经常会碰到服务的问题。编写服务需要调用好几个系统相关的API，导致了与操作系统的紧密耦合，很难用一套代码搞定。因此比较好的办法是抽象出一个通用的服务外壳，然后把业务逻辑代码作为动态库挂载到它下面。这样的话，至少保证了业务逻辑的代码只需要一套；服务外壳的代码虽然需要两套（一个用于Windows、一个用于Posix）（单独的文件夹），但他们是业务无关的，可以很方便地重用。 多线程 1. C运行库（后面简称CRT：C Run-Time）的配置，要支持多线程。 2. 【优化选项】以GCC为例：建议用-O2 选项即可（其实-O2 是一堆选项的集合），没必要冒险用-O3 （除非你有很充足的理由）。除了-O2 和-O3 之外，GCC还有一大坨（估计有上百个）其它的优化选项。如果你企图用当中的某个选项，一定要先把它的特性、可能的副作用都摸清楚，否则将来死都不知道怎么死的。 3. 跨平台的多线程支持还是要依赖第三方库【ACE】【boost::thread】 4. 【关于volatile】 5. 【关于原子操作】多个线程的竞争写需要加锁，却不知道多个读单个写也需要保护。数据是否坏掉，取决于对nCount的读和写是否属于原子操作。还是要用第三方库提供的原子操作类/函数（比如ACE的Atomic_Op）来确保安全 调试环境最好选择WINDOWS平台, 因为那里的调试是最友好, 特别是WINDOWS的结构化异常非常的好用。 与平台相关的调用尽量用宏隔离开来，一般用不同的目录代表不同平台，BOOST、OGRE等是这样做，也可以再一个类或者文件中，这样会导致到处都是操作系统和编译器相关宏的定义。 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:3","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2.4. 第三方库 ACE BOOST ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:4","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2.5. 辅助工具 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:5","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"2.6. 开发流程 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:2:6","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"3. 跨平台的开源库 qt-creator/qt-creator sqlite rapidjson ","date":"2021-12-03","objectID":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/:3:0","tags":null,"title":"PROGRAM C C++ 跨平台","uri":"/post/program-c-c++-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"categories":["PROGRAM"],"content":"1. GSL - GNU Scientific Library GNU Scientific库（GSL）是C和C++程序员的数字库。它是GNU通用公共许可下的自由软件。 该库提供了广泛的数学例程，如随机数发生器，特殊功能和最小二乘拟合。总共有超过1000个功能，具有广泛的测试套件。 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:1:0","tags":["PROGRAM","C/C++"],"title":"C/C++第三方库","uri":"/post/program-c-c++-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["PROGRAM"],"content":"2. tbox一个用c语言实现的跨平台 tbox目的，是为了使C开发更加的简单高效; 目前支持的平台有: Windows, Macosx, Linux, Android, iOS, *BSD等等; ","date":"2021-12-03","objectID":"/post/program-c-c++-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:2:0","tags":["PROGRAM","C/C++"],"title":"C/C++第三方库","uri":"/post/program-c-c++-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["PROGRAM"],"content":"3. libgtop（采集系统监控数据） LibGTop 是一个能够获取【进程信息】以及【系统运行信息】的函数库，这些信息包括： 系统的一般信息、SYS V IPC 限制、进程列表、进程信息、进程映射、文件系统使用信息等。 ","date":"2021-12-03","objectID":"/post/program-c-c++-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/:3:0","tags":["PROGRAM","C/C++"],"title":"C/C++第三方库","uri":"/post/program-c-c++-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["TOOLS"],"content":"1. 阅读What’s the difference between a console, a terminal, and a shell? Terminal只是显示文本并接收输入，他不会看你的输入，也不会思考。 在技术上，Console是一个设备，Terminal是一个软件；在软件世界中,两者是一个东西。 Shell是Terminal向其发送用户输入的程序。Shell生成输出并将其传回Terminal显示。 您对Shell的选择不会也不应该决定您对Terminal的选择. WSL2装载一个真正的Linux kernel运行在Windows之上.Cygwin只是让你能够运行你的bash脚本，并不是一个linux，不能运行其他linux下的程序。 Windows的新ConPTY界面是Windows上控制台和终端的未来. ","date":"2021-11-11","objectID":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/:1:0","tags":["TOOLS","TERMINAL","SHELL"],"title":"命令行终端","uri":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/"},{"categories":["TOOLS"],"content":"2. Terminal ","date":"2021-11-11","objectID":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/:2:0","tags":["TOOLS","TERMINAL","SHELL"],"title":"命令行终端","uri":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/"},{"categories":["TOOLS"],"content":"2.1. Windows Terminal Windows Terminal 完美配置 PowerShell 7.1 Ctrl+Shift+T #打开一个新标签页 Alt+Shift+D #拆分窗口 ","date":"2021-11-11","objectID":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/:2:1","tags":["TOOLS","TERMINAL","SHELL"],"title":"命令行终端","uri":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/"},{"categories":["TOOLS"],"content":"3. Shell ","date":"2021-11-11","objectID":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/:3:0","tags":["TOOLS","TERMINAL","SHELL"],"title":"命令行终端","uri":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/"},{"categories":["TOOLS"],"content":"3.1. zsh 3.1.1. oh-my-zsh 3.1.1.1. 插件 zsh-users /zsh-autosuggestionsFish-like autosuggestions for zsh . ","date":"2021-11-11","objectID":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/:3:1","tags":["TOOLS","TERMINAL","SHELL"],"title":"命令行终端","uri":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/"},{"categories":["TOOLS"],"content":"3.2. PowerShell $PSVersionTable #查看版本 ","date":"2021-11-11","objectID":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/:3:2","tags":["TOOLS","TERMINAL","SHELL"],"title":"命令行终端","uri":"/post/tools-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF/"},{"categories":["设计模式"],"content":"C++ ","date":"2021-10-27","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%B7%A8%E8%AE%BE%E5%A4%87/:0:0","tags":["设计模式","PROGRAM"],"title":"跨设备（嵌入式-PC）","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%B7%A8%E8%AE%BE%E5%A4%87/"},{"categories":["设计模式"],"content":"1. 空间和效率的平衡 在嵌入式开发中，单纯地加入class，不会影响代码的大小，也不会影响程序的效率。 默认参数和函数重载也不会带来代码大小和运行效率的影响。 构造函数和析构函数会带来一点损失，但是为了减少错误而支付的合理代价。【自总结】使用的比较频繁的对象，最好在堆内存中常驻。使用的不是很频繁的可以在栈中。 虚函数在调用前附加了一个存储查询，这个代价相对较小。 昂贵特性：模板、异常事件以及运行类型识别。 ","date":"2021-10-27","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%B7%A8%E8%AE%BE%E5%A4%87/:1:0","tags":["设计模式","PROGRAM"],"title":"跨设备（嵌入式-PC）","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%B7%A8%E8%AE%BE%E5%A4%87/"},{"categories":["项目管理"],"content":"参考Seafile集成OnlyOffic实现word在线编辑 ","date":"2021-10-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E6%96%87%E6%A1%A3%E5%8D%8F%E4%BD%9C-seafile-onlyoffice/:0:0","tags":["项目管理","文档协作"],"title":"SEAFILE+ONLYOFFICE","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E6%96%87%E6%A1%A3%E5%8D%8F%E4%BD%9C-seafile-onlyoffice/"},{"categories":["PROGRAM"],"content":"概述 相比较PANDAS来说，处理比较大的数据集会很快。 ","date":"2021-10-14","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-polors/:1:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-POLORS","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-polors/"},{"categories":null,"content":" 用于构建具有自定义用户界面的高度动态应用程序的声明式框架。 ","date":"2021-10-13","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-06-quick/:0:0","tags":["PLAT","QT"],"title":"QT基本模块QUICK","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-06-quick/"},{"categories":null,"content":" QML是一种声明式语言。它提供了一组接口用来描述可视化组件以及他们之间的互动。它是一个高度可读的语言，而且被设计成使组件以一个动态的方式相互连接。同一时候它使组件非常容易被复用以及创建定制的用户界面。 QML是一种用户界面规范和编程语言。它允许开发人员和设计师创建高性能、流畅的动画和视觉上吸引人的应用程序。QML提供了高可读性、声明性、类似json的语法，支持命令式JavaScript表达式和动态属性绑定。 ","date":"2021-10-13","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-05-qml/:0:0","tags":["PLAT","QT"],"title":"QT-QML","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-05-qml/"},{"categories":null,"content":"1. QWebChannel QWebChannel 提供了在 Server（C++应用）和 client 端（HTML/JS）之间点对点的通信能力。 通过向 client 端的 QWebChannel 发布 QObject 的 派生对象，进而实现在 client 端无缝读取来自 Qt 端的 公共插槽 和 QObject 的 属性值 和 方法。在整个通信过程中，无需任何手动序列化传入的参数。所有 Qt 端的 属性 更新，signal 触发，都会 自动且异步 更新到 client 端。 必须引入 Qt 官方提供的qwebchannel.js,github，official 的 JS 库. 在实现通信之前，必须实例化一个 QWebChannel 对象并传递一个用于传输功能的对象（称为 transport 对象）和一个回调函数。一旦 QWebChannel 完成实例化并 发布对象 变得可用时，将调用之前实例化时提供的回调函数。在回调函数被调用时，即表明通道建立。 ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-03-webchannel/:1:0","tags":["PLAT","QT"],"title":"PLAT QT 扩展模块 03 WEBCHANNEL","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-03-webchannel/"},{"categories":null,"content":"1. QDomElement 解析的xml不是很大，而且基本只涉及加载过程中，所以使用DOM的情况比较多. text()//获取文字，返回QString ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-02-xml/:1:0","tags":["PLAT","QT"],"title":"QT-XML","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-02-xml/"},{"categories":null,"content":"2. QXmlSimpleReader ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-02-xml/:2:0","tags":["PLAT","QT"],"title":"QT-XML","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-02-xml/"},{"categories":null,"content":"QtSql模块提供平台独立的基于SQL的数据库操作。这里的“平台独立”，既包括操作系统平台，也包括各个数据库平台。 #include \u003cQSqlDatabase\u003e#include \u003cQSqlQuery\u003eQT += sql ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/:0:0","tags":["PLAT","QT"],"title":"QT-SQL","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/"},{"categories":null,"content":"1. QSqlDatabase连接 一个实例是一个连接。 // 静态方法 contains() database()//实例化一个连接 // 实例方法 setDatabaseName()//设置数据库路径 open()//打开连接 driver() //获取数据库驱动用来操作数据库连接 close()//断开连接【注意，必须显式地调用，不要放在析构函数中，因为他不会立即调用】 ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/:1:0","tags":["PLAT","QT"],"title":"QT-SQL","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/"},{"categories":null,"content":"2. QSqlDriver访问sql数据库的抽象基类 //实例方法 hasFeature() //是否具有指定的特性 QSqlDriver::Transactions 支持事务 ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/:2:0","tags":["PLAT","QT"],"title":"QT-SQL","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/"},{"categories":null,"content":"3. QSqlQuery 执行SQL语句 操作SQL语句返回的结果集。 在SQL语句中使用变量。 批处理操作。 事务操作。 //实例方法 exec()//执行sql语句 //批量导入库 prepare()//query.prepare(\"INSERT INTO students (name, score,class) VALUES (:name, :score, :class)\");为每一列标题添加绑定值 bindValue()//query.bindValue(\":name\", name);然后执行exec() //查询执行select之后 bool isSelect() const//判断当前的query是不是select语句 int size() const//返回select语句执行之后获得行的个数 -1数据库不支持 seek(int n)//query指向结果集的第n条记录； first()//query指向结果集的第一条记录； last()//query指向结果集的最后一条记录； next()//指向下一条记录，每执行一次该函数，便指向相邻的下一条记录 previous()//query指向上一条记录，每执行一次该函数，便指向相邻的上一条记录 QSqlRecord record()//获得现在指向的记录； record().indexOf(\"country\")//从查询结果中获取字段的索引 QVariant value()//根据索引读取当前行中的一个列值 at()//获得现在query指向的记录在结果集中的编号。 int numRowsAffected() const//返回执行Noselect语句之后，受影响的行的个数 ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/:3:0","tags":["PLAT","QT"],"title":"QT-SQL","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/"},{"categories":null,"content":"4. QSqlRecord 一条记录 //实例方法 QVariant value(int index)// 获取索引的属性值 ","date":"2021-10-13","objectID":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/:4:0","tags":["PLAT","QT"],"title":"QT-SQL","uri":"/post/plat-qt-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97-01-sql/"},{"categories":null,"content":"使网络编程更容易和更可移植性.QT += network ","date":"2021-10-13","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/:0:0","tags":["PLAT","QT"],"title":"QT-NETWORK","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/"},{"categories":null,"content":"QAbstractSocket 继承自QIODevice; ","date":"2021-10-13","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/:1:0","tags":["PLAT","QT"],"title":"QT-NETWORK","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/"},{"categories":null,"content":"1. Qftp 需要自己编译。 # LINIX 1. 下载源码`https://github.com/qt/qtftp`; 2. `mkdir build`; 3. `qmake`; 4. `cd build`； 5. `make -f ../Makefile`; 6. `make -f ../Makefile install`; 7. 使用`Qt += ftp`; # WINDOWS 1. 使用QCreater工具打开； 2. 选择编译工具； 3. 需要安装perl运行环境。 4. 更改qtftp.pro，CONFIG += staticlib CONFIG += shared，这样会生成lib文件。 # 编译完成之后需要将生成的库文件和头文件，保存到QT库中 1. 将 Qt5Ftpd.lib Qt5Ftp.lib Qt5Ftpd.prl Qt5Ftp.prl 拷贝至 D:\\Qt\\Qt5.5.1\\5.5\\msvc2010\\lib； 2. 将Qt5Ftpd.dll Qt5Ftp.dll 拷贝至D:\\Qt\\Qt5.5.1\\5.5\\msvc2010\\bin 3. 将qftp.h qurlinfo.h 拷贝至 D:\\Qt\\Qt5.5.1\\5.5\\msvc2010\\include\\QtNetwork,并新建一个名为 QFtp 的文件(没有后缀名),然后用本写入 #include \"qftp.h\"。 依赖qt消息循环系统，所以需要指定一个parent。 可以调度的操作也被称为“命令”有connectToHost()、login()、close()、list()、cd()、get()、put()、remove()、mkdir()、rmdir()、rename() 和 rawCommand()。 所有这些命令都会返回一个唯一的标识符允许跟踪当前正在执行的命令。当命令的执行开始时发出带有命令标识符的 commandStarted() 信号。当命令完成时会发出 commandFinished() 信号并带有命令标识符和一个 bool 参数表明该命令在完成时是否出错。 【注】：ftp服务端检测，如果长时间不操作，会自动断开连接。 connectToHost() //连接到服务端 login() //登录 state() //当前状态 //信号 commandStarted() // 命令开始信号 commandFinished() // 命令完成信号 done() // 多个命令最后一个完成 listInfo() // list命令会发射这个信号，对于发现的每个条目都会发射此信号 dataTransferProgress() // 显示进度条 ","date":"2021-10-13","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/:2:0","tags":["PLAT","QT"],"title":"QT-NETWORK","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/"},{"categories":null,"content":"QTcpSocket ","date":"2021-10-13","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/:3:0","tags":["PLAT","QT"],"title":"QT-NETWORK","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-04-network/"},{"categories":null,"content":"1. 设计要点 提供了强大的signals and slots机制,用于对象之间的无缝通讯。 可查询和可设计的对象属性。 对象树。 受保护的指针。 跨库边界的动态转换。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:1:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"2. 枚举值 //enum Qt::CheckState Qt::Unchecked //不选 Qt::PartiallyChecked //半选 Qt::Checked //选择 //enum Qt::ItemDataRole Qt::CheckStateRole //10 获取选中状态 //enum Qt::ItemFlag Qt::ItemIsUserCheckable //16 可以被用户选中或不选 Qt::SplitBehavior//Qt::KeepEmptyParts|Qt::SkipEmptyParts ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:2:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"3. QAbstractItemModel(item model)抽象接口 继承自QObject; // virtual data(const QModelIndex \u0026index, int role = Qt::DisplayRole) const //获取给定role的data；【渲染的时候调用】 flags(const QModelIndex \u0026index) const //返回index指定的item的flags，基类实现ItemIsEnabled和ItemIsSelectable【可以重写返回其他flags】 setData(const QModelIndex \u0026index, const QVariant \u0026value, int role = Qt::EditRole) //设置给定role的data【界面修改的时候调用】 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:3:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"4. QAbstractTableModel表模型提供抽象结构 继承自QAbstractItemModel; //virtual flags(const QModelIndex \u0026index) ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:4:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"5. QByteArray字节数组 //实例方法 split()//以某个字符分割 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:5:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"6. QCoreApplication提供了一个事件循环 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:6:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"7. QDateTime //static方法 currentDateTime()//本地时间 fromString()//从QString中获取时间，如hh:mm:ss.zzz //实例方法 toMSecsSinceEpoch()//获取毫秒数 toTime_t()//被废弃，尽量不要用 +/1000 【会出问题】。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:7:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"8. QDebug 提供一个debug信息的输出流 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:8:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"9. QDir /*实例方法*/ exists() // 判断文件夹是否存在 mkdir() // 创建目录 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:9:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"10. QEvent事件类的基类 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:10:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"11. QFile 继承自 QFileDevice ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:11:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"12. QFileDevice ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:12:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"13. QHash字典 QHash的查找速度比QMap要快很多。 在对QHash进行迭代时，这些项是任意排序的。在QMap中，项总是按键排序。 QHash的关键类型必须提供运算符==()和全局QHash(key)函数。QMap的关键类型必须提供操作符\u003c()，以指定全序顺序。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:13:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"14. QIODevice所有I/O设备的基础接口类 继承自QObject; ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:14:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"15. QItemSelectionModel跟踪一个视图选择的项目 //实例方法 isRowSelected(int row, const QModelIndex \u0026parent = QModelIndex())//整行的所有元素都选中，返回TRUE ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:15:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"16. QJsonArray push_back() //放在队尾 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:16:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"17. QJsonObject json 可以嵌套，可以配合QJsonArray一起使用。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:17:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"18. QLinkedList链表 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:18:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"19. QList列表 大多数情况下可以用QList。像prepend()和insert()这种操作，通常QList比QVector快的多。这是因为QList是基于index标签存储它的元素项在内存中，比那种依赖iterator迭代的更快捷。而且你的代码也更少。 如果你需要一个真正的连接着的list，且需要保证一个固定插入耗时。那就用迭代器，而不是标签。使用QLinkedList(); 如果你需要开辟连续的内存空间存储，或者你的元素远比一个指针大，这时你需要避免个别插入操作，出现堆栈溢出，这时候用QVector 如果你需要一个低层的可变数量大小的数组，用QVarLengthArray就够了。他可以预先在栈中分配已知长度大小的数组，如果超过这个长度，会在堆中继续存储。默认大小256 //实例方法 //增加 append(const T \u0026value) append(const QList\u003cT\u003e \u0026value) //查 at()//获取指定index的元素 indexof() // size()//返回节点的数目 count()//返回节点的数目 isEmpty()//空，返回true //删除元素 removeOne(T) //删除第一次出现的指定元素 //排序 qSort(s.begin(), s.end(),compare);//compare是排序回调函数 //遍历 for(int i = 0; i \u003c s.count() ; i++) { qDebug() \u003c\u003c s.at(i).num; } ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:19:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"20. QMap 红黑树的字典 //实例方法 isEmpty()//判断是否为空 insert()//插入一个键值对 contains(key)//判断是否包含某个key QMap\u003cQString,QString\u003e::iterator it = m_map.find(\"111\"); //找到特定的“键-值”对 it.value()//获取map里对应的值 //遍历 QMap\u003cQString, QString\u003e::iterator iterIndex = iter.valueOptions.begin(); while (iterIndex != iter.valueOptions.end()) ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:20:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"21. QModelIndex在数据模型中定位数据 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:21:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"22. QObject【所有Qt类的基类】 setProperty(const char *name, const QVariant \u0026value)//设置自定义属性（所有的类都可用），灵活方便 property(const char *name) const//获取到自定义的数据 sender()//获取到信号的发送者 timerEvent(QTimerEvent *event)//接收定时事件 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:22:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"23. QString（QT内部的编码方式 Unicode (utf-16)） 真正的QString转char，utf8编码转gb2312编码. //static方法 number(double n, char format = 'g', int precision = 6)//e科学计数法e；E科学计数法E；f浮点数；g:e或者f；G：E或者f //实例方法 int compare(const QString \u0026other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const//返回小于等于大于0的整数 split() //QString::SkipEmptyParts忽略空的部分，如：split(QRegExp(\" *\\\"\"), QString::SkipEmptyParts)[0] QString(\"%1%2\").arg(\"\").arg() //格式化arg(hour, 2, 10, QLatin1Char('0'))补0 arg()//可以直接包含至多10个QString arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const//fieldWidth最小的填充空间量，正值是右对齐，负值是左对齐 setNum() //数字转为QString simplified() //返回一个字符串，该字符串从开头和结尾删除了空格，并将每个内部空格序列替换为一个空格 trimmed() //返回从开头和结尾删除空格的字符串。 QStringList split(const QString \u0026sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const QStringList split(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const QStringList split(const QRegExp \u0026rx, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const QStringList split(const QRegularExpression \u0026re, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const /*转为char* */ Qstring str = \"helloworld\"; char *s; QByteArray ba = str.toLatin1(); s = ba.data(); /*正则*/ constIterator = list.constBegin();//0 QRegExp rx(\"[A-Z]+\"); int pos = 0; if ((pos = (*constIterator).indexOf(rx) != -1)){ qDebug() \u003c\u003c rx.cap(0); constIterator++;//1 qDebug() \u003c\u003c (*constIterator).split(QRegExp(\" *\\\"\"), QString::SkipEmptyParts)[0]; }; ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:23:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"24. QStringList QString调用split之后生成。 append() //增加字符串或者\u003c\u003c join() //合并成一个字符串 /*遍历*/ QList\u003cQString\u003e::Iterator it = user.begin(),itend = user.end(); int i = 0; for (;it != itend; it++,i++){ if (*it == pFindLine-\u003etext()){//找到，高亮显示 QModelIndex index = model-\u003eindex(i); m_pTabList-\u003esetCurrentIndex(index); break; } } ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:24:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"25. QTextCodec编码类 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:25:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"26. QThread多线程 QThread类提供了一个与平台无关的管理线程的方法。 一个QThread对象管理一个线程。 方法一：写一个类继承QThread，并重写其run()函数；run()函数是新线程的入口，run()函数退出，意味着线程的终止；使用start()函数来启动子线程，而不是run()；start()会自动调用run()；与主线程通过信号和槽进行通讯。 方法二：使用moveToThread()。 【注意】Qt中的UI操作，比如QMainWindow、QWidget之类的创建、操作，只能位于主线程！一般思路是，主线程负责提供界面，子线程负责无UI的单一任务，通过“信号-槽”与主线程交互。 QThread本身的成员都不属于新线程，而且在QThread构造函数里通过new得到的实例，也不属于新线程。这一特性意味着，如果要实现多线程操作，那么你希望属于新线程的实例、变量等，应该在run()中进行初始化、实例化等操作。 qDebug() \u003c\u003c \"Current thread:\" \u003c\u003c thread();用于判断是否在子线程。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:26:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"27. QTime时钟时间 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:27:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"28. QTimer 提供了重复和单次触发【信号】(非事件)的定时器。 当QTimer的父对象被销毁时，它也会被自动销毁。 定时器之间不是并行处理数据，而是分片占用主线程资源 ，且定时器完成其对应的slot函数任务后，下一个定时器才会开始执行其slot函数任务； 当定时器的间隔时间小于其slot函数任务的执行时间时，一旦定时器timeout时，其slot函数不会终止执行，只是暂停，内部变量仍然保存，而后继续执行。 把QTimer放进线程中的典型例子【此方法不能解决一个线程中使用两个定时器，因为他们关联到主线程的方法】： QThread* thread = new QThread(this); thread-\u003estart(); QTimer *timer = new QTimer(0);//没有指定parent, 所以不会自动销毁. timer-\u003esetInterval(100); timer-\u003emoveToThread(thread); connect(timer, SIGNAL(timeout()), this, SLOT(onTimeout()), Qt::DirectConnection);//指定DirectConnection 才会直接调用slot. 即在worker线程中处理;否则connect默认参数为AutoConnection, 所以当slot的object是main线程时, 会自动post 事件到main线程 connect(thread, SIGNAL(started()), timer,SLOT(start())); 【不可以在子线程中调用UI方法（UI的事件在主线程），必须要用信号和槽】。 //实例方法 setInterval(int msec)//设置间隔，只的是上一个timeout执行完之后的间隔 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:28:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"29. QTimerEvent定时事件 更高的效率。 继承自QEvent; ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:29:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"30. QVariant通用数据类型的封装容器 The QVariant class acts like a union for the most common Qt data types. //构造函数 QVariant(int val)//增加一个整数的数据类型 //实例方法 toInt() toFloat() QString toString() ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:30:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"31. QVarLengthArray低级变长数组 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:31:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"32. QVector动态数组 大多数情况下QVector应该是你的首选 append() //增加元素 count() //元素的数目 和size() 相同 clear() //清空元素，qt5.6及以前会请空间，qt5.7开始不会清空间 currentRtuPara.paras.clear(); QVector\u003cSProcValTableStruInfo_t\u003e().swap(currentRtuPara.paras); ins[] //下标 /*遍历*/ QVector\u003cQString\u003e::iterator iter; for (iter=strArray.begin();iter!=strArray.end();iter++) qDebug() \u003c\u003c *iter \u003c\u003c \"\\0\"； ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:32:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"33. QXmlStreamReader ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/:33:0","tags":["PLAT","QT"],"title":"PLAT QT 基本模块 01 CORE","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-01-core/"},{"categories":null,"content":"1. QBrush设置QPainter绘制的图形的填充图案 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:1:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"2. QColor颜色 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:2:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"3. QGuiApplication管理 GUI 应用程序的控制流和主要设置 //类常量 primaryScreen//默认屏幕 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:3:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"4. QMovie 播放。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:4:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"5. QScreen获取屏幕属性 //类常量 geometry//获取屏幕尺寸 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:5:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"6. QStandardItem setForeground(const QBrush \u0026brush)//设置前景 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:6:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"7. QStandardItemModel通用model 继承自QAbstractItemModel; //实例方法 item(int row, int column = 0) const //返回指定行和列的item setHorizontalHeaderLabels(const QStringList \u0026labels) //使用labels设置水平标题标签。 如有必要，列数增加到labels的数量 rowCount(const QModelIndex \u0026parent = QModelIndex()) const ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/:7:0","tags":["PLAT","QT"],"title":"QT基本模块-GUI","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-03-gui/"},{"categories":null,"content":"1. 设计要点 qmake: QT += widgets 如果希望界面自适应电脑的分辨率或者改变界面大小时，界面上的所有部件也能够做出相应改变。这种时候就可以使用“布局（Layout）功能”。所谓布局，就是界面上组件的排列方式，使用布局可以使组件有规则地分布，并且随着窗体大小自动地调整大小和相对位置。 需要为窗体制定一个总的布局。这样布局之后，当窗体大小改变时，各个组件都会自动改变大小。 如果想要界面自适应电脑分辨率大小，可以将所有组件的sizePolicy中的Horizontal Policy和Vertical Policy设置成Ignored，再进行上述布局。 【对于所有有区域的控件不要用绝对长度和宽度，全都用相对比例】。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:1:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"1.1. 组件 1.1.1. Window和Dialog 没有嵌入父widget的widget称为window； 通常，一个window有一个frame和一个title bar；也可以没有。 任何没有父widget的QWidget都将成为一个window，并且在大多数平台上都将在桌面的任务栏中列出。这通常只适用于应用程序中的一个窗口，即primary window。 另外，一个有父类的QWidget可以通过设置Qt:: window标志成为window。根据窗口管理系统的不同，这些secondary windows通常被堆叠在它们各自的父窗口的顶部，并且没有它们自己的任务栏条目。 QMainWindow类在其构造函数中设置了Qt::Window标志，因为它被设计成一个window，并提供了子窗口部件不需要的工具。 Dialog Windows用作向用户提供选项和选择的secondary windows。对话框是通过继承QDialog并使用小部件和布局来实现用户界面来创建的。 1.1.2. 应用主窗口 1.1.2.1. QMainWindow(类) Qt用QMainWindow和相关类来管理primary window。QMainWindow已经定义了一个布局，可以往里添加一些 QToolBar 和 QDockWidget，也可以添加一个 QMenuBar 和一个 QStatusBar。这个布局有一个中央区域，可以放任意部件。 继承自QWidget menuBar()//返回主窗口的菜单栏QMenuBar，没有就会创建 1.1.3. Dialog Windows现成的对话框 1.1.3.1. QColorDialog(类)选择颜色 1.1.3.2. QFileDialog(类)选择文件或者文件夹 1.1.3.3. QFontDialog(类)选择字体 1.1.3.4. QInputDialog(类)单值输入 1.1.3.5. QMessageBox(类)弹出消息 继承自QDialog; //静态方法 question(QWidget *parent, const QString \u0026title, const QString \u0026text, QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), QMessageBox::StandardButton defaultButton = NoButton) QMessageBox::StandardButton warning(QWidget *parent, const QString \u0026title, const QString \u0026text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton) 1.1.3.6. QProgressDialog(类)进度条 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:1:1","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"1.2. 样式 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:1:2","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"1.3. 布局 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:1:3","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"1.4. Model/View架构 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:1:4","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"1.5. Graphics View Framework 图形视图框架用于管理和与大量定制的2D图形项进行交互，以及用于可视化这些项的视图小部件，支持缩放和旋转。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:1:5","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"2. QAbstractButton 【信号】 void clicked(bool checked = false)//单击 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:2:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"3. QAbstractItemDelegate显示和编辑模型中的数据项 继承自QObject. //需要被继承类重写的方法 createEditor(QWidget *parent, const QStyleOptionViewItem \u0026option, const QModelIndex \u0026index)//创建一个控件用于编辑model中的数据，并返回。index为列号，option为显示选项 setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex \u0026index) //用编辑器的当前值设置model的值 setEditorData(QWidget *editor, const QModelIndex \u0026index)//用model的值设置editor的值 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:3:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"4. QAbstractItemView抽象类 QAbstractItemView是所有的使用QAbstractItemModel模型的视图的基类，是一个不能被实例化的抽象类。它通过信号槽机制为与模型的交互操作提供了一个标准化的接口，确保子类视图能够随着模型的变化而及时更新。该类对键盘和鼠标的导航、视窗的滚动、项的编辑以及选择提供了标准的支持。 //实例方法 setItemDelegate(QAbstractItemDelegate *delegate) //设置委托model setItemDelegateForColumn(int column, QAbstractItemDelegate *delegate)//为column设置委托model setItemDelegateForRow(int row, QAbstractItemDelegate *delegate) //设置委托model为row setModel(QAbstractItemModel *model) //设置模型，view的操作就委托给了model进行处理，model变化view可以实时更新 selectionModel()//Returns the current selection model ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:4:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"5. QAction组件中的一个动作 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:5:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"6. QApplication ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:6:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"7. QBoxLayout水平或竖直排列子部件 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:7:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"8. QButtonGroup按钮组 提供一个容器管理一组按钮。 继承QObject. QButtonGroup(QObject *parent = nullptr)//构造函数 //实例方法 addButton(QAbstractButton *button, int id = -1)//如果id为-1将自动给分配一个ID从-2开始减，如果指定id的话,请指定正数 button(int id) const//获取指定id的button //信号 buttonClicked(QAbstractButton *button)//按键点击了一下 buttonPressed(QAbstractButton *button) buttonReleased(QAbstractButton *button) buttonToggled(QAbstractButton *button, bool checked)//checked is true if the button is checked, or false if the button is unchecked idClicked(int id) idPressed(int id) idReleased(int id) idToggled(int id, bool checked)//checked is true if the button is checked, or false if the button is unchecked. ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:8:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"9. QComboBox下拉选择框(单选) addItem(const QString \u0026text, const QVariant \u0026userData = QVariant())//增加选项，可以自定义数据 addItem(const QIcon \u0026icon, const QString \u0026text, const QVariant \u0026userData = QVariant()) addItems(const QStringList \u0026texts) clear()//清空所有选项 setCurrentIndex(index)//知道索引，就用 setCurrentText(\"text\")//知道文本，就用 QVariant currentData(int role = Qt::UserRole) const currentIndex() const currentText() const itemData(int index, int role = Qt::UserRole)//返回自定义数据 itemText(int index)//返回文本 model()//返回使用的model findText(const QString \u0026text, Qt::MatchFlags flags = Qt::MatchExactly|Qt::MatchCaseSensitive)//返回TEXT对应的index,没有找到返回-1 //【支持输入筛选】 setEditable(bool editable)//设置用户是否可以编辑，默认是false setCompleter(QCompleter *completer)//只有可编辑才支持设置，不然会被忽略。注意输入之后需要判断是否在选项中 //【信号】 currentIndexChanged//当前索引改变触发 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:9:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"10. QCompleter ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:10:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"11. QDesktopWidget获取屏幕信息（该类已过时） //实例方法 availableGeometry()//获取应用程序可用区域 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:11:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"12. QDialog 对话框。 this-\u003esetAttribute(Qt::WA_DeleteOnClose,true); // false 则不立即清空,点击关闭立即杀死自己。 setModal(true)设置为模态。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:12:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"13. QDialogButtonBox //信号 accepted() rejected() ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:13:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"14. QDockWidget QDockWidget是可以在QMainWindow窗口停靠，或在桌面最上层浮动的window。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:14:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"15. QFormLayout窗体布局 与网格状布局类似，但是只有最右侧的一列网格会改变大小。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:15:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"16. QFrame边框 继承QWidget; ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:16:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"17. QGridLayout网格状布局 网状布局大小改变时，每个网格的大小都改变。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:17:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"18. QGroupBox带有标题的分组框 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:18:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"19. QHBoxLayout水平布局 继承QBoxLayout; QHBoxLayout(QWidget *parent)//构造函数 QHBoxLayout()//默认构造函数 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:19:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"20. QItemDelegate模型的显示和编辑功能 继承QAbstractItemDelegate; 一般被继承,委托。 //重写的公共成员函数 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:20:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"21. QListView提供列表或图标视图 继承自QAbstractItemView; ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:21:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"22. QMenu(类)菜单 用于菜单栏、上下文菜单栏和其他弹出菜单。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:22:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"23. QMenuBar(类)水平菜单栏 用来放置QMenu。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:23:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"24. QPushButton setMenu()//将一个按钮变为菜单按钮,点击下拉 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:24:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"25. QRadioButton单选按钮 继承QAbstractButton； 一般和QButtonGroup类配合使用。 QRadioButton(const QString \u0026text, QWidget *parent = nullptr)//构造函数 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:25:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"26. QScrollArea ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:26:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"27. QSizePolicy描述水平和垂直大小调整策略的布局属性 //类型 enum QSizePolicy::Policy//【Fixed】不能放大或者缩小【Preferred】控件的sizeHint是它的sizeHint，但是可以放大或者缩小【Expanding】控件可以自行增大或者缩小 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:27:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"28. QSplitter分割器 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:28:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"29. QStatusBar水平状态栏 QStatusBar 可以添加多个 QWidget，因此，可以构建出很复杂的状态栏。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:29:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"30. QStyle【抽象基类】封装了GUI的外观 【类型】 enum QStyle::StandardPixmap//标准位图图标 【实例方法】 standardIcon()//获取内置的标准图标 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:30:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"31. QTableView（表视图） 继承自QAbstractItemView; 适合大型项目。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:31:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"32. QTableWidget表格组件 继承自QTableView; QTableWidget 约等于 QTableView + Model。 适合小型项目。 //实例方法 setRowCount(int)//设置行数，增加减少行 setColumnCount(int)//设置列数 setHorizontalHeaderLabels(const QStringList)//设置表头标题 setHorizontalHeaderItem(int, QTableWidgetItem）//设置表头标题，适合对表头格式有要求的 clearContents()//只清除工作区，不清除表头 rowCount()//获取行数 stItem()//设置单元格，【必须先设置行数】 setCellWidget()//在单元格中设置控件 cellWidget()//获取单元格的控件 currentItem()//获取当前的item item(int row, int column) const//获取指定行和列的item //信号 itemChanged()//单元格的内容改变（enter，离开焦点）触发，背景颜色改变也会触发 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:32:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"33. QTableWidgetItem 每个单元格（包括表头）。 //构造函数可以传入type，可以通过type()获取 setTextAlignment(int alignment)//设置文字对齐方式。 setBackground(const QBrush \u0026brush)//设置单元格背景颜色。 setForeground(const QBrush \u0026brush)//设置单元格前景色。 setIcon(const QIcon \u0026icon)//为单元格设置一个图标。 setFont(const QFont \u0026font)//为单元格显示文字设置字体。 setCheckState(Qt::CheckState state)//设置单元格勾选状态，单元格里出现一个QCheckBox组件。 setFlags(Qt::ItemFlags flags)//设置单元格的一些属性标记。 setFlags(Qt::ItemIsEditable)//单元格内容变为灰色，且不能选中单元格；用户不能编辑单元格内容，但是可以通过代码修改 setFlags(pItem-\u003eflags() \u0026 (~Qt::ItemIsEditable))//使单元格内容不会变为灰色，可以选中单元格，但是用户不能编辑单元格内容 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:33:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"34. QTabWidget选项卡 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:34:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"35. QTextBrowser ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:35:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"36. QTreeView提供了树视图的默认模型/视图实现 继承自QAbstractItemView; //实例方法 setWordWrap()//设置换行,并不会换行，只会增加省略号 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:36:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"37. QTreeWidget树形控件 继承自QTreeView. //实例方法： clear() //清空 topLevelItemCount()//获取顶层节点的数目 setHeaderHidden(true)//设置表头为隐藏 currentItem()//获取当前节点 //信号 itemClicked(QTreeWidgetItem *item, int column)//点击一个节点发出 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:37:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"38. QTreeWidgetItem 树形控件的节点 QTreeWidgetItem(int type = Type)//在构造函数里传递一个类型值之后，就可以用 type() 返回这个节点的类型值 //实例方法 addChild(QTreeWidgetItem *child)//增加子节点 setData(int column , int role , const QVariant \u0026 value)//额外增加属性，不显示在UI中：column（列）role（enum Qt:: ItemDataRole） QVariant data(int column , int role)//获取上边的额外属性 text(int column) //获取节点的文字 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:38:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"39. QScrollArea 滚动区控件。 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:39:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"40. QVBoxLayout垂直方向布局 继承QBoxLayout; ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:40:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":null,"content":"41. QWidget所有UI对象的基类 一般和布局配合使用。 //static属性 //static方法 //实例属性 //实例方法 resize()//重新调整大小 QWidget *parentWidget() const//获取此组件的父组件 QString toolTip() const//控件的toolTip用来给控件进行注释等信息 //public slots hide()//隐藏，不可见 //信号 void customContextMenuRequested(const QPoint \u0026pos)//右键点击，上下文菜单 ","date":"2021-09-18","objectID":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/:41:0","tags":["PLAT","QT"],"title":"QT基本模块-WIDGETS","uri":"/post/plat-qt-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97-02-widgets/"},{"categories":["HARDWARE"],"content":"1. 简介 ","date":"2021-09-11","objectID":"/post/hardware-moto-mikrokopter%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:1:0","tags":["HARDWARE"],"title":"MikroKopter开源电机项目学习","uri":"/post/hardware-moto-mikrokopter%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"2. 硬件 ","date":"2021-09-11","objectID":"/post/hardware-moto-mikrokopter%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:2:0","tags":["HARDWARE"],"title":"MikroKopter开源电机项目学习","uri":"/post/hardware-moto-mikrokopter%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"3. 软件 ","date":"2021-09-11","objectID":"/post/hardware-moto-mikrokopter%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:3:0","tags":["HARDWARE"],"title":"MikroKopter开源电机项目学习","uri":"/post/hardware-moto-mikrokopter%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"参考What’s VESC? How to use it ? What’s difference between VESC and ESC? ","date":"2021-09-11","objectID":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:0:0","tags":["HARDWARE"],"title":"VESC开源电机项目学习","uri":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"简介 VESC 是一个开源 ESC (电动速度控制器)。 官方网站。 ","date":"2021-09-11","objectID":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:1:0","tags":["HARDWARE"],"title":"VESC开源电机项目学习","uri":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"硬件 ","date":"2021-09-11","objectID":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:2:0","tags":["HARDWARE"],"title":"VESC开源电机项目学习","uri":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"软件 ","date":"2021-09-11","objectID":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:3:0","tags":["HARDWARE"],"title":"VESC开源电机项目学习","uri":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"固件 ","date":"2021-09-11","objectID":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/:3:1","tags":["HARDWARE"],"title":"VESC开源电机项目学习","uri":"/post/hardware-moto-vesc%E5%BC%80%E6%BA%90%E7%94%B5%E6%9C%BA%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"categories":["HARDWARE"],"content":"1. 开始 官方库的选择:使用Cube库替代官方外设库。 ","date":"2021-08-20","objectID":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/:1:0","tags":["HARDWARE"],"title":"STM32软件研发","uri":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/"},{"categories":["HARDWARE"],"content":"2. 资源 ","date":"2021-08-20","objectID":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/:2:0","tags":["HARDWARE"],"title":"STM32软件研发","uri":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/"},{"categories":["HARDWARE"],"content":"中断、事件、中断事件 需触发中断，交给NVIC处理的，也就是软件上有中断函数的，叫中断 不要触发中断，直接给外设(rg，ADC)的，软件上没有中断函数的，叫事件。 触发中断，而且软件上也有中断函数的，叫中断事件 事件机制提供了一个完全有硬件自动完成的触发到产生结果的通道,不要软件的参与,降低了CPU的负荷,节省了中断资源，提高了响应速度(硬件总快于软件)，是利用硬件来提升CPU芯片处理事件能力的一个有效方法。 ","date":"2021-08-20","objectID":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/:2:1","tags":["HARDWARE"],"title":"STM32软件研发","uri":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/"},{"categories":["HARDWARE"],"content":"2.1. 定时器 2.1.1. PWM 互补输出，应该是定时器的PWM互补输出。这个【作用】一般是用在驱动器、逆变器方面。主要是用在【全桥MOS管】的控制上。 如果MOS管相同，PWM不反向的话，势必造成两个MOS都导通。相当于电源和地都直连。 由于两个MOS管的参数不一定完全相同，关断速度不一样，可能有那么几个us 或者MS 是上一个管马上要关闭，下一个已经打开了，造成了两个MOS都打开的短暂现象，所以一般需要加个死区时间。 HAL库 __HAL_TIM_SET_COMPARE()设置CCRx，一般是用在PWM输出的，控制PWM占空比;第三个参数为占空比（高电平的重载值，值越大，高电平越多）。 __HAL_TIM_GET_COMPARE()用来读取CCRx的，一般用于捕获处理. HAL_TIM_PWM_Start()开启PWM CH* HAL_TIM_PWM_Stop()关闭PWM CH* HAL_TIMEx_PWM_Start()开启PWM CH*N HAL_TIMEx_PWM_Stop()关闭PWM CH*N ","date":"2021-08-20","objectID":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/:2:2","tags":["HARDWARE"],"title":"STM32软件研发","uri":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/"},{"categories":["HARDWARE"],"content":"3. STM32CubeMX 工具的使用 ","date":"2021-08-20","objectID":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/:3:0","tags":["HARDWARE"],"title":"STM32软件研发","uri":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/"},{"categories":["HARDWARE"],"content":"3.1. 生成的文件夹结构 Drivers |——CMSIS #符合CMSIS标准的软件抽象层组件，包含两个文件夹 |——Include #包含Cortex-M内核及其设备文件 |——Device #微控制器专用头文件/启动代码/专用系统文件 |——STM32F1xx_HAL_Driver # 包含了所有的STM32F1系列的HAL库头文件和源文件；屏蔽了底层的寄存器配置，统一外设接口。【不同的工程包含的HAL驱动文件是相同的】 Core |——Inc #应用相关的头文件；【不同的工程项目不同】 |——Src #应用相关的源文件；【不同的项目不同】 MDK-ARM #MDK项目 | 如果需要重新生成代码，需要打开MDK工具，并最小化；生成代码之后，更新变化的文件。【切记：MDK工程文件不更新】 ","date":"2021-08-20","objectID":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/:3:1","tags":["HARDWARE"],"title":"STM32软件研发","uri":"/post/hardware-stm32-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91/"},{"categories":["HARDWARE"],"content":"1. USB ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:1:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"1.1. CH9329 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:1:1","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"1.2. HT42B564 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:1:2","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"2. 语音芯片 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:2:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"2.1. NVC系列 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:2:1","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"3. LED ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:3:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"3.1. NeoPixels 也被称为WS2812 LED彩带，是连接在一起的全彩色led灯串 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:3:1","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"4. 传感器 多传感器融合算法：卡尔曼滤波和多贝叶斯估计。 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:4:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"4.1. 温湿度传感器 4.1.1. DHT11（0～50） 4.1.2. DHT22（-40~80） ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:4:1","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"4.2. 光照传感器 Lux(勒克斯)是光照强度的单位，Lumens(流明)指一个光源发出的光能力的总量。 4.2.1. PT550 输出模拟量。 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:4:2","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"4.3. 麦克风阵列 4.3.1. ReSpeaker 2-Mics Pi HAT ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:4:3","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"5. Micro SD卡（TF卡） 存储容量： 读写速度等级：U3表示最低写入速度是30MB/s. 应用性能等级，随机读写性能。A2标识。 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:5:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"6. 树莓派 免费的烧录工具：Etcher。 支持WIFI：wpa_supplicant.conf. ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:6:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"7. NodeMCU 基于乐鑫esp8266的NodeMcu开发板，具有GPIO、PWM、I2C、1-Wire、ADC等功能，结合NodeMcu 固件为您的原型开发提供最快速的途径。 文档. ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:7:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"8. 掌控板 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:8:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"9. 智能音箱 ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:9:0","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["HARDWARE"],"content":"9.1. 技术架构 9.1.1. 拾音 麦克风阵列（Mic Array） 9.1.2. 前端信号处理 回声消除，用于消除在播放音乐时，外放的声音对麦克风采集声音的影响； 噪声抑制； 语音检测：准确检测出语音的开始和结束，过滤掉非语音的声音； 声源定位：在麦克风阵列中，一般是基于声音到达的时间差等算法，确定生源的空间位置，可以帮助进行波束成型； 波束成型：通过滤波算法，将声源方向的信号增强，而其他方向的声音进行抑制； 混响消除：通过算法将人声分离出来，为后续的语音唤醒和识别提供高质量的语音信号. 9.1.3. 语音唤醒 通过特定的唤醒词来激活智能音箱，一方面保护隐私，一方面简化。 Snowboy停止服务；Mycroft Precise(基于RNN神经网络的语音唤醒工具). 9.1.4. 语音识别（STT） 将语音转换为文本。 9.1.5. 自然语言理解 对文本进行处理，识别用户的意图。 9.1.6. 技能 借助后端云平台的强大能力，提供知识图谱、家居设备远程控制和音乐等。 9.1.7. 自然语言生成 组成文本语言。 9.1.8. 语音合成（TTS） 文本转化成语音。 HanTTS ","date":"2021-08-20","objectID":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/:9:1","tags":["HARDWARE"],"title":"HARDWARE 常用器件","uri":"/post/hardware-%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6/"},{"categories":["项目管理"],"content":"1. 安装 apt-get install graphviz; apt-get install doxygen ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:1:0","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"2. 注释格式 ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:2:0","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"2.1. 块注释，建议统一使用 /** *…… */ ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:2:1","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"2.2. 行注释 如下图，函数中注释可以出现在Doxygen 页面的函数说明中。 ///\u003c … /** …… */ ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:2:2","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"2.3. 常用注释 /** @exception \u003cexception-object\u003e {exception description} 对一个异常对象进行注释。 @warning {warning message } 一些需要注意的事情 @todo { things to be done } 对将要做的事情进行注释，链接到所有TODO 汇总的TODO 列表 @bug 缺陷，链接到所有缺陷汇总的缺陷列表 @see {comment with reference to other items } 一段包含其他部分引用的注释，中间包含对其他代码项的名称，自动产生对其的引用链接。 @relates \u003cname\u003e 通常用做把非成员函数的注释文档包含在类的说明文档中。 @since {text} 通常用来说明从什么版本、时间写此部分代码。 @deprecated @pre { description of the precondition } 用来说明代码项的前提条件。 @post { description of the postcondition } 用来说明代码项之后的使用条件。 @addtogroup 添加到一个组。 @deprecated 已废弃函数 @fn 函数说明 @ingroup 加入到一个组 @return 描述返回意义 @retval 描述返回值意义 @include 包含文件 @var、@enum、@struct、@class 对变量、美剧、结构体、类等进行标注 + @attention + 【注意】 + @brief + 概要信息 + @code + 在注释中开始说明一段代码，直到@endcode命令。 + @details + 详细描述 + @note + 开始一个段落，用来描述一些注意事项 + @par + 开始一个段落，段落名称描述由你自己指定 + @param + 标记一个参数的意义 + 常用注释 + 项目注释 + 放在核心文件中，比如main.c中 + /** @mainpage 项目名称 */ + 可以包含@section 项目名称 + 项目描述 + ProjectName + Author + 功能描述 + 用法描述 + 版本描述 + 注意事项 + 可以使用HTML的表格语法 + SubTopic + 源代码文件注释 + /**@file 【需与当前文件名一致】 * @brief 项目主函数文件 * @details 主要包含协议应用栈程序框架，main函数入口 * @author wanghuan any question please send mail to 371463817@qq.com * @date 2018-8-17 * @version V1.0 * @copyright Copyright (c) 2018-2020 江苏亨通光网科技有限公司 * @attention * 硬件平台:nRF52832_QFAA \\n * SDK版本：nRF5_SDK_15.0.0 * @par 修改日志: */ + 函数注释 + /**@brief NB模组向云平台上报数据 * @param[in] handle NB模组驱动句柄 * @param[in] *data 上报数据指针 * @param[in] len 上报数据长度 * @param[in] rcc_enabled 上报时是否主动释放RCC链接 * @param[in] update_enabled 上报时是否更新注册(只适用于onenet) * @param[in] report_fail_try_type 上报失败重新注册类型 \\n * @ref NB_REPFAIL_REG_TRY 出错立即重试 \\n * @ref NB_REPFAIL_REG_DELAY_TRY 出错延缓重试，在延迟期间如果正常则重新延缓，适用于高频率上报（上报失败重新注册超时15min） \\n * @ref NB_REPFAIL_REG_NO_TRY 出错不重试 * @return 函数执行结果 * - NB_NOTIFY_SUCCESS 上报成功 * - NB_NOTIFY_FAIL 上报失败 * - NB_IOT_REGIST_FAILED 注册失败返回 * - Others 其他错误 * @par 示例: * @code * 移动平台发送数据 AT+MIPLNOTIFY=0,122553,3308,0,5900,4,4,50,0,0 * 电信平台发送数据 AT+M2MCLISEND=000101 * @endcode * @see :: ME3616_FxnTable */ + 枚举、结构体等注释 + 模块注释 + 分组注释 ## 配置VS Code 1. `Doxygen Documentation Generator`插件 2. 配置插件`setting.json` ```json // The prefix that is used for each comment line except for first and last. \"doxdocgen.c.commentPrefix\": \" * \", // Smart text snippet for factory methods/functions. \"doxdocgen.c.factoryMethodText\": \"Create a {name} object\", // The first line of the comment that gets generated. If empty it won't get generated at all. \"doxdocgen.c.firstLine\": \"/**\", // Smart text snippet for getters. \"doxdocgen.c.getterText\": \"Get the {name} object\", // The last line of the comment that gets generated. If empty it won't get generated at all. \"doxdocgen.c.lastLine\": \" */\", // Smart text snippet for setters. \"doxdocgen.c.setterText\": \"Set the {name} object\", // Doxygen comment trigger. This character sequence triggers generation of Doxygen comments. \"doxdocgen.c.triggerSequence\": \"/**\", // Smart text snippet for constructors. \"doxdocgen.cpp.ctorText\": \"Construct a new {name} object\", // Smart text snippet for destructors. \"doxdocgen.cpp.dtorText\": \"Destroy the {name} object\", // The template of the template parameter Doxygen line(s) that are generated. If empty it won't get generated atall. \"doxdocgen.cpp.tparamTemplate\": \"@tparam {param} \", // File copyright documentation tag. Array of strings will be converted to one line per element. Can template{year}. \"doxdocgen.file.copyrightTag\": [ \"@copyright Copyright (c) {year}\" ], // Additional file documentation. Array of strings will be converted to one line per element. Can template{year}, {date}, {author}, and {email}. \"doxdocgen.file.customTag\": [], // The order to use for the file comment. Values can be used multiple times. Valid values are shown in defaultsetting. \"doxdocgen.file.fileOrder\": [ \"file\", \"author\", \"brief\", \"version\", \"date\", \"empty\", \"copyright\", \"empty\", \"custom\" ], // The template for the file parameter in Doxygen. \"doxdocgen.file.fileTemplate\": \"@file {name}\", // Version number for the file. \"doxdocgen.file.versionTag\": \"@version 0.1\", \"doxdocgen.gener","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:2:3","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"3. 配置文件 doxygen -s -g 这种方式生成的配置文件非常精简，没有任何注释。 有了doxygen模板配置文件后，现在要做的就是对它进行修改了，下面以c语言开发的项目生成html为例. # 项目名称，将作为于所生成的程序文档首页标题，需要使用双引号括住 PROJECT_NAME = “xxx” # 文档版本号，可对应于项目版本号，譬如 git、svn、cvs 所生成的项目版本号 PROJECT_NUMBER = “1.0.0” # 程序文档输出目录，产生的文件会放在这个路径之下。如果没有填这个路径，将会以当前所在路径来作为输出路径。 OUTPUT_DIRECTORY = doc/ # 程序文档语言环境，预设为 English。1.2.16 版后，可以用 Chinese 输出简体中文，也可以使用 # Chinese-Traditional 来输出中文繁体的格式。 OUTPUT_LANGUAGE = Chinese # 如果是制作 C 程序文档，该选项必须设为YES，否则默认生成 C++ 文档格式 OPTIMIZE_OUTPUT_FOR_C = YES # 对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化 TYPEDEF_HIDES_STRUCT = YES # 把这个标记设置为Yes，即使各个类或函数没有文档，也要提取信息 EXTRACT_ALL = YES # 把这个标记设置为Yes，文档就会包含类的私有数据成员 EXTRACT_PRIVATE = YES # 把这个标记设置为Yes，文档就会包含文件的静态成员(函数和变量) EXTRACT_STATIC = YES # 在 C++ 程序文档中,该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间 # 这样的概念，所以此处设置为 YES HIDE_SCOPE_NAMES = YES # 让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息 QUIET = YES # 这个标记创建一个以空格分隔的所有目录的列表， # 这个列表包含需要生成文档的 C/C++ 源代码文件和头文件，可以不设定，即为当前目录! INPUT = inc/ # 输入文件的编码格式，需要自己根据INPUT指定的文件选择，否则会乱码 INPUT_ENCODING = UTF-8 # 在默认情况下,doxygen 会搜索具有典型 C/C++ 扩展名的文件， # 比如 .c、.cc、.cpp、.h 和 .hpp 。 # 可以使用如下形式的列表方式,指定INPUT下要处理的文件 # 注:文件类型后有空格然后是右斜杠然后回车,每一个文件类均独自一行! # FILE_PATTERNS = *.h \\ *.c \\ *.cpp FILE_PATTERNS = # 递归遍历由 INPUT 所指定的目录及其所有子目录，寻找由 FILE_PATTERNS 指定的要被文档化的文件 RECURSIVE = YES # 如果您有特定文件或目录，不希望经过 Doxygen 处理，那你可在这指出，没有就不指出 # 例如:EXCLUDE = /home/xxx/src_root /home/xxx/test EXCLUDE = # 类似于 FILE_PATTERNS 的用法，只是这个是供 EXCLUDE 所使用 EXCLUDE_PATTERNS = # 若设定为 YES，就会产生 HTML 版本的说明文件。HTML 文件是 Doxygen 预设产生的格式之一 GENERATE_HTML = YES # 若设定为 YES，Doxygen 会帮您产生一个树状结构，在页面左侧，默认为 NO # 这个树状结构是以 JavaScript 所写成。所以需要新版的 Browser 才能正确显示。 GENERATE_TREEVIEW = YES ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:3:0","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"4. 执行 doxygen Doxyfile生成文档了.注意：这里的Doxyfile为你实际的Doxygen配置文件名。 ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/:4:0","tags":["项目管理","归档"],"title":"注释规范Doxygen","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"},{"categories":["项目管理"],"content":"参考软件需求分析模板 软件需求分析就是把软件计划期间建立的软件可行性分析求精和细化，分析各种可能的解法，并且分配给各个软件元素。 需求分析是软件定义阶段中的最后一步，是【确定系统必须完成哪些工作】，也就是对目标系统提出完整、准确、清晰、具体的要求。 软件需求分析的任务是：深入描述软件的【功能】和【性能】，确定【软件设计的约束】和软件同其他系统元素的【接口】细节，定义软件的其他【有效性需求】，借助于当前系统的逻辑模型导出目标系统逻辑模型，解决目标系统“做什么”的问题。 需求分析可分为【需求提出】、【需求描述】及【需求评审】三个阶段。 1. 需求提出主要集中于描述系统目的。需求提出和分析仅仅集中在使用者对系统的观点上。这样的定义称作【系统规格说明】，并且它在用户和开发人员之间充当合同。 2. 在问题分析阶段分析人员的主要任务是：对用户的需求进行鉴别、综合和建模，清除用户需求的模糊性、歧义性和不一致性，分析系统的数据要求，为原始问题及目标软件建立逻辑模型。分析人员要将对原始问题的理解与软件开发经验结合起来，以便发现哪些要求是由于用户的片面性或短期行为所导致的不合理要求，哪些是用户尚未提出但具有真正价值的潜在需求。 3. 在需求评审阶段，分析人员要在用户和软件设计人员的配合下对自己生成的需求规格说明和初步的用户手册进行【复核】，以确保软件需求的完整、准确、清晰、具体，并使用户和软件设计人员对需求规格说明和初步的用户手册的理解达成一致。一旦发现遗漏或模糊点，必须尽快更正，再行检查。 ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E7%BC%96%E5%86%99%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/:0:0","tags":["项目管理","归档"],"title":"编写软件项目需求分析文档","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E7%BC%96%E5%86%99%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/"},{"categories":["项目管理"],"content":"1. 软件需求说明书的编制 1　引言 1．1编写目的 #说明编写这份软件需求说明书的目的，指出预期的读者。 1．2背景 #说明： #a．待开发的软件系统的名称； #b．本项目的任务提出者、开发者、用户及实现该软件的计算中心或计算机网络； #C．该软件系统同其他系统或其他机构的基本的相互来往关系。 1．3定义(术语和缩略词) #列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1．4参考资料 #列出用得着的参考资料，如： #a．本项目的经核准的计划任务书或合同、上级机关的批文； #b．属于本项目的其他已发表的文件； #c．本文件中各处引用的文件、资料、包括所要用到的软件开发标准。 列出这些文件资料的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 2　任务概述 2．1目标 #叙述该项软件开发的意图、应用目标、作用范围以及其他应向读者说明的有关该软件开发的背景材料。解释被开发软件与其他有关软件之间的关系。如果本软件产品是一项独立的软件，而且全部内容自含，则说明这一点。如果所定义的产品是一个更大的系统的一个组成部分，则应说明本产品与该系统中其他各组成部分之间的关系，为此可使用一张方框图来说明该系统的组成和本产品同其他各部分的联系和接口。| 2．2用户的特点 #列出本软件的最终用户的特点，充分说明操作人员、维护人员的教育水平和技术专长，以及本软件的预期使甩频度。这些是软件设计工作的重要约束 2．3假定和约束 #列出进行本软件开发工作的假定和约束，例如经费限制、开发期限等。 3　需求规定 3．1对功能的规定 #用列表的方式（例如IPO表即输入、处理、输出表的形式），逐项定量和定性地叙述对软件所提出的功能要求，说明输入什么量、经怎样的处理、得到什么输出，说明软件应支持的终端数和应支持的并行操作的用户数。 3．2对性能的规定 3．2．1精度 #说明对该软件的输入、输出数据精度的要求，可能包括传输过程中的精度。 3．2．2时间特性要求 #说明对于该软件的时间特性要求，如对： #a．响应时间； #b．更新处理时间； #c．数据的转换和传送时间； #d．解题时间； 等的要求。 3．2．3灵活性 #说明对该软件的灵活性的要求，即当需求发生某些变化时，该软件对这些变化的适应能力，如： #a．操作方式上的变化； #b．运行环境的变化； #c．同其他软件的接口的变化； #d．精度和有效时限的变化； #e．计划的变化或改进。 #对于为了提供这些灵活性而进行的专门设计的部分应该加以标明。 3．3输人输出要求 #解释各输入输出数据类型，并逐项说明其媒体、格式、数值范围、精度等。对软件的数据输出及必须标明的控制输出量进行解释并举例，包括对硬拷贝报告（正常结果输出、状态输出及异常输出）以及图形或显示报告的描述。 3．4数据管理能力要求 #说明需要管理的文卷和记录的个数、表和文卷的大小规模，要按可预见的增长对数据及其分量的存储要求作出估算。 3．5故障处理要求 #列出可能的软件、硬件故障以及对各项性能而言所产生的后果和对故障处理的要求。 3．6其他专门要求 #如用户单位对安全保密的要求，对使用方便的要求，对可维护性、可补充性、易读性、可靠性、运行环境可转换性的特殊要求等。 4　运行环境规定 4．1设备 #列出运行该软件所需要的硬设备。说明其中的新型设备及其专门功能，包括： #a．处理器型号及内存容量； #b．外存容量、联机或脱机、媒体及其存储格式，设备的型号及数量； #c．输入及输出设备的型号和数量，联机或脱机； #d．数据通信设备的型号和数量； #e．功能键及其他专用硬件 4．2支持软件 #列出支持软件,包括要用到的操作系统、编译（或汇编）程序、测试支持软件等。 4．3 接口 #说明该软件同其他软件之间的接口、数据通信协议等。 4．4控制 #说明控制该软件的运行的方法和控制信号，并说明这些控制信号的来源。 ","date":"2021-08-05","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E7%BC%96%E5%86%99%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/:1:0","tags":["项目管理","归档"],"title":"编写软件项目需求分析文档","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%92%E6%A1%A3-%E7%BC%96%E5%86%99%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/"},{"categories":["PROGRAM"],"content":"配置项详解 var option = { //标题 title : { show:true, //显示策略，默认值true,可选为：true（显示） | false（隐藏） text: '主标题', //主标题文本，'\\n'指定换行 link:'', //主标题文本超链接,默认值true target: null, //指定窗口打开主标题超链接，支持'self' | 'blank'，不指定等同为'blank'（新窗口） subtext: '副标题', //副标题文本，'\\n'指定换行 sublink: '', //副标题文本超链接 subtarget: null, //指定窗口打开副标题超链接，支持'self' | 'blank'，不指定等同为'blank'（新窗口） x:'center' //水平安放位置，默认为'left'，可选为：'center' | 'left' | 'right' | {number}（x坐标，单位px） y: 'top', //垂直安放位置，默认为top，可选为：'top' | 'bottom' | 'center' | {number}（y坐标，单位px） textAlign: null ,//水平对齐方式，默认根据x设置自动调整，可选为： left' | 'right' | 'center backgroundColor: 'rgba(0,0,0,0)', //标题背景颜色，默认'rgba(0,0,0,0)'透明 borderColor: '#ccc', //标题边框颜色,默认'#ccc' borderWidth: 0, //标题边框线宽，单位px，默认为0（无边框） padding: 5, //标题内边距，单位px，默认各方向内边距为5，接受数组分别设定上右下左边距 itemGap: 10, //主副标题纵向间隔，单位px，默认为10 textStyle: { //主标题文本样式{\"fontSize\": 18,\"fontWeight\": \"bolder\",\"color\": \"#333\"} fontFamily: 'Arial, Verdana, sans...', fontSize: 12, fontStyle: 'normal', fontWeight: 'normal', }, subtextStyle: {//副标题文本样式{\"color\": \"#aaa\"} fontFamily: 'Arial, Verdana, sans...', fontSize: 12, fontStyle: 'normal', fontWeight: 'normal', }, zlevel: 0, //一级层叠控制。默认0,每一个不同的zlevel将产生一个独立的canvas，相同zlevel的组件或图标将在同一个canvas上渲染。zlevel越高越靠顶层，canvas对象增多会消耗更多的内存和性能，并不建议设置过多的zlevel，大部分情况可以通过二级层叠控制z实现层叠控制。 z: 6, //二级层叠控制，默认6,同一个canvas（相同zlevel）上z越高约靠顶层。 }, xAxis:{ axisLabel: { interval: 6,//间隔 rotate: 35//旋转量 } //提示框，鼠标悬浮交互时的信息提示 tooltip : { trigger: 'item', formatter: \"{a} \u003cbr/\u003e{b} : {c} ({d}%)\" }, //图例，每个图表最多仅有一个图例 legend: { orient: 'vertical', left: 'left', data: ['第一部分','第二部分','第三部分','第四部分'] }, // 系列列表,每个系列通过 type 决定自己的图表类型 series : [ { name: '访问', type: 'pie', radius : '62%', center: ['50%', '65%'],/ minAngle:'15', markPoint: {//标记点 data: [ {type: 'max', name: '最大值'}, {type: 'min', name: '最小值'} ] }, markLine:{//标记线 data: [[ {coord:[mar.up,0]},//指定线的两个点 {coord:[mar.up,mar.top]} ]] }, makrArea:{ itemStyle: { color: 'rgba(255, 173, 177, 0.4)' }, data: [ [{ name: '早高峰', xAxis: '07:30' }, { xAxis: '10:00' }], [{ name: '晚高峰', xAxis: '17:30' }, { xAxis: '21:15' }] ] }, data:[ {name:\"第一部分\",value:4}, {name:\"第二部分\",value:7}, {name:\"第三部分\",value:3}, {name:\"第四部分\",value:1}, ], itemStyle: { normal:{ label:{ show:true, formatter: \"{b} :\\n {c} \\n ({d}%)\", position:\"inner\" } } } } ], }; ","date":"2021-08-02","objectID":"/post/program-js-ts-echarts/:1:0","tags":["PROGRAM","JS/TS","ECHARTS"],"title":"Echarts","uri":"/post/program-js-ts-echarts/"},{"categories":["PROGRAM"],"content":"实例方法 ","date":"2021-08-02","objectID":"/post/program-js-ts-echarts/:2:0","tags":["PROGRAM","JS/TS","ECHARTS"],"title":"Echarts","uri":"/post/program-js-ts-echarts/"},{"categories":["HARDWARE"],"content":"学习 B站 硬石科技的视频教程《基于STM32的电机》专题07 第5节 ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:0:0","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":["HARDWARE"],"content":"1. 基础的电机控制 ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:1:0","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":["HARDWARE"],"content":"1.1. 电机的驱动原理 直流电源。 逆变器。 霍尔传感器（选配），用来获取转子的位置，霍尔磁铁的极性和转子的极性相同，电角度相差120度。 【注】不同的绕组有一端连接在一起，另一端引出（可作为输入，也可以作为输出）。 BLDC电机 PMSM电机 固定定子线圈和活动转子永磁体 固定定子线圈和活动转子永磁体 电源电压呈梯形 电源电压呈正弦形式 反电动式呈梯形 反电动式呈正弦形式 每过60度，定子磁链位置会换向 定子磁链位置连续变化 铁损较高 铁损较低 控制算法相对简单：6步方波，刚好配合每过60度，定子磁链改变方向（流过的电流大小相同）（6步换相）需要根据霍尔传感的位置反馈。根据霍尔器件的位置反馈，改变绕组的通电方向 控制算法复杂：矢量控制FOC 1.1.1. 无刷无感电机 控制难点主要有两点：第一，电机的启动；第二，转子位置的检测。 1.1.1.1. 启动 一般采用“三段式”启动。 1.1.1.1.1. 电机转子预定位 若要保证无刷直流电机能够正常起动，首先要确定转子在静止时的位置。 在小型轻载条件下，对于具有梯形反电势波形的无刷直流电机来说，一般采用磁制动转子定位方式。 系统起动时，任意给定一组触发脉冲，在气隙中形成一个幅值恒定、方向不变的磁通，只要保证其幅值足够大，那么这一磁通就能在一定时间内将电机转子强行定位这个方向上。 在应用中，可以在任意一组绕组上通电一定时间，其中预定位的PWM占空比和预定位时间的长短设定值可由具体电机特性和负载决定，在【实际应用中调试】而得。在预定位成功后，转子在起动前可达到预定的位置，为电机起动做好准备。 关键参数：预定位的PWM占空比（占空比30-50%，不要太大，可能会发热）和预定位时间的长短设定值。 1.1.1.1.2. 电机的外同步加速 确定了电机转子的初始位置后，由于此时定子绕组中的反电动势仍为零，所以必须人为的改变电机的外施电压和换相信号，使电机由静止逐步加速运动，这一过程称为外同步加速。 对于不同的外施电压调整方法和换相信号调整方法，外同步加速可以划分为三类：换相信号频率不变，逐步增大外施电压使电机加速，称为【恒频升压】法。保持外施电压不变，逐渐增高换相信号的频率，使电机逐步加速，称为【恒压升频】法。在逐步增大外施电压的同时，增高换相的频率，称为【升频升压】法。 1.1.1.1.3. 电机运行状态的转换 各个方法都有其优点和缺点。 如升频升压法是人为地给电机施加一个由低频到高频不断加速的可控同步切换信号，而且电压也在不断地增加。通过调整电机换相频率，即可调整电机起动的速度。调整方法比较简单。 但是这个过程比较难实现，切换信号的频率的选择要根据电机的极对数和其它参数来确定，太低电机无法加速，太高电机转速达不到会有噪声甚至无法启动，算法比较困难。 无论哪种方法，该过程都是在未检测到反电动势信号时进行，因此对于控制系统来说，此段电机控制是盲区。参数在调试好的时候，可以快速切换至正常运行状态；而参数不理想时，电流可能不稳甚至电机会抖动。因此，在应用中，应根据【电机及负载特性】设定合理的升速曲线，并在尽可能短的时间内完成切换。 关键参数：换相信号频率及升频曲线和外施电压。 1.1.1.1.4. 启动之后，就可以使用PID进行调速 ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:1:1","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":["HARDWARE"],"content":"1.2. 驱动硬件设计 33逆变器。 改变速度需要PWM波，改变导通的占空比。 TLP715 [半桥驱动电路]只有一个。 自举升压电路。 MCP6024. 过流保护电路。 STM32定时器：互补PWM信号：两个通道输出互为反相的脉冲信号；专门的霍尔传感器接口。 ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:1:2","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":["HARDWARE"],"content":"1.3. 程序代码实现 COM事件的作用：换向之前，先配置好，然后一键生效。 在换相的时候，可能高电平会截断。 ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:1:3","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":["HARDWARE"],"content":"2. FOC的控制原理 学习 B站 硬石科技的视频教程《基于STM32的电机》专题08 FOC是一种电机控制算法，（Field Oriented Control）磁场定向控制，又叫\"矢量控制”。 ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:2:0","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":["HARDWARE"],"content":"2.1. ST Motor Control Workbench ","date":"2021-07-30","objectID":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/:2:1","tags":["HARDWARE"],"title":"直流无刷电机的驱动和控制","uri":"/post/hardware-moto-%E7%9B%B4%E6%B5%81%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"1. 保持愉悦和高效 ","date":"2021-07-21","objectID":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/:1:0","tags":null,"title":"如何成为学习高手","uri":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/"},{"categories":null,"content":"1.1. 概念 峰终定律 成就目标 [道德许可效应] ","date":"2021-07-21","objectID":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/:1:1","tags":null,"title":"如何成为学习高手","uri":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/"},{"categories":null,"content":"1.2. 应用 【制定计划】的时候、量力而行、不要制定完不成的计划、不要制定多类型的任务，尽量少安排； 艰难和轻松的任务【穿插】着（比如各25分钟）去完成，避免负向峰值的出现。 感到疲惫，可以【换个环境】。 【详细记录】当天具体的时间使用情况，一目了然，提升终值体验。 学着不用某种标准框住自己，也别总对自己的表现评头论足，更不必急着追求某种结果，而是踏踏实实走好每一步，专注于【做事本身】。 ","date":"2021-07-21","objectID":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/:1:2","tags":null,"title":"如何成为学习高手","uri":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/"},{"categories":null,"content":"2. 认清伪勤奋 花大量的时间做容易的环节。只有去完成那些让自己感到需要思考、需要克服困难的任务，才是真勤奋。但是不能设置过高的目标，“踮一踮脚能够完成”就很适合。 从来不去【检测】自己获得了什么。学的东西，要立刻检测、检测自己有没有记住，检测自己会不会。“一切不以检测和输出为目的的努力，都是刷流氓”。 只是埋头苦学、不总结规律。学习包括对知识的学习和对学习方法的学习。需要试错、分析、反思、调整以及应用，总结自己的学习方法，不但要做到，还要清楚自己是如何做到的。 【道德许可效应】让你原地徘徊，沉迷于已经努力的幻觉之中。把你想做的事情最简化，去掉花里胡哨的，不搞形式主义，直接开始。 ","date":"2021-07-21","objectID":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/:2:0","tags":null,"title":"如何成为学习高手","uri":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/"},{"categories":null,"content":"特别会考试 学会用考试的思维去学习。 明确地知道，自己需要回答什么问题；进而分析如何回答这个问题； 【即用即学和即学即用】； 学以致用，输出要更多一点，“检索式学习”，回想，想不起来再去看书。回想知识的时候，付出的主动努力越大，学习和记忆的效果越好【注：重复地阅读是低效的方法】。 ","date":"2021-07-21","objectID":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/:3:0","tags":null,"title":"如何成为学习高手","uri":"/post/focus-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/"},{"categories":["PROGRAM"],"content":"1. 创建表 -- 【SQLITE】 CREATE TABLE COMPANY ( ID INT PRIMARY KEY, -- 主键，唯一索引 NAME TEXT NOT NULL UNIQUE, -- UNIQUE 唯一索引 AGE INT NOT NULL , ADDRESS CHAR(50), SALARY REAL DEFAULT 50000.00, -- UNIQUE(column_name1,column_name2) -- 联合唯一 -- primary key (id,bh) -- 联合主键 ); ","date":"2021-07-09","objectID":"/post/program-sql/:1:0","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":["PROGRAM"],"content":"2. 新增 ALTER TABLE \u003c表名\u003e ADD \u003c新字段名\u003e\u003c数据类型\u003e[约束条件];新增字段。 INSERT INTO 【SQLITE】INSERT OR REPLACE INTO table-name (column-name,...) VALUES (column-value,...)需要配合唯一索引进行判断，只有当唯一索引都没有的情况下，才进行新增。否则更新，其他列都更新，没有的为NULL。 【SQLITE】INSERT OR IGNORE INTO ","date":"2021-07-09","objectID":"/post/program-sql/:2:0","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":["PROGRAM"],"content":"3. 删除 删除DELETE FROM table_name WHERE [condition]; 删除所有行DELETE FROM table_name；【SQLITE】 ","date":"2021-07-09","objectID":"/post/program-sql/:3:0","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":["PROGRAM"],"content":"4. 修改 更新UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition];【SQLITE】 ","date":"2021-07-09","objectID":"/post/program-sql/:4:0","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":["PROGRAM"],"content":"5. 查询 ","date":"2021-07-09","objectID":"/post/program-sql/:5:0","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":["PROGRAM"],"content":"5.1. 统计函数 5.1.1. count()用于行数的统计 count()列值为空时认为没有这一行； count()为空时返回结果为0 5.1.2. sum()用于求和 sum()列值为空时不计算；.。 sum()为空时返回结果为null； ","date":"2021-07-09","objectID":"/post/program-sql/:5:1","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":["PROGRAM"],"content":"5.2. GROUP BY 结合统计函数,根据一个或多个列对结果集进行分组.【SQLITE】 ","date":"2021-07-09","objectID":"/post/program-sql/:5:2","tags":["PROGRAM","SQL"],"title":"PROGRAM SQL","uri":"/post/program-sql/"},{"categories":null,"content":"1. Qt Creater配置 【Tools】-\u003e【Options】打开选项。 ","date":"2021-06-23","objectID":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/:1:0","tags":["PLAT","QT"],"title":"使用CREATER开发","uri":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/"},{"categories":null,"content":"1.1. Kits 配置可用的编译工具。 ","date":"2021-06-23","objectID":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/:1:1","tags":["PLAT","QT"],"title":"使用CREATER开发","uri":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/"},{"categories":null,"content":"2. QtCreater项目 .h是头文件； .cpp是源文件； .ui是界面文件。 ","date":"2021-06-23","objectID":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/:2:0","tags":["PLAT","QT"],"title":"使用CREATER开发","uri":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/"},{"categories":null,"content":"2.1. .pro是项目配置文件 INCLUDEPATH += // 增加头文件的目录，末尾不需要加斜线 QMAKE_LFLAGS += // 链接标志 QMAKE_CXXFLAGS += //用来给编译器传递开关 LIBS += //用来链接外部的库 ","date":"2021-06-23","objectID":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/:2:1","tags":["PLAT","QT"],"title":"使用CREATER开发","uri":"/post/plat-qt-creater-%E5%BC%80%E5%8F%91/"},{"categories":null,"content":"参考使用 Qt Installer Framework 制作安装包与程序自动升级 参考Qt Installer Framework 使用说明 Qt Installer Framework 提供了一组工具和实用工具来创建安装程序，并在不重写源代码的情况下将它们部署到所有受支持的桌面 Qt 平台上，它可以运行在 Linux、Microsoft Windows、and OS X 平台上。 ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:0:0","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"1. 目录结构 binbinarycreator.exe用于生成安装程序repogen.exe用于生成升级仓库 ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:1:0","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"2. 创建安装程序 ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:2:0","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"2.1. 创建目录 创建一个Package目录，包含所有配置文件和可安装软件包； 在Package目录中包含 config 和 packages 两个子目录; 在 packages 可以放置不同的程序组件，目录名一般以 domain-like identifier 方式命名，例如：com.vendor.root 。在组件根目录下，创建名为 data 和 meta 的子目录; -packages - com.vendor.root - data - meta - com.vendor.root.component1 - data - meta - com.vendor.root.component1.subcomponent1 - data - meta - com.vendor.root.component2 - data - meta meta 目录包含指定部署和安装过程的文件，这些文件【不会由安装程序提取安装】，meta 目录中必须包含至少一个包信息文件（package.xml ）和你在包信息文件中引用的所有文件，例如：脚本、用户界面文件和翻译等。 将安装程序需要安装的文件（你的exe程序及其依赖等）放到 data 目录中。【包含安装过程中安装程序提取的安装内容】； ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:2:1","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"2.2. 创建配置 在 config 目录中，创建具有以下内容的名为 config.xml 的文件; \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cInstaller\u003e \u003c!-- 程序名称 --\u003e \u003cName\u003eYour application\u003c/Name\u003e \u003c!-- 版本号 --\u003e \u003cVersion\u003e1.0.0\u003c/Version\u003e \u003cTitle\u003eYour application Installer\u003c/Title\u003e \u003c!-- 软件的发布者（公司名称） --\u003e \u003cPublisher\u003eYour vendor\u003c/Publisher\u003e \u003c!-- 在 Windows 开始菜单中为产品指定了默认程序组的名称 --\u003e \u003cStartMenuDir\u003eSuper App\u003c/StartMenuDir\u003e \u003c!-- 指定应用程序的默认安装目录 --\u003e \u003cTargetDir\u003e@HomeDir@/InstallationDirectory\u003c/TargetDir\u003e \u003c!-- 如果卸载时不删除目标文件夹,设置为false --\u003e \u003cRemoveTargetDir\u003efalse\u003c/RemoveTargetDir\u003e \u003c/Installer\u003e meta 目录中创建一个具有以下内容并名为 package.xml 的文件(组件)： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cPackage\u003e \u003cDisplayName\u003eThe root component\u003c/DisplayName\u003e \u003cDescription\u003eInstall this example.\u003c/Description\u003e \u003cVersion\u003e0.1.0-1\u003c/Version\u003e \u003cReleaseDate\u003e2010-09-21\u003c/ReleaseDate\u003e \u003cLicenses\u003e \u003cLicense name=\"Beer Public License Agreement\" file=\"license.txt\" /\u003e \u003c/Licenses\u003e \u003cDefault\u003escript\u003c/Default\u003e \u003cScript\u003einstallscript.qs\u003c/Script\u003e \u003cUserInterfaces\u003e \u003cUserInterface\u003epage.ui\u003c/UserInterface\u003e \u003c/UserInterfaces\u003e \u003c/Package\u003e ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:2:2","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"2.3. 拷贝exe及其依赖 例如：将程序可执行文件及其依赖放到 packages/com.vendor.root/data 目录中. ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:2:3","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"2.4. 创建安装包 切换到 Package 目录，执行下列命令即可： binarycreator.exe -c config/config.xml -p packages YourInstaller.exe ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:2:4","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"3. 定制安装程序 ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:3:0","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"4. 覆盖安装 默认情况下，Qt Installer Framework 不支持离线升级。 如果想要升级，只能先手动卸载旧版程序，再安装新版本的程序。 定制安装程序，来强制覆盖安装新版本程序；或先自动卸载旧版本程序，再安装新版程序。 \u003cComponent\u003e/meta/package.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cPackage\u003e \u003cDisplayName\u003eAtlas4500Tuner\u003c/DisplayName\u003e \u003cDescription\u003eInstall the Atlas4500 Tuner\u003c/Description\u003e \u003cVersion\u003e1.0.0\u003c/Version\u003e \u003cReleaseDate\u003e\u003c/ReleaseDate\u003e \u003cDefault\u003etrue\u003c/Default\u003e \u003cRequired\u003etrue\u003c/Required\u003e \u003c!-- 自定义脚本 --\u003e \u003cScript\u003einstallscript.qs\u003c/Script\u003e \u003cUserInterfaces\u003e \u003cUserInterface\u003etargetwidget.ui\u003c/UserInterface\u003e \u003c/UserInterfaces\u003e \u003c/Package\u003e \u003cComponent\u003e/meta/installscript.qs maintenancetool.exe为Qt的维护软件，生成安装包的时候，会自动加载。 var targetDirectoryPage = null; function Component() { installer.gainAdminRights(); component.loaded.connect(this, this.installerLoaded); } Component.prototype.createOperations = function() { // Add the desktop and start menu shortcuts. component.createOperations(); component.addOperation(\"CreateShortcut\", \"@TargetDir@/Atlas4500Tuner.exe\", \"@DesktopDir@/Atlas4500 Tuner.lnk\", \"workingDirectory=@TargetDir@\"); component.addOperation(\"CreateShortcut\", \"@TargetDir@/Atlas4500Tuner.exe\", \"@StartMenuDir@/Atlas4500 Tuner.lnk\", \"workingDirectory=@TargetDir@\"); } Component.prototype.installerLoaded = function() { installer.setDefaultPageVisible(QInstaller.TargetDirectory, false); installer.addWizardPage(component, \"TargetWidget\", QInstaller.TargetDirectory); targetDirectoryPage = gui.pageWidgetByObjectName(\"DynamicTargetWidget\"); targetDirectoryPage.windowTitle = \"Choose Installation Directory\"; targetDirectoryPage.description.setText(\"Please select where the Atlas4500 Tuner will be installed:\"); targetDirectoryPage.targetDirectory.textChanged.connect(this, this.targetDirectoryChanged); targetDirectoryPage.targetDirectory.setText(installer.value(\"TargetDir\")); targetDirectoryPage.targetChooser.released.connect(this, this.targetChooserClicked); gui.pageById(QInstaller.ComponentSelection).entered.connect(this, this. componentSelectionPageEntered); } Component.prototype.targetChooserClicked = function() { var dir = QFileDialog.getExistingDirectory(\"\", targetDirectoryPage.targetDirectory.text); targetDirectoryPage.targetDirectory.setText(dir); } Component.prototype.targetDirectoryChanged = function() { var dir = targetDirectoryPage.targetDirectory.text; if (installer.fileExists(dir) \u0026\u0026 installer.fileExists(dir + \"/maintenancetool.exe\")) { targetDirectoryPage.warning.setText(\"\u003cp style=\\\"color: red\\\"\u003eExisting installation detected and will be overwritten.\u003c/p\u003e\"); } else if (installer.fileExists(dir)) { targetDirectoryPage.warning.setText(\"\u003cp style=\\\"color: red\\\"\u003eInstalling in existing directory. It will be wiped on uninstallation.\u003c/p\u003e\"); } else { targetDirectoryPage.warning.setText(\"\"); } installer.setValue(\"TargetDir\", dir); } Component.prototype.componentSelectionPageEntered = function() { var dir = installer.value(\"TargetDir\"); if (installer.fileExists(dir) \u0026\u0026 installer.fileExists(dir + \"/maintenancetool.exe\")) { installer.execute(dir + \"/maintenancetool.exe\", \"--script=\" + dir + \"/scripts/auto_uninstall.qs\"); } } \u003cComponent\u003e/meta/targetwidget.ui \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cui version=\"4.0\"\u003e \u003cclass\u003eTargetWidget\u003c/class\u003e \u003cwidget class=\"QWidget\" name=\"TargetWidget\"\u003e \u003cproperty name=\"geometry\"\u003e \u003crect\u003e \u003cx\u003e0\u003c/x\u003e \u003cy\u003e0\u003c/y\u003e \u003cwidth\u003e491\u003c/width\u003e \u003cheight\u003e190\u003c/height\u003e \u003c/rect\u003e \u003c/property\u003e \u003cproperty name=\"sizePolicy\"\u003e \u003csizepolicy hsizetype=\"Preferred\" vsizetype=\"Preferred\"\u003e \u003chorstretch\u003e0\u003c/horstretch\u003e \u003cverstretch\u003e0\u003c/verstretch\u003e \u003c/sizepolicy\u003e \u003c/property\u003e \u003cproperty name=\"minimumSize\"\u003e \u003csize\u003e \u003cwidth\u003e491\u003c/width\u003e \u003cheight\u003e190\u003c/height\u003e \u003c/size\u003e \u003c/property\u003e \u003cproperty name=\"windowTitle\"\u003e \u003cstring\u003eForm\u003c/string\u003e \u003c/property\u003e \u003clayout class=\"QVBoxLayout\" name=\"verticalLayout\"\u003e \u003citem\u003e \u003cwidget class=\"QLabel\" name=\"description\"\u003e \u003cproperty name=\"text\"\u003e \u003cstring/\u003e \u003c/property\u003e \u003c/widget\u003e \u003c/item\u003e \u003citem\u003e \u003clayout class=\"QHBoxLayout\" name=\"horizontalLayout\"\u003e \u003citem\u003e \u003cwidget class=\"QLineEdit\" name=\"targetDirectory\"\u003e \u003cproperty name=\"readOnly\"\u003e \u003cbool\u003etrue\u003c/bool\u003e \u003c/property\u003e \u003c","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:4:0","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"创建在线安装程序 创建在线安装应用程序，只需创建一个存储库并将其上传到 web 服务器，然后在 config.xml 文件中指定存储库的位置即可。 ","date":"2021-06-15","objectID":"/post/plat-qt-ifw/:5:0","tags":["PLAT","QT"],"title":"QT IFW","uri":"/post/plat-qt-ifw/"},{"categories":null,"content":"干货：实时数据库，内存数据库，关系型数据库比较 ","date":"2021-05-12","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/:0:0","tags":["PLAT","数据库"],"title":"数据库概念及选型","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/"},{"categories":null,"content":"1. 实时数据库 实时数据库是采用实时数据模型建立起来的数据库，用于处理不断更新的快速变化的数据及具有时间限制的事务处理.对实时性要求高的【时标型信息】的[数据库管理系统]. 1. 时标型数据并非仅仅指时间戳、值和质量码，还有一个很重要的属性，那就是及时性，及时性有两重含义，采样间隔和数据的新鲜度。时标型数据的价值随新鲜度降低而递减。1秒钟内的数据可以用来流程工业中的控制，5秒钟之内可以用来监视，半小时内的数据可以用来分析和优化，一天内的数据可以用来日报表，如果是半年前的数据，则只能做对比和追溯了。而得到数据的新鲜程度往往取决于采样频率，这就是为什么如此重视实时数据库的采样快速性。同时【采样的频率】还进一步决定了实时数据库保存信息的丰富程度。 2. 从另一个方面讲，实时数据库中存储的数据永远是滤波后数据，实时数据库就像一个低通滤波器。 实时数据库技术是实时系统和数据库技术相结合的产物，利用数据库技术来解决实时系统中的数据管理问题，同时利用实时技术为实时数据库提供时间驱动调和资源分配算法。 主要应用于工业监控，如：电力、石化、化工、钢铁、冶金、造纸、交通控制和证券金融等工业领域的监控。 特点： a. 时间约束:实时数据库是其数据和事务都有明确的时间限制的数据库。在实时系统中，具有时间约束的数据主要是来自于外部的动态数据，以及由这些数据求导出的新的数据。数据库中的数据必须如实反映现场设备的运行情况。 b. 事务调度:实时数据库系统的正确性不仅依赖于事务的逻辑结果，而且依赖于该逻辑结果所产生的时间。事务调度既要考虑事务的执行时间，也要考虑事务的截止期、紧迫程度等因素。 c. 数据存储:实时数据库主要承担系统所有实时数据的存储和管理，为相关的功能提供快速、正确的实时信息。为了达到实时性，实时数据库在系统运行过程中，应常驻内存，以保证读取速度。对于实时性要求不高的数据可存放在外存储空间。因此，在实时数据库设计时，要妥善处理时间与存储空间的矛盾，以保证系统的实时性。 d. 数据在线压缩:在实际的数据存储中，实时数据库还要解决如何高效处理海量数据的问题。如果数据被原封不动地存储势必需要大量内存和磁盘空间以及耗费大量的时间，因此必须对实时数据进行在线压缩存储。 ","date":"2021-05-12","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/:1:0","tags":["PLAT","数据库"],"title":"数据库概念及选型","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/"},{"categories":null,"content":"1.1. 核心技术原理 1.1.1. 整体架构 通过【现场适配层】适配现场的各种接口。然后通过【实时核心】，完成数据的采集、实时计算、报警计算、其它处理，实时数据被不断泵入【磁盘历史存储】，形成可追溯的历史信息，同时通过向【应用层】提供各种适配接口，支持各种开发语言和各种应用需求的访问。 1.1.1.1. 现场接口适配层（底层） 小型实时数据库（许多是号称自己是实时数据库的组态软件）均将核心和接口做在一起，用户使用起来较为简单，但如果出现任何一个不稳定的接口或局部异常，那整个实时数据库就崩溃了。 对于大型应用，这种结构也较难扩展。接口软件被独立出来，即可以与实时数据库核心集中部署在1台计算机上，也可以与部署在接口机上，在大规模应用的时候，接口的负载不会影响核心的稳定，同时任意一个接口出现Crash，都不会导致实时数据库整体宕机。从而提供了更好的可扩展性和稳定性。 影响接口效率因素:协议慢，网络状况，设备效率，工作站负载，底层软件质量。 接口程序内部主要有两部分：现场接口协议栈和位号分组（按照不同的频率分组）。 一般主动采集（还会增加一层缓存，影响效率）的频率都是1赫兹以下的（慢于1秒/次），更加快速的时候，均采用主动通知的方法，即当数据变化的时候，主动向实时数据库内核发送变化的数据，以达到更高效率。 1.1.2. 简化模型 实时数据库被简化成由多个接口、一个接口管理模块、一个组态模块、一个实时模块、一个高速缓存和一个历史模块组成，上面覆以应用接口。 1.1.3. 核心IO策略 实时数据库一般采用缓存来增加读实时数据的及时性，因此实时数据库核心中都有高速缓存。 通过接口的采集，高速缓存的数据得到不断的更新，而当上层读位号的时候，实时数据库通过返回缓存的值来快速响应。因此，读一般是异步的。但写则一般是同步的， 实时数据库不适宜对快速开关量的控制。 另一种则是波动较快的窄带控制，意味着必须将被控量控制在一个较窄的区域内，这时必须考虑时滞问题，如果时滞稳定，则可以按照控制理论采用抵消时滞或者前馈的方式获得较好的控制效果。而如果时滞变化很大，则通过实时数据库之上进行的控制则效果不明显了，很容易失控。 1.1.4. 核心调度策略 很少有实时数据库是单线程的，大型实时数据库中往往都有线程池，对于需要实时处理读、写、采集等任务的实时数据库核心，其调度策略必须慎重考虑。 首先，为难的是往往很难判断那些任务的优先级更高。一般，频率小的数据的优先级高，写的优先级高于读的优先级，采集的优先级高于读。 1.1.5. 实时数据库压缩算法 说到数据压缩，无非有损和无损。无损的一般通过各类近似霍夫曼编码的方法压缩数据，二有损则是采用线性拟合的方法。 1.1.6. 索引技术 ","date":"2021-05-12","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/:1:1","tags":["PLAT","数据库"],"title":"数据库概念及选型","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/"},{"categories":null,"content":"1.2. 选型 实时数据库系统选型 ","date":"2021-05-12","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/:1:2","tags":["PLAT","数据库"],"title":"数据库概念及选型","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/"},{"categories":null,"content":"2. 内存数据库 内存数据库就是将数据放在内存中直接操作的数据库。 它利用内存的【读写速度比磁盘快】、内存是【随机访问】而磁盘是顺序访问这两个特点。 将数据保存在内存中，在内存中模仿建立表结构和索引结构并针对内存特性进行优化，相比从磁盘上访问，内存数据库访问较快。 ","date":"2021-05-12","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/:2:0","tags":["PLAT","数据库"],"title":"数据库概念及选型","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/"},{"categories":null,"content":"3. 关系数据库 关系数据库是建立在集合代数基础上，应用数学方法来处理数据库中的数据。 ","date":"2021-05-12","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/:3:0","tags":["PLAT","数据库"],"title":"数据库概念及选型","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%80%89%E5%9E%8B/"},{"categories":["TOOLS"],"content":"vi 命令模式 ","date":"2021-05-11","objectID":"/post/tools-vi%E9%9D%9Evim/:1:0","tags":["TOOLS","VSCODE"],"title":"TOOLS VI非VIM","uri":"/post/tools-vi%E9%9D%9Evim/"},{"categories":["TOOLS"],"content":"输入:之后 `1,6 s/^/System.out.println(” 2,$ s/^/新增的字符串 注：此为2行至尾行 `% s/^/System.out.println(” 注：此为所有行 ","date":"2021-05-11","objectID":"/post/tools-vi%E9%9D%9Evim/:1:1","tags":["TOOLS","VSCODE"],"title":"TOOLS VI非VIM","uri":"/post/tools-vi%E9%9D%9Evim/"},{"categories":null,"content":"参考主键 参考易百教程 参考CSDN ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:0:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"1. 概念 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:1:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"1.1. 数据类型 SQLite使用更通用的动态类型系统。 在SQLite中，值的数据类型与值本身相关联，而不是与其容器相关联。 在SQLite中，没有一个单独的布尔存储类。一个代替办法是将布尔值存储为整数0(假)和1(真)。 在SQLite中，没有单独的类型来存储日期和时间。 但是可以将日期和时间存储为TEXT，REAL或INTEGER值. 1.1.1. 存储类 SQLite存储类比数据类型更通用一些。 例如：INTEGER存储类包括不同长度的6种不同的整数数据类型。 SQLite数据库中存储的值是以下存储类之一： 存储类 描述 NULL 表示值为空(null)值。 INTEGER 表示值是一个有符号整数，根据值的大小存储在1,2,3,4,6或8个字节中。 REAL 表示值是一个浮点值，存储为8位IEEE浮点数。 TEXT 表示值是一个文本字符串，使用数据库编码(utf-8，utf-16be或utf-16le)存储 BLOB 表示值是一个数据块，与输入的数据完全相同，二进制 1.1.2. 近似类型 SQLite支持列的类型近似性。列可以存储任何类型的数据，但是列的首选存储类称为它的近似性类型。 数据类型 相应的近似类型 INT INTEGER TINYINT SMALLINT（16bit整数） MEDIUMINT BIGINT UNSIGNED BIG INT INT2 INT8 INTEGER VARCHAR(n长度不固定，最大，4000) VARYING CHARACTER(n) NCHAR(55) NATIVE NVARCHAR(100) TEXT CLOB CHAR(n不超过254) TEXT BLOB - 未指定数据类型 NONE REAL DOUBLE DOUBLE PRECISION FLOAT DECIMAL(p,s)(精确值，小数位数) REAL NUMERIC DECIMAL(10,5) BOOLEAN DATE DATETIME NUMERIC ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:1:1","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"1.2. 主键 记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 选取主键的一个基本原则是：【不使用任何业务相关的字段作为主键】。 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有： a. 自增整数类型【最常用】：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； b. 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 [联合主键]：允许一列有重复，只要不是所有主键列都重复即可。 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:1:2","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"1.3. AUTOINCREMENT 序号 字段定义 是否可以自增 备注 1 INT PRIMARY KEY 否 字段值默认为NULL 2 INT PRIMARY KEY AUTOINCREMENT 否 3 INTEGER PRIMARY KEY 是 自增（引擎没有创建sqlite_sequence表）。值 = 此表最大值 + 1，故可与之前删除的值重叠；当超过最大值时，会随机找一个没被使用的值 4 INTEGER PRIMARY KEY AUTOINCREMENT 是 自增(引擎自动在sqlite_sequence表中添加一条记录)，值 = sqlite_sequence表中对应值 + 1。故一般不会与之前删除的值重叠；当超过最大值时，会丢出一个SQLITE_FULL的错误 自增的使用，必须满足以下两点: a. 只能用于整型（INTEGER）字段，INT类型是不可以； b. 只能用于PRIMARY KEY字段； 然后，插入的SQL就是：INSERT INTO Product VALUES(NULL, '產品名稱'). 主键为NULL，就会自动自增填充。 1.3.1. 自增主键清零 当SQLite数据库中包含自增列时，会自动建立一个名为sqlite_sequence的表。这个表包含两个列：name和seq。name记录自增列所在的表，seq记录当前序号（下一条记录的编号就是当前序号加1）。 如果想把某个自增列的序号归零，只需要修改UPDATE sqlite_sequence SET seq = 0 WHERE name='TableName'或者DELETE FROM sqlite_sequence WHERE name='TableName'; 要想将所有表的自增列都归零，直接清空sqlite_sequence表就可以了DELETE FROM sqlite_sequence. ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:1:3","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"1.4. 索引 简单地说，索引是一个指向表中数据的指针。 索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。 1.4.1. 单列索引 CREATE INDEX index_name ON table_name (column_name); 1.4.2. 唯一索引 CREATE UNIQUE INDEX index_name on table_name (column_name); 1.4.3. 组合索引 CREATE INDEX index_name on table_name (column1, column2); 1.4.4. 隐式索引 隐式索引是在创建对象时，由数据库服务器自动创建的索引。索引自动创建为主键约束和唯一约束。 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:1:4","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"1.5. 触发器 SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。 SQLite 只支持 FOR EACH ROW 触发器（Trigger）（操作语句每影响到一行的时候就触发一次），没有 FOR EACH STATEMENT 触发器（Trigger）。 -- 创建触发器 CREATE TRIGGER supplier_change_trigger AFTER INSERT -- 触发的操作（BEFORE|AFTER）（INSERT|UPDATE|DELETE）（OF column_name）指定哪一个字段 ON supplier_new -- 表名 BEGIN -- 到END之间是触发执行的语句 insert into supplier_data_change (info,updateTime) values (-- 记录供应商变化的时间和id '新增供应商ID='||(select max(id) from supplier_new), datetime()); END; -- 删除触发器 DROP TRIGGER trigger_name; ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:1:5","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"2. 附加数据库 ATTACH DATABASE file_name AS database_name福建一个数据库。 DETACH DATABASE database_name解除附加一个数据库。 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:2:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"3. shell命令 sqlite3 db文件打开一个数据库文件,不存在则创建。 sqlite3 test.db \u003c sql文件打开数据库文件，并执行sql文件中sql语句。 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:3:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"4. sqlite中命令 .help 显示帮助信息； .read sql文件对打开的数据库文件执行sql文件中语句。 .tables列出数据库文件中的所有表。 .output xxx.sql指定到处的sql文件。 .dump导出。 .exit退出。 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:4:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"5. sqlite客户端工具 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:5:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"5.1. sqlitestudio 开源，C++和Qt编写。 5.1.1. 使用 【注】多个进程可以同时打开同一个数据库。多个进程可以同时做一个SELECT。但是，只有一个进程可以在任何时刻对数据库进行更改。所以，如果要多个进程同时更改一个数据库的话，最好是执行sql之前创建连接，执行结束之后就断开连接。 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:5:1","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"6. C++调用 ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:6:0","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"6.1. SOCI/soci SOCI is a database access library for C++ that makes the illusion of embedding SQL queries in the regular C++ code, staying entirely within the Standard C++. ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:6:1","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"6.2. SQLiteWrappers ","date":"2021-05-11","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/:6:2","tags":["PLAT","数据库","SQLITE"],"title":"Sqlite","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite/"},{"categories":null,"content":"代码结构 tool.py：命令行工具，从终端窗口来操作数据库 interface.py：使用二叉树实现方式定义了DBDB类-\u003e实现Python的字典接口。因此才能在Python程序中使用DBDB logical.py：逻辑层，键值存储的抽象接口 LogicalBase：逻辑层更新的接口（get、set、commit） ValueRef：指向存储在数据库中的二进制数据的Python类（间接引用-\u003e避免一次性全将数据存到内存中） binary_tree.py：逻辑接口之下的实体二叉树算法 BinaryTree：实现二叉树（get、insert、delete、key/value对），一成不变的 -- \u003e 更新 --\u003e返回一新的树。 BinaryNode：二叉树的一个点 BinaryNodeRef：实例化的ValueRef，可以 serialise and deserialise（连载和丢弃）一二叉树节点（BinaryNode） physical.py：实体层，Storage类提供持久性（大多是只可加的） ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-500-dbdb/:1:0","tags":null,"title":"PROGRAM 跨语言 架构 500 DBDB","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-500-dbdb/"},{"categories":null,"content":"总结 【尽量不要使用类库】这样可以增加可移植性。 先考虑逻辑，然后抽象接口； 将大的功能模块拆分成小模块。 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-500-dbdb/:2:0","tags":null,"title":"PROGRAM 跨语言 架构 500 DBDB","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-500-dbdb/"},{"categories":["PROGRAM"],"content":" QtCreater是插件设计架构，由插件管理器（负责插件的加载,管理,销毁等工作）和一堆插件（有一个叫core的插件,是QtCreator最基础的插件,提供了向界面增加菜单等功能）组成。 QtCreator的核心系统是由PluginManager和Core插件构成.前者负责插件的管理工作,后者负责提供QtCreator的最小功能集合,在PluginManager面前Core是当做普通插件进行加载,在自定义插件面前Core就是一个基础功能库,使用该库可以扩展QtCreator的功能. QtCreator的所有功能,全是由插件实现,这种思路的优点是简化了顶层业务,也就是插件管理工作的逻辑,在那里只有PlunginManager和Plugin,缺点是增加了加载插件的复杂度,因为基础库这个插件需要被其他插件依赖,所以creator在插件加载时就必须要考虑插件之间的【依赖性】。 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:0:0","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"插件 插件都需要继承IPlugin的接口，插件是由描述文件和继承IPlugin的类库组成。 主要功能 A、在一个类中实现ExtensionSystem::IPlugin接口。\rB、使用Q_EXPORT_PLUGIN宏导出插件类。\rC、提供一个pluginspec插件描述文件，用于描述插件的元信息。\rD、向其它插件暴露一个或多个对象。\rE、查找其它插件暴露出来的可用的一个或多个对象。\r 主要接口 //初始化函数,在插件被加载时会调用 bool IPlugin::initialize(const QStringList \u0026arguments, QString *errorString) //在所有插件的initialize函数被调用后,调用该函数,此时该插件依赖的插件已经初始化完成 void IPlugin::extensionsInitialized()\r//在所有插件的extensionsInitialized函数调用完成以后进行调用 bool IPlugin::delayedInitialize()\r ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:1:0","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"暴露对象 暴露对象是存在于插件管理器对象池中的对象。 插件暴露出的对象会加入到PluginManager的对象池。PluginManager的allObjects()函数用于获取对象池中所有QObject对象的指针列表。 一个对外暴露的对象是由一个插件对外暴露的QObject（或其子类）的实例，暴露对象存在于对象池中，并且可供其它插件使用。 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:1:1","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"契约 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:2:0","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"管理插件 从main函数开始看,能够找到下面这个函数，PluginManager::loadPlugins()此函数为插件加载的机制。 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:2:1","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"使用核心系统的功能 使用了核心系统的交互是在获取主编辑区那里,剩余就是插件内部的处理逻辑了 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:2:2","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"扩展 扩展一下,在消息中间件,微服务盛行的今天,核心系统和插件完全可以设计成不在一个进程当中,我们可以把核心系统和插件之间通过远程调用的方式进行联系,核心系统与插件均可设计为单个进程或者服务,让整个系统的部署更加灵活,单个插件的问题也不会影响到整个系统.当然,核心系统与插件之间的发现使用机制,是需要我们结合实际使用场景进一步深入思考的. 本文来源：码农网 本文链接：https://www.codercto.com/a/39708.html QtCreator插件开发（三）——QtCreator架构 ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/:3:0","tags":["PROGRAM"],"title":"QTCreater","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-qtcreater/"},{"categories":["PROGRAM"],"content":"插件设计架构 核心系统 核心系统包含两部分功能：1.最小功能集合,提供给各个插件模块使用,也就是插件如何使用核心系统的功能进行功能扩展;2.插件模块的生命周期管理。 插件模块 插件模块用于增强或扩展核心系统以产生额外的业务功能,插件模块应该是高度内聚,尽量避免产插件之间的依赖. 契约 包含了核心模块和插件模块的通信协议,【模块之间不建议发生任何依赖,也可以发生依赖，如QtCreater】.常见通信方式包含插件会提供一些虚函数,供核心系统中的模块加载器进行初始化,销毁等工作,核心系统提供一些函数,供具体插件模块使用,还可以通过soap等远程通信方式完成两者之间的通信. ","date":"2021-05-08","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:0:1","tags":["PROGRAM"],"title":"架构设计模式","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E6%9E%B6%E6%9E%84-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["PROGRAM"],"content":"1. GPL 只要在一个软件中使用(包括类库引用、修改后的代码或者衍生代码)GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。 GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 ","date":"2021-05-06","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/:1:0","tags":["PROGRAM"],"title":"开源协议","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"categories":["PROGRAM"],"content":"1.1. 项目 pyqt5. ","date":"2021-05-06","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/:1:1","tags":["PROGRAM"],"title":"开源协议","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"categories":["PROGRAM"],"content":"2. LGPL LGPL 允许商业软件通过引用(link)(动态连接)的方式使用LGPL类库，而不需要开放源代码。 ","date":"2021-05-06","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/:2:0","tags":["PROGRAM"],"title":"开源协议","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"categories":["PROGRAM"],"content":"2.1. 项目 QT pyside6 ","date":"2021-05-06","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/:2:1","tags":["PROGRAM"],"title":"开源协议","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"categories":["PROGRAM"],"content":"3. MIT 只在源码或者文档中对用到别人的代码部分注明出处、作者、使用了MIT协议即可。 ","date":"2021-05-06","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/:3:0","tags":["PROGRAM"],"title":"开源协议","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"categories":["PROGRAM"],"content":"项目 [BabyOS] ","date":"2021-05-06","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/:3:1","tags":["PROGRAM"],"title":"开源协议","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"1. NTP 毫秒级。5ms以内的精度。 非超高精度设备，不建议使用PTP设备。 NTP是在应用层级别实现的. ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:1:0","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"1.1. ntp NTP是用来使计算机时间同步化的一种协议，其同步时钟源不仅仅局限于网络的时间服务器，还包括时钟设备，如石英钟，原子钟，【GPS接收器】等。NTP服务器软件将这些时钟源抽象成相应的数据结构，对应于不同的内存地址，通过读取该地址中的信息，进行统计学算法的处理来同步计算机的时钟。 1.1.1. 交叉编译 ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:1:1","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"2. PTP 微秒级。 PTP是在硬件级实现的(硬件支持时间辍，减少了应用到硬件的耗时误差). ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:2:0","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"2.1. ptpd ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:2:1","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"2.2. linuxptp ptp4l:Implementation of PTP (Ordinary Clock, Boundary Clock) phc2sys:Synchronize two clocks (typically PHC and system clock) pmc (PTP Management Client):Send PTP management messages to PTP nodes 利用LinuxPTP进行时间同步(软/硬件时间戳). ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:2:2","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"3. GPS 参考基于GPS北斗卫星授时系统和NTP网络授时服务器的设计与开发充分利用了NTP服务器软件对GPS时钟源的支持，采用[串行数据]和[秒脉冲(PPS微妙量级)]相结合的方式来校准时间，校时精度大为提高. ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:3:0","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"3.1. 与NTP结合方案 GPSD(GPS Daemon)是一个守护进程软件，用来处理GPS接收单元解码出的数据。基于GPSD综合校时的具体过程：GPS天线接收GPS信号，传递给G591芯片进行解码，每秒输出NMEA0183协议格式的数据和PPS信号，MAX 232完成电平转换之后，分别经由串口的RXD和DCD端传递给计算机；GPSD软件经过处理，将准确的时间信息写到特定内存段中；NTP服务器软件通过共享内存的方式读取该地址段中的时间信息，进而完成校正系统时钟的工作。 参考linux pps驱动实现gps授时 ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:3:1","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":null,"content":"3.2. GPS模块选型 – JRC G591 – ","date":"2021-04-29","objectID":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/:3:2","tags":["PLAT","LINUX"],"title":"时钟同步","uri":"/post/plat-linux-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/"},{"categories":["项目管理"],"content":"1. 增加/删除文件 git add -p添加每个变化前，都会要求确认；对于同一个文件的多处变化，可以实现分次提交； ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:1:0","tags":["项目管理","GIT"],"title":"GIT基本操作","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"categories":["项目管理"],"content":"2. 查看更改 git status查看文件在工作区（Workspace）与本地仓库(Repository)以及暂存区(Index/Stage)与本地仓库(Repository)之间的变化。 git diff查看工作区与暂存区的差异。 git diff --cached查看暂存区与本地仓库的区别。 git diff HEAD查看工作区与本地仓库之间的差异。 git show [提交ID]查看某一次提交修改的内容。 git log -- [文件名]按照文件查找日志。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:2:0","tags":["项目管理","GIT"],"title":"GIT基本操作","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"categories":["项目管理"],"content":"3. 版本管理 git describe --tags --always --dirty=\"-dev\"生成基于上一个tag的版本号。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:3:0","tags":["项目管理","GIT"],"title":"GIT基本操作","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"categories":["项目管理"],"content":"git子模块 git submodule foreach它能在每一个子模块中运行任意命令. ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:4:0","tags":["项目管理","GIT"],"title":"GIT基本操作","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"categories":["项目管理"],"content":"学习 极客时间 《项目管理实战20讲》（完） 项目管理能力，成为一个职场人士的【必备技能】，具备项目管理能力的程序员，会在这个程序员严重同质化的局面下，拥有更多的竞争优势。。 项目管理【不同于技术管理】，项目管理的思维和方法，构建出了一套【多人协同】的底层操作系统，个人-》团队。 从头到尾把事做成。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:0:0","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"1. 如何学习 体机用：体对应于项目管理的知识体系。用对应于各种项目管理实践。机不光指时机，同时还意味着环境和条件，只有将知识技能和具体的场景相结合，才能发挥出真正的效用。对机的把握是核心能力。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:1:0","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"学习方法 破除魔障（一步一步，肯定行）。 每次一小步（不积奎步，无以至千里）。 先找找感觉（每天唱谱，左右手单手练习）。 “足”量的刻意练习（10000小时）。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:1:1","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"2. 学习路径 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:2:0","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"2.1. 误区 2.1.1. 【凡事恨不得事必躬亲】想办法影响他人去把事情做好 第一个层次-让他人知道要做（Awareness）：单方面的工作交代和告知，停留在浅层次的信息传达上。 第二个层次-让他人有动力做（Desire）：讲清楚为什么要做，为什么要现在做，获得理解及认同，激发团队的动力。 第三个层次-让他人有能力做（Ability）：项目成功关键路径上的核心能力缺失，要当作最高优先级的风险管理。短期引入人才、长期培养人才。 2.1.2. 【追在别人屁股后面做监工】明确目标，建立机制 明确目标，建立机制，并让这个机制运转起来，最终在项目组形成一种良性的秩序。 【始终依靠流程和规则】来约束大家的行为。 然后，就可以集中精力去做愿景驱动、激励团队等更高层面的工作。 2.1.3. 【拿着锤子看哪里都是钉子】 不要着急使用原来没有的工具和方法。 要加强沟通，看【最需要什么】。 1. 时间、成本、质量、范围这几个因素，哪个最重要？哪些允许有一定调整空间？\r2. 各个角色的痛点在哪儿？哪些需要最先解决？背后的原因是什么？\r3. 对痛点的改进是不是有真实需要？需求的迫切程度如何？\r4. 老板或项目发起人对项目管理以及你本人的定位怎样？是否沟通达成一致？\r5. 打算引入新方法或工具？如何引入，自上而下全面推广？还是自下而上一步步优化？最有可能从哪个问题切入？\r ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:2:1","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"2.2. 常识（项目管理知识框架） 国际上三大项目管理的研究体系，欧洲的IPMA，英国的PRINCE2和美国的PMI（国内普及度最高）。 本文主要讨论PMI 1. 项目是为创造独特的产品、服务或成果而进行的临时性工作。\r2. 项目管理就是将各种知识、技能、工具和技术应用于项目活动，以满足项目的要求。`保目标、助决策、提效能、促协作`(网易)。\r 十大领域五大过程组，一横一纵两条主线。 2.2.1. 十大领域（十个角度，包含项目运作的方方面面）【脑图工具】 2.2.1.1. 干系人管理（辅助领域） 哪些人是你的干系人？（项目发起人等） 是否存在潜在的干系人？（赞助方等） 分析完干系方之后，如何管理干系人的期望和影响？（谁来拍板、什么方式参与等） 2.2.1.2. 范围管理（核心领域）做什么 主要任务是搞清楚到底要做到哪些事，才能更好地达成各方的期望。 确保围绕预期目标来设计相应的【方案（概要方案+详细方案）】，进一步确定前、中、后的工作。 2.2.1.3. 进度（时间管理）（核心领域） 规划好阶段性步骤，同时明确每个里程碑的目标成果和时间安排。 2.2.1.4. 成本管理（核心领域） 从全局视角去思考，更有效地管理各项投入。预算多少？什么时候到位？怎样才能用在刀刃上？ 2.2.1.5. 质量管理（核心领域） 确定项目成功的标准是什么？需要引入哪些流程和方法，保障质量？ 2.2.1.6. 资源管理（辅助领域） 有哪些资源可以使用。渠道、经费、人员等。 2.2.1.7. 采购管理（辅助领域） 思考哪些需要外部采购？经费受限的话，是否可以通过交换？ 2.2.1.8. 沟通管理（辅助领域） 使用什么方式沟通？沟通频率？如何保持信息的高效传递？ 2.2.1.9. 风险管理（辅助领域） 提前做好系统性的风险识别，分等级制定应对策略。 2.2.1.10. 整合管理（整体领域）如何实现整体最优 如何去统筹全局，整合并协调各个环节的利益冲突和工作安排。 2.2.2. 五大过程组 PDCA环（戴明环）：规划（plan）、执行（do）、检查（check）和行动（act）。周而复始、螺旋上升。 五大过程组基于PDCA的法则。 2.2.2.1. 启动过程组 启动过程组意味着正式开始一个项目，或者是开始一个项目中的新阶段。 包括识别干系人和制定项目章程两个子过程。 2.2.2.1.1. 识别项目中的四类干系人 干系人分析是指对项目干系人进行分析和归类，有针对性地规划管理其核心诉求和期望，让干系人更好地参与项目，对项目产生积极影响。 按照在项目上的权利和利益相关度对干系人进行划分，分成四类： 1. 高利益-高权力：项目发起人（项目资助人），天然支持者，重点管理：\ra. [目标]发起这个项目的背景和初衷是什么？项目组的整体目标是什么？如何知道我们做到了？\rb. [资源]有哪些资源短缺或限制因素？涉及哪些外部资源的管理？哪些是项目获得成功的关键资源？\rc. [流程]项目组的决策流程是怎样的？需求如何通过审核？如何确认变更呢？\rd. [团队]如何考虑项目团队的组织结构的？团队组建多长时间了？各个角色的合作状况如何？在团队及组织结构上，是否有需要特别关注的状况？\re. [沟通]通过什么渠道了解项目状况？希望我以什么样的方式跟你保持信息同步？哪些风险和问题需要经过特别审批？\rf. [期望]最看重项目的哪些因素(进度、质量、成本、范围)？在极端情况下，这些要素如何排序？希望我在承担项目管理之后，给项目及团队的哪些方面带来提升？\r2. 高利益-低权力：项目组成员。核心是做到项目事项的随时告知，及时通报项目的进展和困难。\ra. [流程]项目计划一般如何确定？计划的变更是否得到周知？组内的任务分配、跟踪流程是怎样的？项目的文档管理、发布流程、需求变更流程是怎样的？分别使用了哪些工具？\rb. [沟通]你得到了与你目前工作相关的足够的项目北京信息了吗？如果没有，你还希望知道哪些方面的信息？\rc. [期望]你所知道的项目组成员的信息渠道有哪些？你需要参加哪些项目会议？团队成员需要参加哪些会议？\r3. 低利益-高权力：职能经理。管理着资源（人）\ra. [反对者]建立信任，化解敌意。通过积极地聆听，了解对方的内心想法，正确理解对方的逻辑，才有可能进一步对其施加影响。\rb. [支持者]明确知道，他们各自对项目不同的期望和诉求，有意识地创造更多的空间和机会，让他们深度参与。\rc. [中立者]有精力的话，进一步将其转化为支持力量。\rq1. [团队]你的团队成员构成和分布怎么样？总人数、资深工程师的分布情况，团队成员的稳定性怎么样？不同成员之间如何分工？\rq2. [目标]你们团队今年的整体目标是什么？目前的完成度？对完成目标的信心如何？有哪些潜在风险？\rq3. [沟通]你所知道的项目组成员的信息渠道有哪些？你要参加哪些项目会议？团队成员需要参加哪些会议？\rq4. [合作]你的团队与其他团队之间的合作是否顺畅？不同角色的团队之间的沟通渠道有哪些？你的团队需要的支持有哪些？\rq5. [风险]目前项目团队的最大风险和问题是什么？在你们团队的工作中，返工的情况多吗？一般是什么原因导致的？\rq6. [期望]你希望我承担项目管理工作后，给项目及团队带来哪些改变？\r4. 低利益-低权力：外围支持人员。复杂度低而且非核心的工作。提前约定好，每天或每周进展汇报的格式和内容即可，确保他们的工作职责和任务明确，进展符合预期就可以了。\r 干系人分析之后，从而制定出合理的【干系人沟通计划】。 2.2.2.1.2. 制定项目章程【通过启动会公开确认】 【启动会】好比一个大型的推土机，面对项目组全员，正式宣告一个新项目或者新阶段的开始，公开确认项目章程，包括明晰各方干系人的期望和诉求，设定愿景目标和重要里程碑，确定责任分工和沟通机制。省去非常多的后期沟通成本 如果跨部门，【启动会】可以邀请更高的管理层出面，讲清楚项目的背景、目标和重要性。 【启动会】也是项目管理人员的公开授权方式，让你以后的推进工作更容易开展。 2.2.2.2. 规划过程组 规划把愿景目标转化为【可落地的行动方案和工作路线】：明确项目范围、确定里程碑、做好准备。 对一个复杂的项目，规划通常是一个渐进明晰的过程，近期的规划往往是最具体的，需要拆分到具体版本和工作项。远期的规划比较模糊。 规划需要动态细化、不断更新。 计划是“市场需求或发起人的期望”和“团队生产力”之间平衡的结果。从本质上来讲，计划是用来对焦的，做计划，是个集体对焦的过程。 2.2.2.2.1. 排除计划中的‘延期地雷’ 不够具体。 1. 好的计划，不仅要给出时间节点，还要给出依据和来源，这样才能更有效地对焦。\r2. 【WBS工作分解（描述思路的规划和设计工具）】，可以清晰表示各项目工作之间的相互联系，帮助更高效地管理项目。\r3. 创建WBS的过程，就是把项目工作按【阶段可交付成果】分解成较小的、更易于管理的组成部分的过程,一般以3个工作日一项任务为尺度。但是也不能是任务的简单罗列，需要识别关键资源和关键依赖，还要考虑研发之外其他环节。\r 不够全面。 1. 识别依赖并画出关键路径。（甘特图）\r2. 再叠加上时间轴图，标明其他合作环节（比如评审会议，上线时间等）。\r 不够准确。 1. 定义完成标准：就是某个时间点需要完成的事项列表或者应该达成的某项指标。任何重要时间节点，都应该有一组完成标准。越早越好。\r2. 常见的几个关键时间节点：需求/设计确认（反馈意见数小于多少）；功能完成/提测（单元测试覆盖率、静态代码分析分数等）；里程碑完成。\r 没有共识。 1. 没有达成共识的计划，是不具备任何效力的。需要达成共识并公开透明。（规划会）\r 不够即时。 1. 及时调整变更。做计划永远是个反复修正、渐进明晰的过程。重要的是，每一次进行调整，都要确保项目中的每个人知道当前的计划是什么，调整计划需要怎样的决策过程，需要谁参与。并公开告知所有的项目成员。\r 2.2.2.3. 执行过程组 前两个过程组做好了，这一过程相对轻松，重在整合资源，推动项目落地。 在项目执行过程中，【想要降低偏差、减少返工】，你就需要构建系统能力，在产品研发的整个过程中，建立起【真正闭环反馈】的产品验证机制。 三种实用的方法。 2.2.2.3.1. 方案评审（OARP评审） 需求评审、交互评审、视觉评审都是非常基本的闭环验证方法。 要想执行中不走样，就必须把方案评审做到位。评审的精髓不在会，而在于背后的决策机制。 OARP（Owner, Approver, Reviewer、Participant）决策机制: 负责人（Owner）负责给出方案，组织各方讨论并【推进】作出最终的决定；\r批准者（Approver）最终批准者；\r审核者（Reviewer）负责人和批准者挑选出来的审核人。审核者有责任对文档进行讨论分析、并提出反馈意见，负责人必须重视并给予回复。\r参与者（Participant）其他提供意见的人。参与者会收到文档的相关信息，可以对相关问题作出反馈。\r 类型 Owner Approver Reviewer Participant 确认方式 需求稿 策划人员 产品负责人 产品/设计/开发/测试Leader 项目组 会议+邮件 需求变更 策划人员 产品负责人 产品/设计/开发/测试Leader 项目组 任务流程 设计稿 设计人员 产品负责人 产品/设计/开发/测试Leader 项目组 会议+邮件 开发设计文档 开发人员 技术负责人 开发/测试/运维Leader 项目组 邮件 测试计划/测试用例 测试人员 技术负责人 开发/测试Leader 项目组 会议 2.2","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:2:2","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"2.3. 硬技能（项目的完整流程） 五大过程组的流程，已经融入之前的'常识'中。 2.3.1. 需求变更：化解程序员的\"头号噩梦” 流程：发起申请——变更委员会评估——接受变更、调整计划——公布。 2.3.1.1. 达成最小共识，变更是有代价的 严格按照变更流程； 最开始，做好需求评审，对需求质量把关。 2.3.1.2. 源头治理：一次把事情做对 “小黑屋+deadline”，产品和设计人员，头脑风暴，把事情做对。 2.3.1.3. 快试错，不可抗力巧应对 来自大老板或者大客户的需求，就是不可抗力。 不要直接顶回去，要去剖析、把握和满足老板或客户的真正诉求。 成立需求应急响应小队，快速试错，用数据说话。 2.3.2. 风险管理：如何系统化应对风险？ 2.3.2.1. 系统化风险识别 风险识别的主体，应该包含项目中的团队成员在内的各方干系人。 系统化的风险识别，是一个反复进行的过程，从构思阶段开始，贯穿项目规划和执行的始终。 项目的典型风险列表： 识别风险的输出，及时初始的【风险登记册】：包括已知的风险清单，以及潜在应对措施清单。对于已识别的每个风险，都要评估其概率（发生的可能性）和影响（对项目目标进度（\u003e20%高风险）、成本（\u003e40%高风险）、范围、质量的潜在影响），并进行优先排序。 2.3.2.2. 冰山下的风险（不可知的风险） 没有人反馈风险，不代表没有风险（缺乏沟通渠道；提出来也没用；老板认为自己没有能力等）。 一个优秀的项目经理，必须是优秀的“情报人员”。需要一个真诚的心，去关注项目中的每个角色、每个成员的需求，理解他们的困难，愿意为他们提供发展的机会，帮助他们去获得更大的成功。 你识别的风险越多，项目的风险就越低。 2.3.2.3. 风险应对措施 对于发生概率很高的严重风险，一定要提前准备风险应对【方案】和危机应【预案】。 在项目排期是，要确保相应的故障演练计划，并且做好充分的准备。 每周的项目状态同步会议上，对风险进行再评估，并通过周期性的风险审查，来识别新的风险。 2.3.2.4. 树立正确的风险观 风险的另外一面是“机”。 2.3.2.4.1. 治未病，建立系统性保健机制 致力于持续改善人与人之间的互动品质，提升项目团队的健康度。 经常匿名的问卷收集或访谈，定期做一场开诚布公的复盘会。 问卷\r1. 对这个版本研发过程的综合评分（迭代方式、工作量、工作压力、团队配合、时间管理等各个方面），反映了过程满意度。\r2. 对这个版本功能设计的满意度，即产品认可度。\r 坚持在多个版本中反复使用，积累数据，回顾趋势。 2.3.2.4.2. 积极管理致命风险（往往在一开始就埋下了） 挖掘出这些致命风险，把他们变成可见的，可谈的。 正视风险，不村侥幸心理。 在项目的核心团队中，周期性地树立和同步风险状态。 2.3.3. 质量管理：一次把事情做对 程序员们只有27%的时间在做真正产生价值的编码工作。20%的时间，是在做需求质量和代码质量问题所引发的Bug修复、返工和紧急上线工作。 质量成本分为两类：一类是事前防止失败的一致性成本；一类是事后处理失败的非一致性成本，包括内部Bug引发的返工成本，以及外部Bug导致的用户侧成本。 【鼓励开发人员通过各类技术手段从上游保障质量】，【事后检查处理的代价其实是最高的】。 实际上，质量是规划、设计、建造出来的，不是检查出来的。预防高于检查，预防错误的成本通常比在检查中发现并纠正错误的成本低很多。 一次性把事情做对的成本是最低的，但是，就意味着，我们要有意识地提升预防类工作的占比，从根本上降低内部bug率和外部bug率。 2.3.3.1. 质量规划、明确标准 规划质量，是识别项目及产品的质量要求和标准，并确定用哪些保障方法、改进措施来达到这些标准的过程。 在业务生命周期的不同阶段，质量标准应该是动态变化的。 只能结合具体项目和具体阶段的质量诉求，对质量的标准进行合理定义。 定义好了质量标准，需要思考，在整个项目进程中，需要规划好哪些质量保障活动，以很好地达到这个标准：特别关注研发过程中的质量保障手段。 1. 适当的编码规范；\r2. 提交规范；\r3. 分支规范；\r4. 设计代码准入标准（静态扫描、覆盖率测试、冲突检测，版本检测等）；\r5. 确保代码Review；\r6. 单元测试；\r7. 接口验证；\r8. UI验证。\r 质量作为目标的一部分，达到要求是最重要的，不需要追求质量的无止境提升。质量终究也是有代价的，是否够用则取决于项目目标和要求。 2.3.3.2. 质量分析、追根溯源 质量分析，指识别项目运行期间，整体质量上遇到的问题和制约因素，分析根本原因，并制定相对应的预防措施和解决方案。 每月坚持开Bug分析会； 持续进行内部Bug分类；引入阶段分类（需求不清、设计缺陷、逻辑错误、测试遗漏、变更引发、历史遗留）、类别分类（功能、性能、界面、兼容性） 建立质量大盘，拉通不同业务线或模块的【每月Bug趋势】。 2.3.3.3. 质量控制、层层卡点 将一些明确下来的质量规范和做法，真正落地到各个环节。【卡点的在线工具化】 CI/CD。 质量控制和卡点行为，也要结合项目的质量要求和团队的质量成熟度，一层一层地加强质量把关和收口。 2.3.4. 高效会议：项目中要开好哪些会议 断舍离，只开最有必要的会，会而有议，议而有决，决而有行。 有意识地选择，最适合项目现阶段状况的会议。 2.3.4.1. 项目中的重要会议 启动会（誓师大会）（启动过程组） 1. 启动会的目的是清晰目标，明确授权；\r（WHY）充分理解项目背景、目的和意义，才能更好地唤起团队的参与热情。\r（WHAT）描绘蓝图，设定清晰的愿景。\r（HOW）明确团队之间的责任分工以及合作公约。\r2. 方面：\r1. 项目背景\r2. 项目目标\r3. 项目范围\r4. 里程碑计划\r5. 主要风险\r6. 组织架构\r7. 责任分工\r8. 流程机制\r9. 沟通方式\r10. 支持工具（任务管理、文档管理、代码管理的工具）\r 评审会（需求评审、方案评审、需求变更评审，螺旋上升） 每日站会 1. 关键是还政于民，满足的是【团队的自组织需要】，而不是leader的监控需求。\r2. 自己决定站会时间；轮流主持人。\r3. “三张牌”式站会法：\r1. 红牌。随时喊停，避免过度讨论，每个人都有机会。\r2. 黄牌。打断讨论，进行提问。\r3. 绿牌。发言权，每次只有一个人发言，按顺序，发过言之后，归还给主持人。\r 项目周会（人数少的话，不需要项目周会） 1. 目的是解决整体计划层面、跨团队协同配合的问题。（负责人参与或全员参与）\r2. 除了常规的各角色进度和风险同步之外，还需要根据项目组每个时期的整体阶段性重点，来设置相应的环节，让大家清晰地感受到项目组明确的导向，也就是什么是当前最重要的。\r 复盘会（螺旋上升） 2.3.4.2. 保障会议品质的关键 不要盯着会议的数量，而是要追求会议的品质。 2.3.4.2.1. 明确会议的边界 每个会议都有【特定的主题和目的】，并有【明确的参会人员范围】，这个就是会议的边界。 对于哪些与主题不相干的议题，要坚决舍弃。 确保个部分的进展信息在会前统一提交，会议当场只说重要问题、风险及需要支持的地方； 确保会议当场严格围绕主题开展，对偏离主题的讨论，及时叫停。 2.3.4.2.2. 建立会议规则 对于行为（迟到，请假、拖堂、跑题等）建立规则。 2.3.4.2.3. 做好会后跟进 及时汇总讨论的结果，形成会议结论。 会后有跟进项目，直接进任务系统，确保跟进到底。 会议纪要明文呈现，下次会议统一回顾。 2.3.5. 故事案例：引入变化 要想引入变化，简单来说，需要“天时、地利、人和”。 这个变化，必须是【解决团队大家的问题】，并不是好才引入。 2.3.5.1. 天时 合适的时机。 实际上，问题并不等于时机，只有把【问题和痛点】关联起来，才能形成一个好的时机。 所谓痛点，就是必须及时解决的问题，包含着强烈的迫切感。判断是否是痛点的标志，就是看这个问题，如果不解决，对方是否会很苦恼、很痛苦。 【要想促发别人的行为，必须换位思考，去体会和抓住他的痛点】。 1. 访谈法，直接问。\r2. 观察法。判断是不是伪痛点。去观察那些花他时间和精力最多、他反复强调却又没很好解决的问题，那些才是真正痛点。\r3. 同理心和聆听。\r 在变革的早期，最重要的就是寻找到早期支持者。围绕着你想要引入的变化，击中几个重要干系人的痛点之后，这个世纪就到了。 2.3.5.2. 地利 结合团队的实际情况，而不是照搬理论或者所谓的“最佳实践”。 结合每个项目团队的现状，做好本地化的场景适配，这样才能获得好的效果。 也并不是向环境妥协，而是创造一个最小阻力的落地方法，先快速地跑起来，让团队感受到变化带来的闭环成效。 2.3.5.3. 人和 企业变革失败的最常见因素就是人的阻力。（与生俱来的对变化的情绪反应） 所以要多聆听彼此，充分理解，找到共同的出发点。（对一些事情，不同的人去看，会产生完全不同的看法） 在沟通时，你要因人而异，针对不同的人，采取不同的策略。 1. 首先，先判断每个人的立场。立场不同，看问题的视角就不同。\r2. 把变化涉及到的干系人，按照角色和层级做个初始划分，思考下不同区域的人，会怎么看待这个变化带给他的影响（找到更多的积极因素，对消极因素，也要提前引入相应的工具或方法来规避或改善）。\r3. 所以，在大范围公布并引入变化之前，与关键角色进行一对一的沟通，是更稳妥的做法。\r 引入变化的过程中，面向全员的正式公开沟通，一般会【放在最后，水到渠成】。 2.3.6. 故事案例：敏捷 2.3.6.1. 为什么引入敏捷 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:2:3","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"2.4. 软技能（沟通协作） 2.4.1. 向上沟通：三个误区 2.4.1.1. 误区一：所有问题，都自己抗 迈过自己内心的那道坎，主动大胆地发起沟通，是做好向上沟通的第一步。有些问题已经严重到不属于自己可以抗的级别了。 不管通过什么途径，我们必须时刻从大局出发，让这些项目关键信息，及时有效地流动，保障及时有效的决策。 当真正重要、紧急的事情发生时，一定要确保第一时间沟通。记住，你不需要所有问题，都自己抗。 2.4.1.2. 误区二：只知道吐槽，不知道争取 当团队和管理层之间关系紧张时，很多项目经理会特别容易掉进一个误区：尽自己的努力帮团队解决问题，脏活累活都自己来。 把“夹心饼”变成“连接器”，成为高层干系人与团队之间紧密联系的纽带。 当需要高层重视和支持的事件发生时，该出手时就得出手，引发高层关注，把团队最一手的相关动态信息及时传递给他，争取高层必要的支持，而不是跟着团队一起吐槽。 2.4.1.3. 误区三：抓不住重点，给不出方案 如果只是反映问题，没有对应的方案，更没有说明关注这个问题的原因的话，高层不但不会重视，甚至还会产生反效果。 沟通之前，做好充分的准备。要反映的问题，与高层干系人的核心关注点是否相匹配，这是能否引起其关注并进一步行动的关键所在。 在向高层干系人提问题的同时，【一定要给他一个明确的点】，让他知道，为什么要关注这个问题【数据和事实】。 针对提出的问题，列举可能的解决方案，这一点非常重要；不需要完整的，只是【前进一小步的解决方案】。 2.4.2. 跨部门沟通：不归你管的人积极配合 人类社会的很多冲突，都始于“边界”二字。 共同目标、利益捆绑和流程约束是基础，开需要更开放的心态。 2.4.2.1. 约法三章，先说清除 第一步：建立君子协定（上级领导） 1. 合作前，要跟对方建立合约，明确合作目标、合作事项、双方各自的需求和责任、时间进度要求、风险及责任人。需要公开作出正式的承诺。\r2. 刚开始合作时,建立稳定的预期是关键，双方责任及进度要求，必须要得到公开确认。\r3. 承诺越公开、越正式、日后对双方的约束效力就越大。\r 第二步：建立机制 1. 合作建立之后，需要建立常规的沟通机制来持续推动；\r2. 可以借助标准的任务管理和文档管理工具，对项目任务和文档做到统一的流程化管理，在过程中确保及时地跟进检查。\r3. 运行过程中，经常自检，确认下流程上是否有疏忽的地方。是否存在\"三不管\"地带？每个依赖任务的职责是否明确，责任是否具体到个人。一旦发现，需要及时沟通、权责分明、分工合理。\r 第三步：解决问题 1. \"找他们领导\"是王炸，不到特别时刻，不要随便拿出来用。\r2. 自己尽快启动风险应对机制，确定问题处理方案；\r3. 把问题和相关的决议结果抄送给双方的负责人，让双方清楚问题对整体项目的影响及调整方案。\r4. 需明确，今后要采取哪些预防措施，以避免问题的再次发生。\r 2.4.2.2. 打开边界，一起想办法 首先，要建立统一、清晰的节奏感（交付节奏，关键节点）； 其次，想要打开边界，你还需要主动往前一步（每个模块都要有担当）； 1. 上敬老，对于用户方，要去主动深挖用户方的需求及业务背景，走在用户的前面；\r2. 下爱小，对于依赖方，要全面监控、必要容错、并帮助它不断改进。\r 2.4.3. 向下沟通 “非职权领导力”：执行力、信息力、感知力、透明力、影响力和整合力。 2.4.3.1. 执行力 根基，俗称“靠谱”。立身之本。 2.4.3.1.1. 主动担责 首先需要跳出自己的小圈圈，主动承担更大的责任，而不是眼睁睁地看着项目出现问题，放手不管。 2.4.3.1.2. 有始有终 言必信，行必果。交给你的任何事情，都有始有终。 一个有始有终的闭环，意味着你要对自己的每一个行为负责，清楚地了解为什么做，目标是什么，做完之后效果是怎样的，还有什么问题，以后要做哪些改进。如果中途有变化，也要及时根相关方明确说明调整或取消的原因是什么。 2.4.3.2. 信息力 要让流动的信息汇聚起来。 信息互通机制和平台：周会、站会、周报、邮件列表、通讯群，甚至是各类数据平台，都可以成为信息力的承载。 让非正式的信息自动流向你。内功：好奇、热心、真诚、友善等。 2.4.3.3. 感知力 感知力是对“冰山下”的隐形信息的敏锐度。 重点就是平时在开会时你要多联系、多观察。 1. 第一层：现象层；\"冰山上的行为\"。\r2. 第二层：意图层。多问几个为什么。\r3. 第三层：感受层。试着从现象和意图中，去感受每个人的状态和需要。必须要先要处理好感受。让那些平常看不到的真实一面，被集体看见和理解。\r 2.4.3.4. 透明力 观察的结果只有透明出来，才能发挥效用。需要想办法把你看到的问题可视化，让决策者和团队都能看到这些问题。透明的力量。 一个是“分析-思考-看见”（共识），一个是”目睹-感受-看见“（共鸣）。 想要改善什么，就把什么透明化！在走脑的同时又要走心，让团队的所有人都看见问题，调动起集体的关注力和改变的动力。 2.4.3.5. 影响力 项目经理，行走江湖，靠的是大家肯买你的账。对个人来说，时有说服力；对群体来说，时有感染力。 影响力的真正秘诀是”听“，提得每一条建议都是建立在对对方的理解之上，所以才会被对方听进去。 ”不听“是一切沟通问题的根源。 当你真诚地抱着想要了解和倾听对方的愿望，放下对自己的想法的执着时你才能留意到对方真正的需求。这样自然的交流分享，反而更容易产生碰撞，引发共鸣。 2.4.3.6. 整合力 优秀的全局整合能力非常关键。 凡是能促进业务良性运作的，凡是能促进团队健康发展的都是整合管理的范畴。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:2:4","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"2.5. PMP认证 还是有必要的。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:2:5","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3. Qt项目管理 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:0","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3.1. 正确理解需求 首先分析并详细记录最终用户和市场的需求。 然后，建议构建多个【用例】来描述用户在新系统中每个可能的举动。 可能需要原型设计。 建议您多构建几套原型；迭代、细化是成功的重要组成部分。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:1","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3.2. 深谋远虑的研发 们建议从一开始就假设您的应用需要运行在多种设备上。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:2","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3.3. 考虑周全的硬件选型 开发者在嵌入式设备就绪前，通常在台式机或软件模拟器上开始开发，这完全行得通。但是，尽早在真实硬件或开发板上运行应用程序也非常重要，它能验证您的硬件是否能正常运行您所设想的内容。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:3","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3.4. 团队步调一致 建议使用相同的工具链和框架来统一分布式开发团队 —— 使用 Qt 很容易实现这些— 尽可能地跨工具和功能重用代码。一种有效的方法是基于 Qt 创建自己定义的 SDK，来确保团队成员和项目之间的一致性。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:4","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3.5. 避免重新发明轮子 ，Qt 具有非常强大的跨台抽象层，因此不需要编写特定平台、处理器或操作系统的代码。如果您正在使用 “#ifdef OS_LINUX” 这样的方式来写代码，那么某些内容可能已经出错了。 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:5","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":["项目管理"],"content":"3.6. 性能优化和重构 ","date":"2021-04-23","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/:3:6","tags":["项目管理"],"title":"如何管理一个项目","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-01-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"1. 提升程序性能 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:1:0","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"1.1. 系统级性能优化 两个阶段 1.1.1. 性能剖析 找出性能瓶颈 查找原因和热点代码 1.1.2. 代码优化 【优化代码】和【编译选项】。 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:1:1","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2. 性能剖析工具 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:0","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.1. gperftools ***** 应用级别。 gperftool主要支持以下四个功能： a. thread-caching malloc b. heap-checking using tcmalloc 堆检查器 c. heap-profiling using tcmalloc 堆分析器 d. CPU profiler CPU分析器 如果要获得完整功能，链接应用代码的时候，需要链接动态库-lprofiler -ltcmalloc. 安装 参考内存泄漏分析工具：tcmalloc. 克隆源码,提取出tag。 没有libtool的话，需要安装sudo apt-get install libtool. ./autogen.sh. PC mkdir x64_build; ./configure --prefix=$(pwd)/x64_build; make; make install. 交叉编译生成so动态库 source使用交叉编译器。 ./configure --prefix=$(pwd)/arm_build --host=arm-linux. make clean. make -j8. make install. 使用 应用程序生成分析源文件(需要设置一些环境变量)，然后在PC上分析(pprofperl脚本)，此时需要修改应用程序源码并链接相应的库。 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:1","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.2. Oprofile 更新停滞。 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:2","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.3. Perf ***** 内核级别(一般用来分析CPU，分析内存可用gperftools)【必须在内核中打开perf的events功能】。 开源。 内置于内核源码树。 基于事件采样原理:每隔一个固定的时间，产生一个中断，然后统计对应的pid和函数【采样就预示着与实际运行情况并不能保持一致，但如果一个函数运行的时间越长，被时钟中断的机会就越大。鉴于perf最终显示的是统计值，所以它的测量结果是高度可信的】。 perf支持两种模式，计算模式和采样模式。比如，perf stat使用的是计算模式，而perf record采用的是采样模式。 2.3.1. 以性能事件为基础 支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析. 主要有3类。 2.3.1.1. Hardware Event 是由 PMU 硬件产生的事件 2.3.1.1.1. cache 命中 2.3.1.2. Software Event 是内核软件产生的事件 2.3.1.2.1. 进程切换 2.3.1.2.2. tick 数 2.3.1.3. Tracepoint event 是内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节 2.3.1.3.1. slab 分配器的分配次数 2.3.2. 安装 源码存在linux内核源码tools/perf中。 2.3.2.1. 交叉编译 需使用和编译内核一致的编译器。 需要查看是否需要安装相应的插件. Auto-detecting system features: ... dwarf: [ OFF ] ... glibc: [ on ] ... gtk2: [ OFF ] ... libaudit: [ OFF ] ... libbfd: [ OFF ] ... libelf: [ OFF ] # 需要elf ... libnuma: [ OFF ] ... libperl: [ OFF ] ... libpython: [ OFF ] ... libslang: [ OFF ] ... libunwind: [ OFF ] ... libdw-dwarf-unwind: [ OFF ] ... zlib: [ OFF ] ... lzma: [ OFF ] 安装zlib1.2.11. 1. 下载源码； 2. 更新环境变量，使用交叉编译器。 3. `mkdir arm_build`; 4. `./configure --prefix=$(pwd)/arm_build`; 5. `make` 6. `make install`. 安装elfutils0.183.(work) 1. 下载\"https://sourceware.org/elfutils/ftp/\". 2. `mkdir arm_build`; 3. `./configure --prefix=$(pwd)/arm_build --host=arm-linux LDFLAGS=\"-L[zlib_path] -lz\" CPPFLAGS=-I[zlib_include] --disable-libdebuginfod --disable-debuginfod`; 4. `make` 5. `make install`. 交叉编译perf: 1. 修改Makefile.config`EXTLIBS`增加-lelf -lz 1. make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 遗留问题，静态编译(LDFLAGS+=-static)失败，只能动态编译???。 symbol不显示函数名sudo apt-get install libiberty-dev binutils-dev. 2.3.3. 使用 perf list列出所有能够触发perf采样点的事件. 2.3.3.1. perf stat [程序] 最先使用的一个工具; 通过概括精简的方式提供被调试程序运行的整体情况和汇总数据. 2.3.3.1.1. 指标分析 task-clockCPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO. context-switches进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。 cpu-migrations表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行 page-faults; cycles处理器时钟，一条机器指令可能需要多个 cycles; instructions机器指令数目; branches branch-misses 使用 -e 选项来查看您所感兴趣的特殊的事件. 2.3.3.2. perf top 实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态. 查看当前系统最耗时的[内核函数]或[某个用户进程]. -e 选项，您可以列出造成其他事件的 TopN 个进程 / 函数 2.3.3.3. perf record 记录单个函数级别的统计信息,使用-o记录到文件中，并使用 perf report 来显示统计结果 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:3","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.4. Strace strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如【系统调用】、信号传递、进程状态变更等. strace底层使用内核的ptrace特性来实现其功能. 基本使用strace -tt -f ./some_server ../conf/some_server.conf. 2.4.1. 交叉编译 clonestrace; 使用gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf; ./bootstrap; ./configure --prefix=$(pwd)/arm_build --host=arm-none-linux; make; make install; 2.4.2. 使用 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:4","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.5. Top 2.5.1. 内存 Mem: 172520K used, 858088K free, 0K shrd, 1053056K buff, 1053104K cached 2.5.2. CPU sys 占用高需要查看系统调用。 2.5.3. 各列 VSZ 虚拟内存。 STAT 进程状态。 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:5","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.6. VTune Intel平台。 收费。 ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:6","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2.7. shell脚本 f18m/CPU-MEM-monitor复杂脚本. 简单脚本。 #!/bin/sh interval=1 if [ \"$1\" != \"\" ]; then interval=$1 else exit fi if [ \"$2\" != \"\" ]; then procname=$2 else exit fi echo \"检查时间间隔(单位秒)：\"$interval echo \"进程名称:\"$procname datetime=$(date +'%Y%m%d') while :; do #根据进程名获取进程id pid=$(ps -ef | grep $procname | grep -v grep | awk '{print $1}') echo $pid $procname #获取当读占用cpu信息 echo $(date +'%Y-%m-%d %H:%M:%S') %cpu: $(top -n 1 -d 1 | grep $procname | grep -v grep | awk '{print $8}') \u003e\u003e/program/${procname}_cpu_stat.txt sleep $interval done ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:7","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3. 程序性能问题的原因 程序的运算量很大，导致 CPU过于繁忙，CPU是瓶颈. 程序需要做大量的 I/O，读写文件、内存操作等等，CPU 更多的是处于等待，I/O部分称为程序性能的瓶颈. 程序之间相互等待，结果 CPU 利用率很低，但运行速度依然很慢，事务间的共享与死锁制约了程序的性能. ","date":"2021-04-21","objectID":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:3:0","tags":["PLAT","LINUX"],"title":"LINUX调试和性能分析","uri":"/post/plat-linux-02-%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["PROGRAM"],"content":"1. bit LUA本身不支持位运算,所以需要bit模块。 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:1:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"1.1. 操作 bit.lshift(x, n) --逻辑左移 bit.rshift(x, n) --逻辑右移 bit.arshift(x, n) --算术右移 bit.band() --与 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:1:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"2. JSON ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:2:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"2.1. cjson 需要手动编译link 【要求编码格式必须是utf-8】;如果不是需要自己写，但是性能会降低link ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:2:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"3. websocket lua-resty-websocketlink 发送超时（别的进程CPU占用过高，会导致超时），ngx.exit(444)会导致浏览器websocket异常断开（1006）。 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:3:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"3.1. API send_text --发送文本字符串(utf-8); send_binary --1. 发送`byteArray`;2. 调用`send_frame(self, true, 0x2, data)`. recv_frame --超时为new设置的超时时间 server:new{timeout = 5000, max_payload_len = 65535} ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:3:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"4. lua-resty-aeslink ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:4:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"5. lua-resty-corelink New FFI-based Lua API for ngx_http_lua_module and/or ngx_stream_lua_module ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"6. lua-resty-locklink Simple shm-based nonblocking lock API ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"7. lua-resty-sessionlink 安全、灵活的会话库 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"7.1. API session:parse_cookie(cookie) --Parses cookie and returns the data back as a table on success and nil and error on errors. session:get_cookie() --Returns the cookie from the request or nil if the cookie was not found session.new(opts) session:regenerate(flush, close)--重新生成一个session，并且重新设置Cookie session:save(close) --保持原状，不变 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"7.2. 原理 7.2.1. save() 7.2.1.1. 保存session并设置cookie 7.2.2. session的field 7.2.2.1. expires 7.2.2.1.1. 超时的时间点 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:2","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"8. lua-resty-stringlink ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"8.1. String utilities and common hash functions for ngx_lua and LuaJIT ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"8.2. 核心文件 8.2.1. sha1.lua ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:2","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"9. lua-resty-uploadlink ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:9:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"9.1. Streaming reader and parser for HTTP file uploading based on ngx_lua cosocket ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:9:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"9.2. 有权限的问题 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:9:2","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"10. LuaSQLite 3link ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:10:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"10.1. a Lua 5.1 to 5.3 wrapper for the SQLite3 library ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:10:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"10.2. To use this module you need the SQLite3 library (DLL or .so) ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:10:2","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"11. ffi 集成在luajit中 编译器在查找动态库所在的路径的时候其中一个环节就是在 LD_LIBRARY_PATH 这个环境变量中的所有路径进行查找 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:11:0","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"11.1. API ffi.load(name [,global]) --name:z就是libz.so;global:ture，这个库符号被加载到一个全局命名空间 ","date":"2021-04-21","objectID":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:11:1","tags":["PROGRAM","LUA"],"title":"LUA常用模块","uri":"/post/program-lua-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":"C.40 Define a constructor if a class has an invariant ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:1:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"R.3: A raw pointer (a T*) is non-owning ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:2:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"R.4: A raw reference (a T\u0026) is non-owning ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:3:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"R.10: Avoid malloc() and free() 避免使用malloc和free malloc() and free() do not support construction and destruction, and do not mix well with new and delete. ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:4:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"E ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:5:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"E.28: Avoid error handling based on global state (e.g. errno) 错误处理不要基于全局变量。（比较难于管理） ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:5:1","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"I: Interfaces（接口） 拥有良好的界面（易于理解，鼓励高效使用，不易出错，支持测试等）可能是代码组织的最重要方面。 ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:6:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":"I.2: Avoid non-const global variables 非常数全局变量，会隐藏依赖关系，而且会导致欲知的更改。 【警惕：动态链接库的陷阱】C++又一坑:动态链接库中的全局变量。 除非全局变量比单例更好。 ","date":"2021-04-17","objectID":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/:6:1","tags":["PROGRAM","C/C++"],"title":"PROGRAM C++ 核心准则","uri":"/post/program-c++-%E6%A0%B8%E5%BF%83%E5%87%86%E5%88%99/"},{"categories":["PROGRAM"],"content":" Scapy是功能强大的交互式数据包处理程序、数据包生成器、网络扫描器、网络发现工具和包嗅探工具。 它能够伪造或解码各种协议的数据包，在线发送它们，捕获它们，匹配请求和答复等等. 它可以轻松地处理大多数经典任务，例如扫描，跟踪路由，探测，单元测试，攻击或网络发现（它可以替代hping，nmap，arpspoof，arp-sofof，arp-sk，arping，tcpdump，tethereal，p0f等的85％）。 它在大多数其他工具无法处理的许多其他特定任务上也表现出色，例如发送无效帧，注入您自己的802.11帧，结合技术（VLAN跳变+ ARP缓存中毒，WEP加密通道上的VOIP解码等等）等等。 scapy主要做两件事：发送数据包和接收答案。定义一组数据包，发送它们，接收答案，将请求与答案匹配，并返回数据包对（请求、应答）列表和不匹配数据包列表. ","date":"2021-04-16","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/:0:0","tags":["PROGRAM","PYTHON"],"title":"PROGRAM PYTHON 第三方库 SCAPY","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/"},{"categories":["PROGRAM"],"content":"1. def 方法 ","date":"2021-04-16","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/:1:0","tags":["PROGRAM","PYTHON"],"title":"PROGRAM PYTHON 第三方库 SCAPY","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/"},{"categories":["PROGRAM"],"content":"1.1. def sniff(*args, **kwargs) ","date":"2021-04-16","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/:1:1","tags":["PROGRAM","PYTHON"],"title":"PROGRAM PYTHON 第三方库 SCAPY","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/"},{"categories":["PROGRAM"],"content":"2. class 类 ","date":"2021-04-16","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/:2:0","tags":["PROGRAM","PYTHON"],"title":"PROGRAM PYTHON 第三方库 SCAPY","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/"},{"categories":["PROGRAM"],"content":"2.1. Packet 类 定义一个协议(Packet的子类)即一个包： class Disney(Packet): name = \"DisneyPacket \" # 起个名字 fields_desc=[ #字段组成 ShortField(\"mickey\",5), XByteField(\"minnie\",3) , IntEnumField(\"donald\" , 1 , { 1: \"happy\", 2: \"cool\" , 3: \"angry\" } ) ] 2.1.1. def 方法 def __init__直接传入bytes的字符串，即可进行解析，只解析能解析的，剩下的在load中。 def show(self, dump=False, indent=3, lvl=\"\", label_lvl=\"\")打印packet的结构 ","date":"2021-04-16","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/:2:1","tags":["PROGRAM","PYTHON"],"title":"PROGRAM PYTHON 第三方库 SCAPY","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/"},{"categories":["PROGRAM"],"content":"2.2. Field 类 Field是Packet的成员。 认为是数据包的最小组成单元，在成帧的过程中，每一个filed输出一个bytes数组，然后packet按照顺序，把每个filed的bytes连接起来，形成最终的数据包。 每个Field只需要关注自己输出的bytes数组就可以了，这也体现了面向对象的封装隔离的原则 2.2.1. def 方法 def addfield(self, pkt, s, val)将Field封包成bytes string。 def getfield(self, pkt, s)将bytes string解包成Field。 2.2.2. 子类 2.2.2.1. class BitField(Field) 操作bit位 2.2.2.2. class ByteField(Field) 字节 def __init__(self, name, default)名称、默认值 2.2.2.2.1. 子类 ####### 2.2.2.2.1.1. ‵class XByteField(ByteField)` 首选16进制 ####### 2.2.2.2.1.2. class LEThreeBytesField(ByteField) 小端3字节 2.2.2.3. class DestField(Field) 2.2.2.4. class FCSField(Field) 2.2.2.5. class IntField(Field) 2.2.2.6. class IP6Field(Field) 2.2.2.7. class IPField(Field) 2.2.2.8. class LEShortField(Field) 小端无符号 2.2.2.9. class LESignedShortField(Field) 小端有符号 2.2.2.10. class MACField(Field) 2.2.2.11. class ShortField(Field) 两个字节的短整形 2.2.2.12. class SignedByteField(Field) 2.2.2.13. class SignedShortField(Field) 2.2.2.14. class StrField(Field) 2.2.2.14.1. 子类 ####### 2.2.2.14.1.1. class PacketField(StrField) ","date":"2021-04-16","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/:2:2","tags":["PROGRAM","PYTHON"],"title":"PROGRAM PYTHON 第三方库 SCAPY","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-scapy/"},{"categories":null,"content":"（按照字母顺序） ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:0:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"1. busybox（常用工具包） busybox是一个集成了一百多个最常用linux命令和工具的软件,甚至还集成了一个http服务器和一个telnet服务器,而所有这一切功能却只有区区1M左右的大小。 一般可用来构建linux最小文件系统; 【支持的命令功能有限】。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:1:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"2. cat(In busybox) -n 或 --number 所有输出的行数编号 -b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 --show-nonprinting ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:2:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"3. date(In busybox) date +\"%T.%12N\" # 打印ps级别的时间，一般到纳秒 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:3:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"4. dhcp3-server ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:4:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"5. dirname 输出去掉最后一个非斜杠目录名和尾随斜杠以后的剩余部分；如果目录名不包含/，则输出.（表示当前目录）. dirname /usr/bin/ # 输出 /usr dirname dir1/str dir/str # 输出 dir1或者dir2 dirname stdio.h # 输出 . ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:5:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"6. ethtool（查询及设置网卡参数） -a 查看网卡中接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。 -A 修改网卡中接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。 -c display the Coalesce(聚合、联合) information of the specified ethernet card.聚合网口信息，使看起来更有规律。 -C Change the Coalesce setting of the specified ethernet card.修改网卡聚合信息。 -g Display the rx/tx ring parameter information of the specified ethernet card. 显示网卡的接收/发送环形参数。 -G Change the rx/tx ring setting of the specified ethernet card. 修改网卡的接收/发送环形参数。 -i 显示网卡驱动的信息，如驱动的名称、版本等。 -d 显示register dump信息, 部分网卡驱动不支持该选项。 -e 显示EEPROM dump信息，部分网卡驱动不支持该选项。 -E 修改网卡EEPROM byte. -k 显示网卡Offload参数的状态：on 或 off，包括rx-checksumming、tx-checksumming等。 -K 修改网卡Offload参数的状态 -p 用于区别不同ethX对应网卡的物理位置，常用的方法是使网卡port上的led不断的闪；N指示了网卡闪的持续时间，以秒为单位。 -r 如果auto-negotiation模块的状态为on，则restarts auto-negotiation. -s 修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac地址等。加上-s选项修改的内容才会生效 -S 显示NIC- and driver-specific 的统计参数，如网卡接收/发送的字节数、接收/发送的广播包个数等。 -t 让网卡执行自我检测，有两种模式：offline or online. 输出内容 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:6:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"7. exa（ls命令的现代替代品） ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:7:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"8. filezilla(FTP图形界面工具）) ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:8:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"9. find(In busybox) mtime查找在指定时间曾被更改过的文件或目录，单位以24小时计算:+值,多少天之前,跟当前比较. find . -exec COMMAND \\; -exec COMMAND \\; # find之后执行多条命令,使用{}指代每一行参数 -type # f 为文件 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:9:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"10. ftpget(In busybox)ftp下载文件 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:10:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"11. ftpput(In busybox)ftp上载文件 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:11:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"12. gpsd(GPS协议) 自动探测并识别GPS协议，同时支持多个GPS设备，并且可以动态进行设备控制 支持PPS并且与NTPD结合，实现时间服务 统一生成JSON流报告给上层客户端 支持DBUS，共享内存以及本地SOCKET等方式与客户端通讯，最大支持64个 提供丰富的组件及工具用来调试及测试 参考GPSD架构介绍及交叉编译和使用. ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:12:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"13. grep(In busybox) 一般用于管道对标准输出的内容进行检索。 -E或--extended-regexp 使用正则表达式（双引号包起来） -o 或 --only-matching 只显示匹配PATTERN 部分。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:13:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"14. hexdump(In busybox) -n length 只格式化输入文件的前length个字节。 -C 输出规范的十六进制和ASCII码。 -b 单字节八进制显示。 -c 单字节字符显示。 -d 双字节十进制显示。 -o 双字节八进制显示。 -x 双字节十六进制显示。 -s 从偏移量开始输出。 -e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：'a/b \"format1\" \"format2\"' a表示对每a个输入字节应用format2格式 b表示对每b个输入字节应用format1格式 format1和format2中可以使用类似printf的格式字符串 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:14:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"15. hostapd ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:15:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"16. ipcs -a #查看当前使用的共享内存、消息队列及信号量所有信息 -m #查看共享内存段 -p #pid ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:16:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"17. ipcrm ipcrm [ -M key | -m id | -Q key | -q id | -S key | -s id ] -M用shmkey删除共享内存 -m用shmid删除共享内存 -Q用msgkey删除消息队列 -q用msgid删除消息队列 -S用semkey删除信号灯 -s用semid删除信号灯 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:17:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"18. iperf3(带宽测试) The ultimate speed test tool for TCP, UDP and SCTP. ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:18:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"18.1. 安装 下载源码; mkdir ../install_3.1.3; ./configure --host=arm-none-linux-gnueabi --prefix=${pwd}/../install_3.1.3; make; make install. ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:18:1","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"18.2. 使用 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:18:2","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"19. iw（wifi配置工具） Linux下的一种wifi配置工具，它替代了Wireless tools中的iwconfig. ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:19:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"20. less(In busybox) ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:20:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"21. more(In busybox) +n #从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:21:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"22. nginx 交叉编译见我的nginx代码库。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:22:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"23. nohup(In busybox) nohup命令是永久执行，忽略挂起信号。\u0026是指在后台运行。 用 \u0026 后台运行程序时，如果是守护进程，断开终端则程序继续运行，如果不是守护进程，断开终端则程序也会被断开停止运行。 使用nohup命令时，如果指定了输出文件，输出信息则会附加到输出文件中，如果没有指定输出文件，则输出信息会附加到当前目录下的nohup.out文件中，如果当前目录的nohup.out文件不可写，输出重定向到$HOME/nohup.out文件中。 nohup ./program \u003e/dev/null 2\u003elog \u0026只输出错误信息到日志文件. nohup ./program \u003e/dev/null 2\u003e\u00261 \u0026什么信息也不要. ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:23:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"24. openssl ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:24:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"24.1. 交叉编译 ./config no-asm -shared --prefix=$(pwd)/.opensslno-threads非多线程no-shared不支持动态链接库no-asm不在编译过程.中使用汇编代码加快编译过程 修改Makefile:搜索-m64选项并删除，共两处;增加-lrt. make make install 编译之后得到两个动态库libcryptoThe libcrypto library provides the fundamental cryptographic routines used by libssl;You can however use libcrypto without using libssl.libssl. ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:24:1","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"25. setserial(In busybox)设置或显示串口的相关信息 Usage: setserial [-gabGvzV] DEVICE [PARAMETER [ARG]]... -a 显示详细信息。 -b 显示摘要信息。 -g 显示串口的相关信息。 -G 以指令列表的格式来显示信息。 -q 执行时显示较少的信息。 -v 执行时显示较多的信息。 -V 显示版本信息。 -z 设置前，先将所有的标记归零。 PARAMETER low_latency 以更高的CPU占用率来使得接受滞延达到最小。(通常传输中的5－10ms的滞延以使系统开销最小.) 此项默认值为关闭，但某些实时程序可能会用到此参数。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:25:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"26. sort（文本内容排序）(In busybox) Linux sort命令用于将文本文件内容加以排序。 sort可针对文本文件的内容，以行为单位来排序。 -b 忽略每行前面开始出的空格字符。 -c 检查文件是否已经按照顺序排序。 -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。 -f 排序时，将小写字母视为大写字母。 -i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。 -m 将几个排序好的文件进行合并。 -M 将前面3个字母依照月份的缩写进行排序。 -n 依照数值的大小排序。 -u 意味着是唯一的(unique)，输出的结果是去完重了的。 -o\u003c输出文件\u003e 将排序后的结果存入指定的文件。 -r 以相反的顺序来排序。 -t\u003c分隔字符\u003e 指定排序时所用的栏位分隔字符。 +\u003c起始栏位\u003e-\u003c结束栏位\u003e 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 -k, --key=KEYDEF sort via a key; KEYDEF gives location and type ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:26:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"27. squid（代理服务） 安装完之后，编辑配置使用linux服务器搭建代理。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:27:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"28. stress（压力测试工具） 可以对cpu、memory、IO以及磁盘进行压力测试 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:28:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"28.1. 安装 下载https://salsa.debian.org/debian/stress; 编译./configure --prefix=/tmp/install --host=arm-linux-gnueabihf-; make; make instal; ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:28:1","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"28.2. 使用 -t --timeout N 指定运行N秒后停止 -c --cpu 产生n个进程 每个进程都反复不停的计算随机数的平方根 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:28:2","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"29. stty（检查和修改当前注册的终端的通信参数） ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:29:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"30. tmux 在远程到一台机器或者在本地终端下，经常发现，一个终端远远地不够用，经常需要同时打开几个，往往还希望这几个窗口同时显示在视线内。tmux正是为这种需求而生。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:30:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"30.1. 使用C/S模型构建 主要包括以下单元模块： server服务器。输入tmux命令时就开启了一个服务器。 session会话。一个服务器可以包含多个会话 window窗口。一个会话可以包含多个窗口。 panel面板。一个窗口可以包含多个面板。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:30:1","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"30.2. 命令 # server tmux ls（Ctrl+b s） 列出所有会话 tmux new -s \u003csession-name\u003e 新增一个会话 tmux rename-session -t 0 \u003cnew-name\u003e（Ctrl+b $） 重命名会话 tmux detach 或者使用 exit（Ctrl+b d） 分离会话 tmux attach -t \u003csession-name\u003e 或者使用 tmux at -t \u003csession-name\u003e 重新连接会话 tmux kill-session -t \u003csession-name\u003e 杀死会话 tmux switch -t \u003csession-name\u003e 切换会话 # window Ctrl+b c - (c)reate 生成一个新的窗口 Ctrl+b n - (n)ext 移动到下一个窗口 Ctrl+b p - (p)revious 移动到前一个窗口. Ctrl+b \u0026 - 确认后退出 tmux # panel Ctrl+b \" - 水平分割当前panel Ctrl+b % - 竖直分割当前panel Ctrl+b 方向键 - 在各窗格间切换 Ctrl+b；Ctrl+方向键 - 调整窗格大小 Ctrl+b q - 显示分隔panel的编号 Ctrl+b o - 跳到下一个分隔panel Ctrl+b x - 关闭当前panel Ctrl+b 空格键 - 采用下一个内置panel布局 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:30:2","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"31. uniq（文本内容去重）(In busybox) Linux uniq 命令用于检查及删除文本文件中重复出现的行列，因为他只比较相邻的两行，所以一般与 sort 命令结合使用。 uniq 可检查文本文件中重复出现的行列。 -c或--count 在每列旁边显示该行重复出现的次数。 -d或--repeated 仅显示重复出现的行列。 -f\u003c栏位\u003e或--skip-fields=\u003c栏位\u003e 忽略比较指定的栏位。 -s\u003c字符位置\u003e或--skip-chars=\u003c字符位置\u003e 忽略比较指定的字符。 -u或--unique 仅显示出一次的行列。 -w\u003c字符位置\u003e或--check-chars=\u003c字符位置\u003e 指定要比较的字符。 [输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据； [输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:31:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"32. watchdog（看门狗）(In busybox) 来操作和控制看门狗设备 -T:复位之后多少秒超时 -t:多少秒复位一次 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:32:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"33. wc（文件属性计数）(In busybox) wc指令我们可以计算文件的Byte数、字数、或是列数。 -c或--bytes或--chars 只显示Bytes数。 -l或--lines 只显示行数。 -w或--words 只显示字数。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:33:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"34. xargs给命令传递参数的一个过滤器 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具； xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令； xargs 一般是和管道一起使用somecommand |xargs -item command。 -a file 从文件中读入作为 stdin -e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。 -p 当每次执行一个argument的时候询问一次用户。 -n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 -t 表示先打印命令，然后再执行。 -i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。 -r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。 -s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。 -L num 从标准输入一次读取 num 行送给 command 命令。 -l 同 -L。 -d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。 -x exit的意思，主要是配合-s使用。。 -P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。 ","date":"2021-04-13","objectID":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/:34:0","tags":["PLAT","LINUX"],"title":"LINUX命令","uri":"/post/plat-linux-01-%E5%91%BD%E4%BB%A4/"},{"categories":["PROGRAM"],"content":"1. class ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.1. 规范 类名首字母都大写 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:1","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.2. 访问权限 1.2.1. public 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员 1.2.2. private（默认） 基类中的 private 成员不能在派生类中使用，仍然可以被继承（派生类也有这些成员，只是不可以在自己的成员函数中直接访问和使用，必须要要调用基类的成员函数获取和修改）。 1.2.3. protected 声明为 protected 的成员在类外也不能通过对象访问，但是在它的派生类内部可以访问 1.2.4. 实现private和protected的外部调用 一般用于消息系统注册函数（基类调用子类的方法）。 #include \"stdio.h\" struct func_struct; class A { private: static func_struct func; protected: void echo(void) { printf(\"hello world\"); } public: func_struct *get() { return \u0026func; } }; typedef void (A::*TEST)(void); struct func_struct { TEST func; }; func_struct A::func = {\u0026A::echo}; int main() { A a; const func_struct *m_ptr = a.get(); ((\u0026a)-\u003e*(m_ptr-\u003efunc))(); } ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:2","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.3. 抽象和封装 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:3","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.4. 成员 1.4.1. 成员变量 大都以m_开头 一般为private 类的成员变量应该使用引用类型、指针类型还是对应类型对象呢？ 1. 因为引用类型必须在初始化列表初始化，并且不能被重新赋值，使用较少。 2. 指针类型适合在以下几种情况下使用： 当成员变量要使用多态时，将成员变量定义成指针。 当成员变量是可选的，在有些情况下不会使用，可以将成员变量定义成指针，节省空间。 当成员变量是一个很大的对象时，将成员定义成指针，避免栈溢出，linux默认栈大小可以通过ulimit -s查看，默认为8Mb。 当成员变量对应的资源不是对象独有，而是多个对象共同所有。 ？？构造函数具有参数。 3. 其他情况直接定义指定类型对象较好，无需进行内存管理，无需担心空指针。 1.4.2. 成员函数 1.4.2.1. 构造函数 只有在编译器需要默认构造函数来完成编译任务的时候，编译器才会为没有任何构造函数的类合成一个默认构造函数，或者是把这些操作插入到已有的构造函数中去。参考C++ 合成默认构造函数的真相 编译器需要默认构造函数的四种情况，总结起来就是: a) 调用对象成员或基类的默认构造函数。 b) 为对象初始化虚表指针与虚基类指针。 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 1. 是个构造器; 2. 是个默认且隐含的类型转换操作符。(在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。) 1.4.2.2. “=”会隐式调用拷贝构造函数 使用explicit声明 才能避免隐式调用 1.4.2.3. 带默认值参数的构造函数和无参数的构造函数不能共存，会有编译错误 1.4.2.4. 继承 【基类构造函数将会被自动调用】，用于初始化派生类从基类继承过来的成员变量，而派生类中新增的成员则需要从新定义构造函数用于初始化了 在派生类的构造函数中不指定对应的基类的构造函数，这个时候调用的是基类的默认构造函数(即含有默认参数值或不带参数的构造函数) 在派生类的构造函数中指定要调用的基类的构造函数，并将派生类构造函数的部分参数值传递给基类构造函数。 除非基类有默认的构造函数，否则必须采用【显式调用】。 1.4.2.5. 构造函数后加冒号【:】是初始化表达式 初始化const成员(括号赋值) 初始化引用成员 调用基类的构造函数，而它拥有一组参数时 调用成员类的构造函数，而它拥有一组参数时 1.4.2.6. 拷贝构造函数 复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，【参数类型是本类的引用】。 复制构造函数的参数可以是 const 引用，也可以是非 const 引用(一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。) 不写复制构造函数，【编译器就会自动生成复制构造函数】。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”. Complex cl(1, 2); Complex c2 (cl); //用复制构造函数初始化c2 如果编写了复制构造函数，则默认复制构造函数就不存在了 复制构造函数被调用的三种情况 1. 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用 Complex c2(c1); Complex c2 = c1; 2. 如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。【类似传值调用】 a. 以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。 b. 如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。 3. 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。【类似函数返回】 a. 有些编译器出于程序执行效率的考虑，编译的时候进行了优化，函数返回值对象就不用复制构造函数初始化了，这并不符合 C++ 的标准 1.4.2.7. get开头 1.4.2.8. set开头 1.4.2.9. 非静态、非虚的普通成员函数指针不能直接调用，必须绑定一个类对象 1.4.2.10. 重载 同一个类中（同一个作用域中/在类的内部） 【一组函数名相同】，【函数的参数列表不同（参数的个数、类型、顺序）】，函数有无 virtual 关键字都可以 返回值的类型不会影响重载 const属性相同 typeof是类型重命名，类型是相同的。 1.4.2.11. 重写 虚函数重写（会发生多态） 非虚函数重写（重定义的一种形式） 条件 1. 函数的返回类型、方法名、参数列表完全相同 2. 必须发生在不同的作用域中（基类与派生类中） 3. 基类中有 virtual 关键字声明，派生类中可有可无，不能有 static （虚函数重写） 1.4.2.12. 重定义（隐藏） 子类重新定义父类中有相同名称的函数 ( 不包括虚函数重写 ) 条件 1. 必须发生在不同的作用域中（基类与派生类中） 2. 函数名相同 3. 返回值可以不同 4. 参数列表不同，此时，无论基类中的同名函数有无 virtual 关键字，【基类中的同名函数都会被隐藏】 5. 参数列表相同，此时，基类中的同名函数没有 virtual 关键字，则基类中的同名函数将会被隐藏 --- 非虚函数重写 可以通过作用域分辨符(::)访问被隐藏的父类中的同名成员 不可以直接通过子类对象访问父类成员； 注：同名覆盖规则适用于类的成员变量与成员函数 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:4","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.5. Friend Classes（functions）（友元类或者函数） 1.5.1. 在一个类中指明其他的类（或者）函数能够直接访问该类中的private和protected成员 1.5.2. 友元按类型分为三种：普通非类成员函数作为友元,类的成员函数作为友元，类作为友元 1.5.3. 友元不能被继承 1.5.4. 友元不具有传递性 1.5.5. 如果想要指定两个类都有成员函数作为对方的友元，那么必须第2个类是第一个类的友元 1.5.6. 可以互为友元 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:5","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.6. 创建对象 在栈上创建对象Student stu;. 在堆上创建对象Student *pstu = new Student;. ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:6","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.7. 多态 1.7.1. 虚基类 1.7.1.1. 在c++中，派生类可以继承多个基类。问题在于：如果这多个基类又是继承自同一个基类时，那么派生类是不是需要多次继承这“同一个基类”中的内容？虚基类可以解决这个问题。 虚基类可以使得从多个类（它们继承自一个类）中派生出的对象只继承一个对象。 1.7.2. 纯虚函数 若一个类的成员函数被声明为纯虚函数，则意味着该类是ABC(Abstract Base Class，抽象基类)，即只能被继承，而不能用来声明对象。纯虚函数通常需要在类中声明的后面加上关键词“=0”。 当然，声明为纯虚函数并不意味着在实现文件中不可对其进行定义，只是意味着不可用抽象基类实现一个具体的对象。 1.7.3. 虚函数 重写不同于重载。我对重载的理解是：同一个类，内部的同名函数具有不同的参数列表称为重载；重写则是派生类对基类同名函数的“本地改造”，要求函数特征标完全相同。当然，返回值类型不一定相同（可能会出现返回类型协变的特殊情况）。 一个基类的指针或者引用可以指向或者引用派生类的对象。同时，派生类可以重写基类中的成员函数。 在基类中将被重写的成员函数设置为【虚函数】，其含义是：当通过基类的指针或者引用调用该成员函数时，将根据指针指向的对象类型确定调用的函数，而非指针的类型。【否则默认会调用基类的方法】 将基类与派生类的同名方法区分开 虚函数的使用将导致类对象占用更大的内存空间。 只需将基类中的成员函数声明为虚函数即可，派生类中重写的virtual函数【自动成为虚函数】； 基类中的析构函数必须为虚函数，否则会出现对象释放错误 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:7","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.8. 继承 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:8","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"方案 ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"两个类如何相互调用 类A和类B相互引用比较麻烦的根本原因在于：定义A的时候，A的里面有B，所以就需要去查看B的占空间大小，但是查看的时候又发现需要知道A的占空间大小，从而造成死循环。 两个类相互引用，一个用对象、include；另一个用指针、前置声明、create手动new。手动new的过程不能在构造函数中进行，同时需要知道另一个类的完整定义（include）。 ///\u003cA.h\u003e class B;///\u003c前置声明\u003e class A{ B *b_;///\u003c此处只能用指针或者引用\u003e } ///\u003cA.cpp\u003e #include \"A.h\"#include \"B.h\" ///\u003c次文件中要调用b_所以此处需要inlcude B 的头文件\u003evoid A::create(){ b_ = new B(); } ///\u003cB.h\u003e #include \"A.h\"class B{ A a_;///\u003c此处可用对象\u003e } ","date":"2021-04-07","objectID":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["PROGRAM","C/C++"],"title":"C++面向对象","uri":"/post/program-c-c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":" Qt的实现主要是采用p-impl手法，实现接口与实现分离，它有很好的消息循环机制，有的对象与线程的相关性，它也有借助moc生成反射元信息，这种设计方法至今仍然非常适用。 Qt内核部分其实是完全和界面无关的，你完全可以抛开Qt GUI部分来学习和使用Qt。当你完完全全学习了qt及其理念后，你会发现写优雅的代码是一件十分简单的事情，它可以应用到你之后的所有过程中去。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:0:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"1. 开发方式 如果开发的程序只管windows上跑，不用跨平台，也不关心是否需要使用Qt Creator打开，那么推荐使用VS+Qt方式进行开发。把Qt当成一个界面库来在VS中调用。VS编码+MSVC编译。 需要考虑跨平台，那么最好不要使用VS+Qt这种方式。纯QtCreator方式，QtCreator编码+MinGW或MSVC或其他编译。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:1:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"2. 软件架构 原则：UI界面和业务逻辑需要尽可能的分离（判断一个结构的解耦程度，一个简单的办法是离开了UI界面，业务逻辑是否可以正常调用和运行，如果可以，说明这个架构是比较成功的。同时，对UI界面和业务逻辑功能的每个模块，是否能够被替换，而不影响整个项目的功能，这点也是判断架构解耦性的一个指标）。两者的链接用信号与槽机制。然后每个业务逻辑按照功能划分，封装成一个单独的函数或者类。 三层： UI层（所有的主界面都会从这三个类：QWiget,QMainWindow,QDialog中的一个继承而来，并在main函数里生成实例并show出来，进入主消息循环。可以使用QWiget，不使用UI文件，所有的界面都new出来，再使用代码来布局）；控制器层(建线程，实例化业务逻辑类，搭建信号和槽)；模型层(业务逻辑，在线程中执行)。 三层： UI界面层（view）——\u003e控制器层：当用户操作UI界面时，发射一个控制器层【信号】； 控制器层（controller）——\u003e模型层：控制层【调用】模型层功能函数，实现对应业务逻辑功能； 模型层（model）——\u003e控制器层：模型功能层，完成业务逻辑后，再发射一个控制器层【信号】，声明完成了该业务逻辑功能。 控制器层（controller）——\u003eUI界面层：控制器层接收到该支线程完成了对应的业务逻辑，开启槽函数结束该支线程，然后发射一个控制器层完成业务逻辑【信号】到UI界面层。UI界面层收到 信号，显示对应的结果UI界面。 注意：整个过程控制器有【三个关键信号】：启动业务逻辑功能信号；退出该业务逻辑线程信号；完成业务逻辑信号。而model层功能函数是用【支线程】来执行。也就是说，所有的模型功能函数 都是用【支线程】完成，这样可以保证UI界面的流畅度。 基于上边3层，还可以增加一个通讯层，用于调用通信接口逻辑。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:2:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"2.1. 基于插件的架构 【注】以前基于APP+DLL的传统架构，现在流行插件架构（核心加插件组件）：【方便功能的扩展（接口定义好）】；【更新量小（只更新插件）】；【降低模块之间依赖】；【面向未来（API稳定）】。 分为三部分： 主系统:通过插件管理器加载插件，并创建插件对象。一旦插件对象被创建，主系统就会获得相应的指针/引用，它可以像任何其他对象一样使用。 插件管理器:用于管理插件的生命周期，并将其暴露给主系统。它负责查找并加载插件，初始化它们，并且能够进行卸载。它还应该让主系统迭代加载的插件或注册的插件对象,很难与主系统分割干净。 插件:插件本身应符合插件管理器协议，并提供符合主系统期望的对象。 开源项目【开源】基于Qt的跨平台插件开发框架QCPFrame（一） ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:2:1","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"3. 国内源 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/ 北京理工大学：http://mirror.bit.edu.cn/qtproject/ 中国互联网络信息中心：http://mirror.bit.edu.cn/qtproject/ 注: 5.15开始，官方不再提供编译好的版本。 6.0开始，貌似只支持win10以上的windows。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:3:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"4. 官方安装包安装(只支持到5.12.12LTS) 下载.run文件。 增加执行权限。 运行，选择所有模块（包括qtcreater和qmake）。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:4:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"5. 编译源码(5.15.2) 下载*everywhere*源码，可以使用编译工具，编译到各个平台（Windows，Linux，Arm）。 Building Qt Sources. ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:5:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"5.1. Ubuntu 下载qt-everywhere-src-5.15.2.tar.xz. 解压tar xvJf qt-everywhere-src-5.15.2.tar.xz。 安装依赖(可以不安装依赖，直接走下一步，会没有一些模块) sudo apt-get install gperf # WARNING: gperf is required to build QWebEngine. sudo apt-get install flex # WARNING: flex is required to build QWebEngine. sudo apt-get install bison # WARNING: bison is required to build QWebEngine. 执行configure mkdir qt-5.15.2-build cd qt-5.15.2-build ./../qt-everywhere-src-5.15.2/configure -release -prefix /opt/qt-5.15.2 执行make(大概会需要半小时到4小时不等) 【注】不需要make install. ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:5:1","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"5.2. windows 编译之前Qt for Windows - Requirements. 参考Qt for Windows - Building from Source 参考在Windows环境下编译Qt 5.15.1 1. 安装python； 2. 安装perl； 3. 安装openssl或其他可选依赖。 4. 注意configure的时候使用-debug-and-release选项 configure.bat -static #指明是静态编译 -prefix \"D:\\qt\" #指明安装的目录 -confirm-license -opensource #指明是开源版本的qt -debug-and-release #指明需要debug版和release版，可以单独选择release版 -platform win32-msvc #指明使用msvc编译，这里的win32并不指32位 -nomake examples -nomake tests #不编译样例 -plugin-sql-sqlite -plugin-sql-odbc -qt-zlib -qt-libpng -qt-libjpeg #可选插件 -opengl desktop #用系统自带的opengl -mp #多核编译 安装完毕之后，将bin目录放进Path中。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:5:2","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"6. Qt多版本管理 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:6:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"6.1. qtchooser ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:6:1","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"7. 理论支持 QT实质上是用C++编写的跨平台的开发类库。为GUI应用程序和非GUI应用程序提供了各种类。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:7:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"7.1. 元对象系统 元对象系统由3个部分组成。 1. QObject是所有使用元对象系统的类的基类； 2. 在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽； 3. MOC（元对象编译器）为每个QObject的子类提供必要的代码来实现元对象系统的特性。是一个预处理器，在源程序被编译前先将Qt特性的程序（发现类的定义里有Q_OBJECT宏）转换为标准C++兼容的形式，然后再由标准C++编译器进行编译。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:7:1","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"7.2. QT全局定义 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:7:2","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"7.3. 容器类 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:7:3","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"7.4. 模块（文件夹） 7.4.1. 基本模块 在所有的开发平台和目标平台都可用。 7.4.1.1. QT Webenginewidgets QT += webenginewidgets 需要将QtWebEngineProcess.exe放到exe同级目录，会生成debug.log日志文件。 //QtWebEngineProcess.exe的依赖 QT5WEBENGINECORED.DLL QT5CORED.DLL MSVCP120D.DLL MSVCR120D.DLL 需要拷贝resources和tranlations下的文件到运行目录。【必要的时候，需要将resources中文件拷贝到运行目录，qtwebengine_locales拷贝到运行目录】。 需要编译安装ICU,可以下载编译好的。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:7:4","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"8. 工具 Qt Creator是Qt的IDE，功能最强大，它大大简化了Qt开发，可以原生创建QT应用程序（带有Qt引擎的C++）。并且允许我们创建和编辑源代码，调试应用程序等。集成下边的两个工具： 1. `Qt Designer`是用于使用Qt小部件文件（.ui）设计和构建图形用户界面（GUI）的Qt工具，可以按所见即所得（WYSIWYG）的方式编写和自定义窗口或对话框，并使 用不同的样式和分辨率对其进行测试。 2. `Qt Quick Designer`允许图形化编辑QML文件（.qml），但是现在它已集成在Qt Creator中。 Qt Design Studio是一款UI设计和开发工具，它让设计师和开发者可以迅速设计原型，并且开发复杂的可伸缩的UI。简单概括其功能就是让UI设计转换为qml，为工程师所用，并且可以与Photoshop集成。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:8:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"9. 有什么很好的软件是用 Qt 编写的 QtCreater 插件架构，过于复杂。 sqlitestudio 也有插件，可以作为入门。 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:9:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"10. 解决方法 QSqlDatabasePrivate::addDatabase: duplicate connection name ‘qt_sql_default_connection'解决办法 ","date":"2021-04-02","objectID":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/:10:0","tags":["PLAT","QT"],"title":"QT安装配置及概览","uri":"/post/plat-qt-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%A6%82%E8%A7%88/"},{"categories":null,"content":"1. 使用make menuconfig ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:1:0","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"1.1. ulfalizer/Kconfiglib Just drop kconfiglib.py and the scripts you want somewhere. There are no third-party dependencies, but the terminal menuconfig won’t work on Windows unless a package like windows-curses is installed. Kconfiglib is a Kconfig implementation in Python 2/3. ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:1:1","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"1.2. 使用 使用Kconfig语法写一个Kconfig文件。 python3 -m menuconfig/guicongfig/alldefconfig进行配置，会生成.config的中间文件. python3 -m genconfig会生成一个头文件（生成的时候，会和老文件进行对比），默认为config.h文件.需要在源码中引用。【每次更改完配置都要执行】。 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:1:2","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"1.3. Kconfig语法 KConfig使用介绍 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:1:3","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"2. CMake 一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。 CMake 入门实战 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:2:0","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"2.1. 安装 sudo apt-get install cmake. ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:2:1","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"2.2. 使用 CMake的所有的语句都写在一个叫CMakeLists.txt的文件中。 当CMakeLists.txt文件确定后,可以用ccmake命令对相关的变量值进行配置。这个命令必须指向CMakeLists.txt所在的目录。 配置完成之后,应用cmake命令生成相应的makefile（在Unix like系统下）或者 project文件（指定用window下的相应编程工具编译时）。 需要使用此工具获取Kconfig的配置。 2.2.1. 编写CMakeLists.txt “#“后面为注释的内容，CMake的命令不区分大小写. 2.2.1.1. 内置变量 1.CMAKE_BINARY_DIR/PROJECT_BINARY_DIR/\u003cprojectname\u003e_BINARY_DIR#这三个变量指代的内容是一致的,如果是 in source 编译,指得就是工程顶层目录,如果是 out-of-source 编译,指的是工程编译发生的目录。#PROJECT_BINARY_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。2.CMAKE_SOURCE_DIR/PROJECT_SOURCE_DIR/\u003cprojectname\u003e_SOURCE_DIR#这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。也就是在 in source 编译时,他跟 CMAKE_BINARY_DIR 等变量一致。#PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。3.CMAKE_CURRENT_SOURCE_DIR#指的是当前处理的 CMakeLists.txt 所在的路径4.CMAKE_CURRRENT_BINARY_DIR#如果是 in-source 编译,它跟 CMAKE_CURRENT_SOURCE_DIR 一致,如果是 out-of-source 编译,他指的是 target 编译目录。#使用我们上面提到的 ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。#使用 SET(EXECUTABLE_OUTPUT_PATH \u003c新路径\u003e)并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径。5.CMAKE_CURRENT_LIST_FILE#输出调用这个变量的 CMakeLists.txt 的完整路径6.CMAKE_CURRENT_LIST_LINE#输出这个变量所在的行7.CMAKE_MODULE_PATH#这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂,有可能会自己编写一些 cmake 模块,这些 cmake 模块是随你的工程发布的,为了让 cmake 在处理CMakeLists.txt 时找到这些模块,你需要通过 SET 指令,将自己的 cmake 模块路径设置一下。#比如# SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)# 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。8.EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH#分别用来重新定义最终结果的存放目录9.PROJECT_NAME#返回通过 PROJECT 指令定义的项目名称。COMPILE_FLAGS#编译选项LINK_FLAGS#链接选项CMAKE_C_FLAGS#CMAKE_C_FLAGS_DEBUGCMAKE_C_FLAGS_RELEASECMAKE_CXX_FLAGS#CMAKE_CXX_FLAGS_DEBUGCMAKE_CXX_FLAGS_RELEASECMAKE_SHARED_LINKER_FLAGS#共享库的链接标志CMAKE_EXE_LINKER_FLAGS#可执行程序的链接标志 使用find_package引入外部依赖包对于系统预定义的Find\u003cLibaryName\u003e.cmake模块，使用方法一般如上例所示。每一个模块都会定义以下几个变量- \u003cLibaryName\u003e_FOUND\u003cLibaryName\u003e_INCLUDE_DIRor\u003cLibaryName\u003e_INCLUDES\u003cLibaryName\u003e_LIBRARYor\u003cLibaryName\u003e_LIBRARIES 2.2.1.2. Cmake文件中数组操作 # 增LIST(APPEND\u003clist\u003e\u003celement\u003e[\u003celement\u003e...])# 追加，【改变原数组】LIST(PREPEND\u003clist\u003e[\u003celement\u003e...])# 将元素插入到列表的0索引位置LIST(INSERT\u003clist\u003e\u003celement_index\u003e\u003celement\u003e[\u003celement\u003e...])# 在指定位置将元素（一个或多个）插入到列表中# 删LIST(POP_BACK\u003clist\u003e[\u003cout-var\u003e...])# 将列表中最后元素移除，如果指定了输出变量，则会将最后一个元素移入到该变量，并【将元素从原列表中移除】。如果指定了多个输出变量，则依次将原列的最后一个元素移入到输出变量中，如果输出变量个数大于列表的长度，那么超出部分的输出变量未定义。LIST(POP_FRONT\u003clist\u003e[\u003cout-var\u003e...])# 将列表中第一个元素移除，其他与上相同LIST(REMOVE_ITEM\u003clist\u003e\u003cvalue\u003e[\u003cvalue\u003e...])# 将指定的元素从列表中移除LIST(REMOVE_AT\u003clist\u003e\u003cindex\u003e[\u003cindex\u003e...])# 将指定索引的元素从列表中移除LIST(REMOVE_DUPLICATES\u003clist\u003e)# 移除列表中的重复元素LIST(FILTER\u003clist\u003e\u003cINCLUDE|EXCLUDE\u003eREGEX\u003cregular_expression\u003e)# 根据正则表达式包含或排除列表中的元素，【改变原数组】元素变少# 改LIST(TRANSFORM\u003clist\u003e\u003cACTION\u003e[\u003cSELECTOR\u003e][OUTPUT_VARIABLE\u003coutputvariable\u003e])# 指定的动作运用到所有或者部分指定的元素# 查LIST(FIND\u003clist\u003e\u003cvalue\u003e\u003coutputvariable\u003e)# 查找，返回索引LIST(GET\u003clist\u003e\u003celementindex\u003e[\u003celementindex\u003e...]\u003coutputvariable\u003e)# 获取元素（如-1，0，1），存储到新创建的变量中LIST(JOIN\u003clist\u003e\u003cglue\u003e\u003coutputvariable\u003e)# 将列表中的元素用\u003cglue\u003e链接起来，组成一个字符串后，返回给\u003coutput variable\u003e变量LIST(LENGTH\u003clist\u003e\u003coutputvariable\u003e)# 获取数组的长度，存储到新创建的变量中LIST(SUBLIST\u003clist\u003e\u003cbegin\u003e\u003clength\u003e\u003coutputvariable\u003e)# 获取数组的一部分# 排序LIST(REVERSE\u003clist\u003e)# 将整个列表反转LIST(SORT\u003clist\u003e[COMPARE\u003ccompare\u003e][CASE\u003ccase\u003e][ORDER\u003corder\u003e])# 排序 2.2.1.3. CMakeLists.txt需要的元素 cmake_minimum_required(VERSION3.2)#1. 指定cmake的最低版本，必需PROJECT(test_mathLANGUAGESCCXX)#2. 指定工程名，一般和项目的文件夹名称对应，必需，指定语言（可选）message(\"\")#3. 用来打印信息ADD_DEFINITIONS(\"-Wall -lpthread -g\")#4. 指定编译选项INCLUDE_DIRECTORIES(include)#5. 指定【头文件】搜索目录,可以有多个LINK_DIRECTORIES()# 指定【库】搜索目录link_libraries()# （添加需要链接的库文件路径，注意这里是全路径），该用法【已经被废弃】#FIND 系列指令，通过FIND寻找路径并进行添加FIND_PATH(\u003cVAR\u003ename1path1path2...)# VAR 变量代表包含这个文件的路径FIND_FILE(\u003cVAR\u003ename1path1path2...)# VAR 变量代表找到的文件全路径，包含文件名FIND_LIBRARY(\u003cVAR\u003ename1path1path2...)#VAR 变量表示找到的库全路径，包含库文件名FIND_PROGRAM(\u003cVAR\u003ename1path1path2...)#VAR 变量代表包含这个程序的全路径。FIND_PACKAGE# 【重点】AUX_SOURCE_DIRECTORY(srcDIR_SRCS)#6. 该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名add_subdirectory(math)#7. 添加子目录，这个目录里边也有一个CMakeLists.txtSET(TEST_MATH${DIR_SRCS})#8. 设置环境变量SET(LIBRARIESlibm.so)#9. 设置外部的依赖库SET(EXECUTABLE_OUTPUT_PATH${PROJECT_BINARY_DIR}/bin)#10. 设置可执行文件的输出路径SET(FS_BUILD_BINARY_PREFIX\"Yfs\")# 加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成configur","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:2:2","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"3. 示例 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:3:0","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"3.1. Neutree/c_cpp_project_framework 一个足够简单易用并且可配置的用于构建C/C++的模板工程; 使用CMake构建，并且支持带GUI配置界面的Kconfig. ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:3:1","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"3.2. kracejic/cleanCppProject Features: Modern CMake, CPack, Doxygen, PlantUML, Catch Unit testing, static analysis. ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:3:2","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"4. 总结（适合自己的构建系统） ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:4:0","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"4.1. 目录结构 参考ESP32的目录组织。 CMakeLists.txt Kconfig - components/ #组件(一般每个组件编译为一个静态库) - component1/ - CMakeLists.txt - Kconfig - src/ - src1.c - inc/ - component2/ - CMakeLists.txt - Kconfig - src/ - src1.c - inc/ - component2.h main #生成可执行文件的主要代码 - CMakeLists.txt # 组件规则 - src - inc build #生成结果目录 cmake/ #自己写的cmake模块 tools/ #其他工具，比如读取kconfig的配置 欢迎使用模板 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/:4:1","tags":["PLAT","编译"],"title":"构建框架（make）","uri":"/post/plat-%E7%BC%96%E8%AF%91-%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6/"},{"categories":["PROGRAM"],"content":"参考Markdown 语法教程 元素 语法 删除线 ~~abcd~~ 表格内换行 \u003cbr\u003e ","date":"2021-04-02","objectID":"/post/program-markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":["PROGRAM","MARKDOWN"],"title":"MarkDown基本语法","uri":"/post/program-markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"GCC 查看编译器的默认搜索路径echo | gcc -v -x c -E -和echo | g++ -v -x c++ -E -; 查看内部预宏定义gcc -E -dM - \u003c/dev/null. 【注】linux下gcc不支标准c的gets,puts函数，可以用gcc fgets,fputs分别代替gets,puts。 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-gcc/:1:0","tags":["PLAT","编译"],"title":"GCC","uri":"/post/plat-%E7%BC%96%E8%AF%91-gcc/"},{"categories":null,"content":"编译 编译选项 -fpermissive #允许编译一些不合格的代码。 ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-gcc/:1:1","tags":["PLAT","编译"],"title":"GCC","uri":"/post/plat-%E7%BC%96%E8%AF%91-gcc/"},{"categories":null,"content":"交叉编译 Linaro + gcc-linaro- + 4.9.4-2017.01- + glibc 2.17 + 5.2-2015.11- + 5.1-2015.08- + 4.8-2014.04- + 4.7-2013.04- ","date":"2021-04-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-gcc/:1:2","tags":["PLAT","编译"],"title":"GCC","uri":"/post/plat-%E7%BC%96%E8%AF%91-gcc/"},{"categories":null,"content":"1. 多进程和多线程 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:1:0","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"1.1. 存储空间 参考Linux虚拟地址空间布局以及进程栈和线程栈总结 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:1:1","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"1.2. 多进程 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:1:2","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"1.3. 多线程 线程是可结合的（joinable），或者是分离的（detached）。决定一个线程以什么样的方式来终止自己。 一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。 在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。 要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。 线程的优先级。 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:1:3","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"1.4. 开源实现 chenshuo/muduoMuduo is a multithreaded C++ network library based on the reactor pattern. 《Linux 多线程服务端编程：使用 muduo C++ 网络库》 libevent/libevent一个用C语言编写的、轻量级的开源高性能事件通知库. ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:1:4","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"2. 协程 参考什么是协程 百度的自动驾驶系统Apollo中使用了协程作为底层调度单元。 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:2:0","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"2.1. 为什么使用协程 【线程太多】一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。每个线程至少会占用4M的内存空间，10000个线程会消耗39G的内存，而服务器的内存配置只有区区8G，这时候你有2种选择，一是选择增加服务器，二是选择提高代码效率。 协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多（启动100个线程，每个线程上运行100个协程）。 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:2:1","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"2.2. 注意事项 在协程中不能调用导致线程阻塞的操作。协程只有和【异步IO】（IO密集型）结合起来，才能发挥最大的威力。 如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式： 在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。【这其实和多线程没有太大区别】。 对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，【最好寄希望于编程语言原生支持】。 协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:2:2","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"2.3. 开源实现 Tencent/libco协程库。 ","date":"2021-03-30","objectID":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/:2:3","tags":["PLAT","LINUX","应用"],"title":"系统调用和标准库的封装","uri":"/post/plat-linux-%E5%BA%94%E7%94%A8-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"注：命令后台执行。 1. command \u0026 #后台运行，你关掉终端会停止运行 2. nohup command \u0026 #后台运行，你关掉终端也会继续运行 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:0:0","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1. 变量 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:0","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.1. 定义变量 定义：your_name=\"runoob.com\",变量名和等号之间不能有空格. 用语句给变量赋值： for file in ls /etc 或 for file in $(ls /etc)。 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:1","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.2. 使用变量 echo $your_name echo ${your_name} ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:2","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.3. 只读变量 readonly myUrl ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:3","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.4. 删除变量 unset variable_name # unset 命令不能删除只读变量 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:4","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.5. 变量类型 1.5.1. shell变量 $$ # Shell本身的PID（ProcessID） $! # Shell最后运行的后台Process的PID $? # 最后运行的命令的结束代码（返回值） 终止状态。 $- # 使用Set命令设定的Flag一览 $* # 所有参数列表。如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 $@ # 所有参数列表。如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $# # 添加到Shell的参数个数 $0 # Shell本身的文件名,但在bash下，执行source,为'bash'; $1～$n # 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 $BASH_SOURCE # 【bash】取得当前执行的 shell 文件所在的路径及文件名 $BASH_SOURCE[0] # 【bash】等价于 BASH_SOURCE , $SHELL # 当前默认使用的shell ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:5","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.6. 字符串 字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 双引号里可以有变量. 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号里可以出现转义字符 1.6.1. 拼接 使用双引号拼接greeting_1=\"hello, ${your_name} !\" 使用单引号拼接greeting_2='hello, '$your_name' !' ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:6","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"1.7. 数组 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:1:7","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2. 运算符 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:0","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2.1. 算数运算符 默认情况下，Shell 不会直接进行算术运算，而是把+两边的数据（数值或者变量）当做字符串. 要想让数学计算发挥作用，必须使用数学计算命令. (()) 和 bc 即可. 运算操作符/运算命令 说明 示例 (( )) 用于整数运算，效率很高，推荐使用。 let 用于整数运算，和 (()) 类似。 $[] 用于整数运算，不如 (()) 灵活。 expr 可用于整数运算，也可以处理字符串。比较麻烦，需要注意各种细节，不推荐使用。 bc Linux下的一个计算器程序，可以处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器。 declare -i 将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。功能有限，仅支持最基本的数学运算（加减乘除和取余），不支持逻辑运算、自增自减等，所以在实际开发中很少使用。 2.1.1. (()) ((a=10+66) ((b=a-15)) ((c=a+b)) 这种写法可以在计算完成后给变量赋值。以 ((b=a-15)) 为例，即将 a-15 的运算结果赋值给变量 c。 注意，使用变量时不用加$前缀，(( )) 会自动解析变量名。 a=$((10+66) b=$((a-15)) c=$((a+b)) 可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c=$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。 注意，类似 c=((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。 ((a\u003e7 \u0026\u0026 b==c)) (( )) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。 echo $((a+10)) 需要立即输出表达式的运算结果时，可以在 (( )) 前面加$符号。 ((a=3+5, b=a+10)) 对多个表达式同时进行计算。 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:1","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2.2. 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 运算符 说明 举例(a为10，b为20) -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:2","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2.3. 布尔运算符 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:3","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2.4. 逻辑运算符 【注】有逻辑运算符必须要双[]. 运算符 说明 举例 \u0026\u0026 逻辑的 AND [[ $a -lt 100 \u0026\u0026 $b -gt 100 ]] 返回 false || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:4","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2.5. 字符串运算符 字符串比较直接用=. ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:5","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"2.6. 文件测试运算符 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:2:6","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"3. 流程控制 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:3:0","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"3.1. if 【从本质上讲，if 检测的是命令的退出状态】 expression 和方括号( )之间必须有空格，否则会有语法错误 if [ expression 1 ] then Statement(s) to be executed if expression 1 is默认 true elif [ expression 2 ] then Statement(s) to be executed if expression 2 is true elif [ expression 3 ] then Statement(s) to be executed if expression 3 is true else Statement(s) to be executed if no expression is true fi ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:3:1","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"3.2. for for var in item1 item2 ... itemN do command1 command2 ... commandN done for var in item1 item2 ... itemN; do command1; command2… done; ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:3:2","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"4. 注释 【注】不要在行后加注释。 ","date":"2021-03-29","objectID":"/post/plat-linux-03-shell/:4:0","tags":["PLAT","LINUX"],"title":"SHELL","uri":"/post/plat-linux-03-shell/"},{"categories":null,"content":"学习状态机的三种骚操作，值得你了解 ","date":"2021-03-27","objectID":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/:0:0","tags":["PLAT"],"title":"状态机","uri":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":null,"content":"1. 概念 状态机的实现3个要素：状态、事件、响应； 有限状态机，层次状态机，并行状态机。 ","date":"2021-03-27","objectID":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/:1:0","tags":["PLAT"],"title":"状态机","uri":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":null,"content":"2. 实现方法 ","date":"2021-03-27","objectID":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/:2:0","tags":["PLAT"],"title":"状态机","uri":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":null,"content":"2.1. switch—case法 比较常用。 状态嵌套事件和事件嵌套状态,自行决断。 【注】switch—case的原理是从上到下挨个比较，越靠后，查找耗费的时间就越长，所以要注意状态和事件在各自的 switch 语句中的安排顺序；出现频率高或者实时性要求高的状态和事件的位置应该尽量靠前。 ","date":"2021-03-27","objectID":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/:2:1","tags":["PLAT"],"title":"状态机","uri":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":null,"content":"2.2. 表格驱动法 把事件当做纵轴，把状态当做横轴，交点[Sn , Em]则是系统在 Sn 状态下对事件 Em 的响应 S0 S1 S2 E0 Node_S0E0 Node_S1E0 Node_S2E0 E1 Node_S0E1 Node_S1E1 Node_S2E1 E2 Node_S0E2 Node_S1E2 Node_S2E2 E3 Node_S0E3 Node_S1E3 Node_S2E3 Node_SnEm 叫做状态机节点，在 Sn状态下对事件 Em 的响应。这里所说的响应包含两个方面：输出动作和状态迁移。 struct fsm_node { void (*fpAction)(void* pEvnt);//函数指针，pEvent事件的内容 INT8U u8NxtStat; }; 表格反映在 C 语言代码里就是一个二维数组，第 1 维就是状态机的状态（枚举），第 2维就是统一分类的事件（枚举），而数组的元素则是上述结构体常量。 【优点】效率提高，相对于switch-case方法。【缺点】可读性差，而且无法根据条件不同切换到不同的状态。 压缩表格驱动法压缩表格驱动法使用了一维数组作为驱动表格，数组的下标即是状态机的各个状态。节点函数对所有事件起作用，让动作封装函数返回一个状态， 并把这个状态作为状态机新的状态。 struct fsm_node /*压缩状态机节点结构体*/ { INT8U (*fpAction)(void* pEvnt); /*事件处理函数指针（内部就是switch-case）,返回一个状态*/ INT8U u8StatChk; /*状态校验， 程序在引用函数指针 fpAction 之前， 先检查当前状态和当前节点成员 u8CurStat 的值是否一致，一致则认为状态合法，事件正常响应，如果不一致，则认为当前状态非法，转至意外处理，最大限度保证程序运行的安全。*/ }; //也可以判断当前状态是否是这个数组的index 压缩表格驱动法是相当优秀的，它既有表格驱动法的简洁、高效、标准，又有 switch—case 法的直白、灵活、多变，相互取长补短，相得益彰。 ","date":"2021-03-27","objectID":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/:2:2","tags":["PLAT"],"title":"状态机","uri":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":null,"content":"2.3. 函数指针法 前边方法用一个全局的整型变量来记录状态值，然后再查驱动表格找函数地址，直接用一个全局的函数指针来记录状态。 函数的返回值不再是整型的状态值， 而是下一个动作封装函数的函数地址， 函数返回后， 框架代码再把这个函数地址存储到全局函数指针变量中。 不建议使用，很难判断函数指针是否合法。 ","date":"2021-03-27","objectID":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/:2:3","tags":["PLAT"],"title":"状态机","uri":"/post/plat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":null,"content":" 字符设备驱动，需要支持 O_NOBBLOCK，默认是阻塞的。 ","date":"2021-03-27","objectID":"/post/plat-linux-%E9%A9%B1%E5%8A%A8-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/:0:0","tags":["PLAT","LINUX"],"title":"驱动-字符设备","uri":"/post/plat-linux-%E9%A9%B1%E5%8A%A8-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"1. 串口 linux下的串口或者usb转串口驱动都是依赖linux内核提供的tty核心、tty线路规划和tty驱动。 ","date":"2021-03-27","objectID":"/post/plat-linux-%E9%A9%B1%E5%8A%A8-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/:1:0","tags":["PLAT","LINUX"],"title":"驱动-字符设备","uri":"/post/plat-linux-%E9%A9%B1%E5%8A%A8-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"1.1. 调试串口 查看某个串口的波特率等信息stty -F /dev/ttyS0 -a #ttyS0为要查看的串口; 设置串口参数stty -F /dev/ttyS0 ispeed 115200 ospeed 115200 cs8; 打印串口数据cat /dev/ttyS0 #串口传来数据就可以显示; 发送数据echo \"sss\" \u003e /dev/ttyS0. ","date":"2021-03-27","objectID":"/post/plat-linux-%E9%A9%B1%E5%8A%A8-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/:1:1","tags":["PLAT","LINUX"],"title":"驱动-字符设备","uri":"/post/plat-linux-%E9%A9%B1%E5%8A%A8-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"},{"categories":["PROGRAM"],"content":"线程 GIL锁，全称为Global Interpreter Lock，也就是全局解释器锁,在一个进程中每次只能有一个线程在运行。 ","date":"2021-03-15","objectID":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:0","tags":["PROGRAM","PYTHON"],"title":"并发编程","uri":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["PROGRAM"],"content":"threading ","date":"2021-03-15","objectID":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:1","tags":["PROGRAM","PYTHON"],"title":"并发编程","uri":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["PROGRAM"],"content":"线程间通讯 ","date":"2021-03-15","objectID":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:2","tags":["PROGRAM","PYTHON"],"title":"并发编程","uri":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["PROGRAM"],"content":"生产者和消费者问题 使用全局变量。 ","date":"2021-03-15","objectID":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:3","tags":["PROGRAM","PYTHON"],"title":"并发编程","uri":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["PROGRAM"],"content":"threadpool 方法 makeRequests(callable_, args_list, callback=None,exc_callback=_handle_thread_exception)#创建任务 类 ThreadPool ThreadPool(n) # 创建一个线程池，线程个数为n putRequest() # 将一个任务放进线程池中 poll() # 等待所有任务处理完 ","date":"2021-03-15","objectID":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:4","tags":["PROGRAM","PYTHON"],"title":"并发编程","uri":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["PROGRAM"],"content":"进程 ","date":"2021-03-15","objectID":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:0","tags":["PROGRAM","PYTHON"],"title":"并发编程","uri":"/post/program-python-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["其他"],"content":"1. 高新区 排名 学校名称 办学特色 公/私 学费 划分片区 1 艾瑞德国际小学 3+1教师模式（语文、数学和生长指导+全校中外英语老师合作履教）和8的倍数班额（幼儿园每班24人，小学每班32人） 2 郑中国际学校 突出国际化教育，进一步加强超常人才实验班建设，以小组合作探究为主要学习方式 3 郑州中学附属小学（一附小）（桂花街） 公 （2014-2021）金色嘉园、快乐E家、阳光馥园、帝苑别墅、五洲华夏村、郑州中学家属院、宏莲花园、文雅青年公寓、玉兰雅庭、菁翠苑范围内的适龄儿童 3 郑州中学附属小学（一附小）（玉兰街） 公 （2019-2021）金科城1号院、瓦屋李新居、美景菩提范围内的适龄儿童 4 郑州大学实验小学 公 （2015-2021）翠竹苑、西现代城小区、金盾花园符合就近入学条件的适龄儿童 注： 玉兰街校区和桂花街校区是“兄弟”关系，他们共同组成了郑州中学附属小学（一附小）。这两个校区没有总校和分校之别，没有重点和非重点之别，没有“好”与“坏”之别，没有亲疏远近之别。 两个校区有各自的划片范围，满足学生就近入学接受优质教育的需求。 两个校区的教师配备会坚持均衡配备的原则，中青年教师合理配比，各学科都会配备骨干教师进行引领。教师可以在校区间进行动态调整，部分学科教师跨校区任教。课程设置、教学进度、教学资源、学生作业、学业质量监测等完全一致，学科教研、教师培训等统一进行。 ","date":"2021-03-15","objectID":"/post/%E5%85%B6%E4%BB%96-%E5%AD%A9%E5%AD%90-%E5%B0%8F%E5%AD%A6/:1:0","tags":["其他"],"title":"高新区小学","uri":"/post/%E5%85%B6%E4%BB%96-%E5%AD%A9%E5%AD%90-%E5%B0%8F%E5%AD%A6/"},{"categories":["其他"],"content":"1.1. 郑州中学附属小学（一附小）学区房 | 考虑否 | 小区名称 | 建成年代（贝壳） | 均价（20211202） | 物业公司 | 燃气 | 暖气 | | —— | ————– | —————- | —————- | ——– | —- | | N | 宏莲花园 | 1998 | 11143 | | N | 五洲华夏村 | | 19107 | | N | 帝苑别墅 | 2000 | 15335 | | N | 郑州中学家属院 | 2000 | 12699 | | N | 青翠苑 | | | 金色嘉园 | 2005 | 14712 | | | 快乐E家 | 2005~2006 | 15659 | | | 阳光馥园 | 2005 | 16144 | | | 文雅青年公寓 | 2005 | 15020 | | | 玉兰雅庭 | 2005 | 10227 | | | 美景菩提 | 2012 | 19322 | | Y | 金科城1号院 | 2017-2019 | 20824 | | | 瓦屋李新居 | | | ","date":"2021-03-15","objectID":"/post/%E5%85%B6%E4%BB%96-%E5%AD%A9%E5%AD%90-%E5%B0%8F%E5%AD%A6/:1:1","tags":["其他"],"title":"高新区小学","uri":"/post/%E5%85%B6%E4%BB%96-%E5%AD%A9%E5%AD%90-%E5%B0%8F%E5%AD%A6/"},{"categories":["PROGRAM"],"content":"1. 语言版本 目前最广泛使用的C语言版本是 ANSI / ISO C(C89,C90)，最经典的C语言教材是《C程序设计语言(The C Programming Language) 第二版》，【几乎所有的开发工具都支持 ANSI / ISO C 标准】。1999年发布的 ISO/IEC 9899:1999标准，通常被成为C99，C99并没有得到广泛的支持。 C++ compiler support ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:1:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2. 语法 程序的入口：int main(int argc, const char * argv[])；argc参数表示了命令行中参数的个数;argv指针，数组的长度即为参数个数. 在c语言标准中，加法与减法运算对于地址的操作（适用\u0026获得地址和指针变量）和对于值的操作是不同的。 当一个加法运算，加号两边的操作数一个是指针，另一个是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再和指针的值相加；当一个减法运算，减号左边的操作数是一个指针，右边的操作数是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再被指针的值减去；当一个减法运算，减号两边的操作数都是地址时，则这两个地址的数据类型必须一致（如都是int *类型），否则无法通过编译。减法运算的结果为地址值的差，再除以该地址的数据类型的大小（如sizeof(int)）。 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.1. static 在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次【在编译阶段】，而且延长了局部变量的生命周期，直到程序运行结束以后才释放,【不能被其他函数调用】。 static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。 static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。 【注】：全局变量一个进程只有一个。 2.1.1. C++ 被 static 修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要 new 出一个类来; 被 static 修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要 new 出一个类来; 被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。【注】静态成员在一个进程中共享，多个进程间独立。 静态成员变量不能在类的内部初始化，【在类的内部只是声明，定义必须在类外,定义时不能加上static关键字】。定义时可以指定初始值,也可以不指定,不指定时系统默认其初始值为0. 类的对象可以使用静态成员函数和非静态成员函数。 如果类有一个静态成员指针变量，在进程中执行new或malloc操作分配了内存，进程退出前并不需要调用new或malloc，因为系统会自动进行释放。 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:1","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.2. const 2.2.1. C++ const成员变量是属于对象的，其生命周期就是对象的生命周期，在这个生命周期中其值是不可改变的。 非static的const成员变量不能在类的内部初始化，在类的内部只是声明，只能通过构造函数的初始化列表进行初始化,并且必须进行初始化。 为static的const成员变量，应遵循static初始化原则，在类外进行初始化. 【常变量只能初始化不能赋值】，所以在构造函数中赋值，或者使用自定义的成员函数赋值都是错误的。 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:2","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.3. 函数 【传址调用】指针作为参数在函数中传递的时候，它的实质依然是值传递，形参只是实参的一份拷贝，他们分别属于不同的两个指针变量。两个指针变量的地址肯定是不一样的，值是一样的，指向相同的内存。void funcAddr(int *a_Fml) 【引用调用】形参是实参的引用，实参与形参拥有相同的地址。系统对传过来的参数没有拷贝，不会有任何额外开销，直接使用原始变量的内存空间。所以说，引用调用是比传址更高效的调用方式。void funcRef(int \u0026a_Fml) ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:3","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.4. 冒号(:) struct中bit位的定义。 2.4.1. C++ 构造函数后加冒号是初始化表达式. ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:4","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.5. restrict 它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.如 int *restrict ptr, ptr 指向的内存单元只能被 ptr 访问到，任何同样指向这个内存单元的其他指针都是未定义的，直白点就是无效指针。 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:5","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.6. struct 2.6.1. C++ c++中允许在结构体当中定义函数，它的用法和类的用法很像，不过与类有一个区别在于，struct中定义的函数和变量都是默认为public的，但class中的则是默认为private。 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:6","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.7. volatile 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化,防止优化编译器把变量从内存装入 CPU 寄存器中，系统总是重新从它所在的内存读取数据，从而可以提供对特殊地址（一个寄存器变量或者表示一个端口数据）的稳定访问。 适用场景：【1】内嵌汇编操纵栈：这种方式属于编译无法识别的变量改变，【2】另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。 1) 中断服务程序中修改的供其它程序检测的变量需要加 volatile； 2) 多任务环境下各任务间共享的标志应该加 volatile； 3) 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义； ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:7","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.8. typedef 定义一个新类型。 2.8.1. C++ typedef定义类成员函数指针. #include \u003ciostream\u003eclass foo { public: int g (int x, int y) { return x + y ; } }; typedef int (foo::*memberf_pointer)(int, int);//是一个指向函数的指针，而且这个指针指向的函数必须是类foo的成员函数 int main() { foo f ; memberf_pointer mp = \u0026foo::g;//如何赋值 std::cout \u003c\u003c (f.*mp) (5, 8) \u003c\u003c std::endl;//如何调用 } ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:8","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"goto 尽量避免使用goto. 可以考虑使用goto的情形：(1)从多重循环中直接跳出(2)出错时清除资源(3)可增加程序的清晰度。 使用goto语句只能goto到同一函数内，而不能从一个函数里goto到另外一个函数里。 使用goto语句在同一函数内进行goto时，goto的起点应是函数内一段小功能的结束处，goto的目的label处应是函数内另外一段小功能的开始处。 不能从一段复杂的执行状态中的位置goto到另外一个位置，比如，从多重嵌套的循环判断中跳出去就是不允许的。 应该避免向两个方向跳转. ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:9","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"2.9. C++特有 2.9.1. 异常 throw 关键字除了可以用在函数体中抛出异常； throw 用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。 double func (char param) throw (int); double func (char param) throw (int, char, exception); double func (char param) throw (); 2.9.2. Lambda 函数与表达式 2.9.3. 命名空间（namespace） C语言中所有的全局标识符共享一个作用域；C++中提出了命名空间的概念； namespace Name { namespace Internal { /*...*/ } /*...*/ } 使用整个命名空间：using namespace name; 后续代码正在使用指定命名空间中的名称 使用命名空间中的变量：using name::variable 使用默认命名空间中的变量: ::variable ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:2:10","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"3. 库 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:3:0","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"3.1. 动态库 动态库只加载1份，但是其中的全局变量和静态变量会在每个进程中有1份，是独立的。 ","date":"2021-03-02","objectID":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/:3:1","tags":["PROGRAM","C/C++"],"title":"PROGRAM C C++ 基础知识拾遗","uri":"/post/program-c-c++-01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"},{"categories":["PROGRAM"],"content":"1. \u003carpa/inet.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:1:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"1.1. 宏 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:1:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"1.2. 结构体 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:1:2","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"1.3. 函数原型 unsigned long int inet_addr(const char *cp)//将一个字符串格式的ip地址转换成一个uint32_t数字格式，\"127.0.0.1\"\u003e0x100007F ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:1:3","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"2. \u003cerrno.h\u003e 定义了 errno 和各种常量。 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:2:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"3. \u003cfcntl.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:3:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"3.1. 宏 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:3:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"3.2. 函数原型 3.2.1. int fcntl (int __fd, int __cmd, ...); 针对(文件)描述符提供控制. 3.2.2. int open (const char *__file, int __oflag, ...) ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:3:2","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"4. \u003csetjmp.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:4:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"5. \u003csignal.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:5:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"6. \u003cstdio.h\u003e 标准 IO 函数库 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:6:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"6.1. 宏 EOF stdin stdout ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:6:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"6.2. 函数原型 printf()%p的实质即为将所指向的数据地址以十六进制的形式输出；对于指针来说，%p的打印的为所指向的数据地址。指针自己的实际地址为\u0026p。负值为左对齐。 getc()从文件描述符获取一个字符 putc()向文件描述符写一个字符 fgets()从文件描述符读取一行 6.2.1. void perror (const char *__s); 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。 6.2.2. int atoi (const char * str) 将字符串转换成整数。 atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('\\0’)才结束转换，并将结果返回。 返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。 6.2.3. double atof (const char* str) 将字符串转换为双精度浮点数。 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:6:2","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"7. \u003cstdlib.h\u003e 定义了四个变量类型、一些宏和各种通用工具函数. ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:7:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"函数原型 1. void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)) 对 nitems 对象的数组执行二分查找，base 指向进行查找的数组，key 指向要查找的元素，size 指定数组中每个元素的大小。 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:7:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"8. \u003cstring.h\u003e void *memset (void *__s, int __c, size_t __n)复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符. char *strchr(const char *str, int c)在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置.未找到该字符则返回 NULL. strerror()传入 errno，输出对应的错误字符串。 int strncasecmp (const char *__s1, const char *__s2, size_t __n) char *strstr(const char *haystack, const char *needle)返回在haystack中第一次出现needle字符串的位置，如果未找到则返回 null;不包含终止符 ‘\\0’. ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:8:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"9. \u003csysdefs.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:9:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"10. \u003csys/stat.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:10:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"10.1. 宏 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:10:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"11. \u003csys/wait.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:11:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"12. \u003ctime.h\u003e ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:12:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"12.1. 函数原型 12.1.1. time(time_t *t) 此函数会返回从公元 1970 年 1 月 1 日的 UTC 时间从 0 时 0 分 0 秒算起到现在所经过的秒数。如果 t 并非空指针的话，此函数也会将返回值存到 t 指针所指的内存。 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:12:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"13. \u003cunistd.h\u003e封装了类 UNIX 系统下的很多固定名称的 system_call 系统调用 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:13:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"13.1. 宏 STDIN_FILENO 标准输入的文件描述符 STDOUT_FILENO 标准输出的文件描述符 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:13:1","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"13.2. 函数原型 getpid() 获取当前进程的进程 ID getppid() 获取当前进程的父进程 ID _exit() close() 13.2.1. ssize_t read (int __fd, void *__buf, size_t __nbytes) 如果文件描述符不是 socket 的话，该函数是非阻塞的，否则该函数是阻塞的。 ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:13:2","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"14. \u003cwchar.h\u003e 标准 IO ","date":"2021-03-02","objectID":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/:14:0","tags":["PROGRAM","C/C++"],"title":"C/C++ 标准库","uri":"/post/program-c-c++-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"1. 基本数据类型（32位CPU架构） 摘自Basic data types in ARM C and C++ 类型 bit数 Natural alignment in bytes 取值范围 备注 char 8 1 (byte-aligned) 0 to 255 (unsigned) by default. –128 to 127 (signed)编译选项--signed_chars signed char 8 1 (byte-aligned) –128 to 127 unsigned char 8 1 (byte-aligned) 0 to 255 (signed) short 16 2 (halfword-aligned) –32,768 to 32,767 unsigned short 16 2 (halfword-aligned) 0 to 65,535 (signed) int 32 4 (word-aligned) –2,147,483,648 to 2,147,483,647 unsigned int 32 4 (word-aligned) 0 to 4,294,967,295 (signed) long 32 4 (word-aligned) –2,147,483,648 to 2,147,483,647 unsigned long 32 4 (word-aligned) 0 to 4,294,967,295 (signed) long long 64 8 (doubleword-aligned) –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 unsigned long long 64 8 (doubleword-aligned) 0 to 18,446,744,073,709,551,615 float 32 4 (word-aligned) 1.175494351e-38 to 3.40282347e+38 (normalized values) 如果将int转为float可能会损失精度 double 64 8 (doubleword-aligned) 2.22507385850720138e-308 to 1.79769313486231571e+308 (normalized values) long double 64 8 (doubleword-aligned) 2.22507385850720138e-308 to 1.79769313486231571e+308 (normalized values) wchar_t 16 2 (halfword-aligned) 0 to 65,535 by default. wchar_t 32 4 (word-aligned) 0 to 4,294,967,295 when compiled with –wchar32. All pointers 32 4 (word-aligned) Not applicable. bool (C++ only) 8 1 (byte-aligned) false or true _Bool (C only) 8 1 (byte-aligned) false or true ","date":"2021-03-01","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["PROGRAM"],"title":"基本数据类型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2. 浮点数的结构 内存存储 类型 占用内存 符号位 指数位 尾数位 指数范围 指数偏移 精度 float 32 1 8 23 -128~127 +127 约7位有效数字(1/(2^23)) double 64 1 11 52 -1023~1024 +1023 约16位有效数字(1/(2^52)) 符号位：最高位，0正，1负； 指数位：为以2为底的指数+指数偏移,这样可以表示负的指数。 尾数位：表示成以2为底的指数之后，小数点之后的二进制。 查看浮点内存表示 浮点数表示的数值，虽然范围比较大，但是是有误差的。 ","date":"2021-03-01","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["PROGRAM"],"title":"基本数据类型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"郑州高新区校外培训白名单（2020年12月） 序号 培训机构名称 地址 培训内容 备注 1 学而思培训学校 银屏路15号高新数码港05#商业楼1-3层附1号、2号 6-18岁课外辅导 1 学而思培训学校 翠竹街1号28/29栋3层 6-18岁课外辅导 2 郑大教育培训中心 科学大道100号郑州大学校内 3 洋光语言培训中心 翠竹街1号总部企业基地9幢4楼04号 4 晨钟数理化辅导中心 五龙口校区：华强广场三楼 4 晨钟数理化辅导中心 翠竹街1号27号楼西户 4 晨钟数理化辅导中心迎春街校区 高新区翠竹街1号62号楼1单元1楼1号 5 七色花少儿艺术中心 翠竹街企业总部基地一期26号楼7楼 6 雅君教育培训中心 翠竹街1号63幢1单元4层04号 7 平行线数理化培训中心 银杏路企业基地115号楼二楼 8 三一外语培训中心 翠竹街1号企业基地26号楼4层 9 艺术星空培训中心 翠竹街总部企业基地36号楼3-4楼 10 郑州艳华培训学校有限公司 长椿路西蔷薇路南祥谦万和城216号 11 郑州许慎培训学校有限公司 翰林国际城金梭路221号2号楼 12 大山培训学校有限公司高新分公司华强校区 华强校区 12 大山培训学校有限公司高新分公司的瑞达路校区 瑞达路校区 12 大山培训学校有限公司高新分公司 新龙路南长椿路西祥谦万和城13号楼附2号 12 大山培训学校有限公司高新分公司万科城城校区 万科城 12 大山培训学校有限公司高新分公司的祝福红城校区 祝福红城校区 12 大山培训学校有限公司高新区分公司枫杨校区 枫杨校区 13 郑州英之成语言培训学校有限公司 雪松路迎春街路北朗悦公园茂3层U-24-06 14 郑州佰特街培训学校有限公司 翰林国际城桃李园2号楼金梭路209号附4/5号 15 郑州丽禾艺术培训学校有限公司 万和城D区长椿路西13号楼附2铺 15 郑州丽禾艺术培训学校有限公司 祝福红城校区：石楠路药厂街口西北角 16 郑州百思得培训学校有限公司 翠竹街1号院23号楼01号 17 优联优教育培训学校 电厂路70号华强广场2期8号楼3层20号 18 郑州文君艺术培训学校有限公司 电厂路70号华强城市广场1期173-175号 19 河南明芮安特思库培训学校有限公司 电厂路华强广场2期8号楼 20 河南子聪培训学校有限公司 电厂路华强广场2期8号楼商业3层 21 高新区艳婷艺术培训中心 科学大道瑞达路口西南角正弘生活广场5楼 22 毓贤堂教育培训中心 高新区瑞达路樱花街口东南角樱花街5号四楼 23 大河教育培训学校 高新区兰寨新城东门北 24 郑州梦华艺术培训学校 科学大道瑞达路口创达高科二楼 25 新易成教育培训中心 瑞达路68号光华酒店裙楼10号门2层 26 彩色泡沫美术教育培训 高新区木兰里9号睿达广场二层B-2019-1 27 郑州市天勇教育培训学校有限公司 碧桃路祝福红城109号2号楼4楼 28 郑州至一东成培训学校有限公司 春藤路玉兰街向南50米路东二楼 29 郑州德诚祥培训学校有限公司 合欢街北腊梅路东1号楼二楼33铺 30 郑州市高新区溯源培训学校有限公司 高新区木兰里九号睿达广场2层 31 郑州新东方培训学校有限公司高新分公司 高新区木兰里睿达广场二楼 32 郑州市京翰一对一培训学校有限公司 瑞达路68号光华酒店裙楼10号门3层 33 河南正方向培训学校有限公司 瑞达路68号光华大酒店裙楼1栋3层 34 郑州易克思培训学校有限公司 合欢街腊梅路新芒果大厦1号楼4层 35 郑州恩而佳培训学校有限公司 高新区木兰里9号瑞达广场2层B-2828-3-1 36 郑州市春藤培训学校有限公司 郑州市高新区红莲街2号华品糖果社区6号楼 37 郑州培森培训学校有限公司 高新区谦祥万和城B区北门向西200米路南 38 爱在舞彩艺术培训学校有限公司 郑州髙新区谦祥万和城D区23号楼52-63 39 河南翰林英才培训学校有限公司 丁楼庄园8号楼一层附9号2层附8、9、10号 40 河南爱蓓培训学校有限公司 金菊街北石楠路丁楼城中村一号楼4-3商业区一层附3附25 41 郑州晞望美术培训学校有限公司 髙新区枫杨街29号公园道1号三期1号楼附27号 41 晞望美术培训学校白桦街校区 髙新区牡丹路38号9号楼附51号 42 郑州优得培训学校有限公司 朗悦公园茂U-24-05区A3004号 43 敢闯培训学校睿达广场校区 睿达广场二层B-2828-2号 43 郑州敢闯培训学校有限公司 总部企业基地三期115号楼 44 郑州板牙儿培训学校有限公司 石楠路6号二层 45 郑州市登龙门培训学校有限公司 高新区木兰里9号睿达广场二楼B-2828-2 46 河南飞斯达艺术培训学校有限公司 高新区秦岭路与东风路口华强广场二楼18号 47 郑州艺星艺术培训学校有限公司 高新区电厂路70号5号楼3层16号 48 郑州衡佳培训学校有限公司 高新区翠竹街1号总部企业基地7号楼5层 49 河南繁星培训学校有限公司 高新区谦祥万和城B区西门北21号楼1-2层 50 河南智高维尼培训学校有限公司 石楠路金菊街口西北角金菊街30号D区2号楼三层附36-附54号 51 河南星宝贝培训学校 高新区万科生活广场锦枫苑3#-3、4 52 金方德教育培训中心 高新区木兰里9号睿达广场三楼 53 郑州优实力教育培训学校 高新区银屏路正道易生活一楼 54 初美艺象美术培训学校 科学大道银屏路口西南角高新区银屏路15号10号楼3层附24号 55 郑州一舟培训学校 高新区碧桃路109号26号楼1-2层附5号 56 郑州响当当培训学校高新区分公司 高新区电厂路漳河路交叉口华强广场3层169-172号 57 郑州市高新区倍斯瑞百特培训学校 高新区碧桃路109号25幢祝福红城商业一楼（二层） 58 郑州优可培训学校有限公司 药厂街石楠路交叉口东北角祝福红城二号院6号楼第三 层 59 郑州星天艺术培训学校有限公司 高新区碧桃路109号26号楼3层附8号 60 思而睿培训学校有限公司 高新区火炬街南、紫竹路西万科生活广场锦枫苑14号楼1、2层 61 郑州东鸿培训学校有限公司 白杨路12号西溪花园3号楼三楼 62 原鸿培训学校有限公司 郑州髙新区翠竹街1号总部企业基地1-A1/22号楼 63 及励培训学校有限公司 高新区翠竹街1号总部企业基地8号楼一层 64 美之阁培训学校有限公司 髙新区翠竹街6号9号楼1楼107号2楼203–217号 65 白描培训学校有限公司 髙新区枫杨街29号院公园道1号三期3号楼一层 66 华而美艺术培训学校有限公司 髙新区玉兰街77号院洼刘新城B区4号楼1单元2楼 67 拓维培训学校有限公司 紫竹路68号万科生活广场3号楼附6号商铺 68 花漾童心艺术培训学校 紫竹路68号万科生活广场3号楼1楼7–8号、2号楼9号 69 棒拇指美术培训学校 白桦街72号附4号 ","date":"2021-03-01","objectID":"/post/child-%E6%A0%A1%E5%A4%96%E5%9F%B9%E8%AE%AD/:1:0","tags":null,"title":"CHILD 校外培训","uri":"/post/child-%E6%A0%A1%E5%A4%96%E5%9F%B9%E8%AE%AD/"},{"categories":["PROGRAM"],"content":"1. 文件 python的文件类似linux的一切皆文件，比如网络。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.1. open()打开一个文件。 默认只读。 1.1.1. 参数 file mode encoding指定编码。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:1","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.2. read()读取（输入）所有的内容。 1.2.1. 参数 数字，几个字符。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:2","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.3. readline()读取一行 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:3","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.4. readlines()逐行读取 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:4","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.5. seek()文件内移动 1.5.1. 参数 offset偏移位置。 base偏移的基本点。0从开头1从当前位置2从末尾 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:5","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.6. tell()返回打开文件的指针 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:6","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.7. write()写（输出）。。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:7","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1.8. close()关闭。最后都必须关闭。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:8","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2. 迭代器和生成器 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2.1. iter() 将一个列表变成迭代器，可以配合next()使用，访问迭代器的元素。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:1","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2.2. range() 生成一个迭代器。 步进必须是整数。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:2","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2.3. filter() 过滤。 返回函数为true的元素。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:3","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2.4. map() 每个元素执行函数。 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:4","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2.5. reduce() 需要引入_functools模块。 reduce(lambda x,y:x+y,[2,3,4],1)为10. ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:5","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"2.6. zip() zip((1,2,3),(4,5,6))为(1,4),(2,5),(3,6) 【应用场景】:字典中key和value的对掉 ","date":"2021-02-19","objectID":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:6","tags":["PROGRAM","PYTHON"],"title":"PYTHON-内建函数","uri":"/post/program-python-04-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["PROGRAM"],"content":"1. 运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.1. 算术运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:1","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.2. 赋值运算符 +=与+的区别。 In [21]: a=[] In [22]: a Out[22]: [] In [23]: a+=b'1' In [24]: a Out[24]: [49] In [25]: a= [] + b\"2432\" --------------------------------------------------------------------------- TypeError Traceback (most recent call last) \u003cipython-input-25-5f6065d809aa\u003e in \u003cmodule\u003e ----\u003e 1 a= [] + b\"2432\" TypeError: can only concatenate list (not \"bytes\") to list ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:2","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.3. 比较运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:3","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.4. 逻辑运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:4","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.5. 身份运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:5","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.6. 成员运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:6","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"1.7. 位运算符 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:1:7","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"2. 作用域 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:2:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"3. 循环 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:3:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"3.1. for 3.1.1. 推导式（迭代器） 列表推导式； 字典推导式。 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:3:1","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"4. 异常捕获（可以弹出用户友好的弹窗） try: \u003c监控异常\u003e except Exception[,reason]: # 捕获多个异常可以使用元组；可以使用as \u003c捕获异常\u003e finally: \u003c无论异常发生与否都发生\u003e ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:4:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"4.1. 异常列表 ValueError AttributeError ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:4:1","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"4.2. 自定义异常类型 使用raise可以发出异常。 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:4:2","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"4.3. with ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:4:3","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5. 函数 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.1. 定义函数 变长参数。def func(*para,**paras): 参数有默认值的话，可以省略；没有默认值，不可省略。 函数中使用【赋值语句】（=）都会创建一个新变量，如果全局有同名变量，他们是不同的。如果是给全局变量重新赋值或改变他的值，需要使用global关键字.【注】 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:1","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.2. 调用函数 使用关键字参数。c=func(a=1,b=2) ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:2","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.3. 迭代器和生成器 使用关键字yield.配合next()使用。 for in会自动调用next()方法。 def frange(start, end ,step): x=start while x\u003c end: yield x x += step ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:3","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.4. lambda表达式 作用：简化，没有函数名的函数。 lambda x,y: x+y ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:4","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.5. 闭包 外部函数的变量被内部函数引用。变量不会释放。 def sum(a): def add(b): return a+b return add sum2=sum(2) sum2(1) 实现计数器的功能，调用一次自动加1 def counter(start=0): cnt = [start] # 如果使用整形，下边再使用的时候会没有定义 def add_one(): cnt[0]+=1 return cnt[0] return add_one 实现一些科学计算。有若干变量的值不变，变的是其他一些参数。调用一次外部函数，传入不变的值；然后多次调用闭包。 可以使用lambda优化闭包，内部函数使用lambda。 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:5","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.6. 装饰器 使用场景：如计算程序的运行时间。不用重复一些代码 def timer(func): def wrapper(): start_time = time.time() func() stop_time = time.time() printf(f\"{stop_time-start_time}\") return wrapper @timer def func(): 带参数的装饰器。 def new_tips(argv): # 判断argv def tips(func): def wrapper([这里的参数定义和装饰的函数的参数定义相同]): #### func([]) #### return wrapper return tips @new_tips(\"argv\") # 装饰器带参数 def new_func(): ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:6","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"5.7. 上下文管理器 with用法。 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:5:7","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["PROGRAM"],"content":"6. 模块 import [py文件] 会执行一遍py文件中的代码。 from [py文件] import [] as别名 ","date":"2021-02-19","objectID":"/post/program-python-03-%E8%AF%AD%E6%B3%95/:6:0","tags":["PROGRAM","PYTHON"],"title":"PYTHON-语法","uri":"/post/program-python-03-%E8%AF%AD%E6%B3%95/"},{"categories":["项目管理"],"content":"1. .gitlab-ci.yaml详解 stages:# 定义构建阶段，非必须- buildjob1:#任务说明script:- execute-script-for-job1# 直接执行系统命令stage:build# 指定在哪个阶段,不能使用-tags:- docker# 指定runner的标签artifacts:# 指定附件untracked:true# 发送所有没有被git跟踪的文件name:\"\"# 指定name，\"$CI_JOB_NAME\"当前job的名字\"$CI_COMMIT_REF_NAME\"当前分支名称或者是tag${CI_JOB_STAGE}当前stagewhen:on_failure# on_success - 当job成功的时候上传artifacts。默认值on_failure - 当job失败的时候上传artifactsalways - 不论job失败还是成功都上传artifactsexpire_in:\"8h\"#用于过期后删除邮件上传的artifacts。默认情况下，artifacts都是在GitLab中永久保存paths:- binaries/- .config ","date":"2021-02-02","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/:1:0","tags":["项目管理","GIT"],"title":"Gitlab-CICD配置","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/"},{"categories":["项目管理"],"content":"2. 使用标记 ","date":"2021-02-02","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/:2:0","tags":["项目管理","GIT"],"title":"Gitlab-CICD配置","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/"},{"categories":["项目管理"],"content":"2.1. badges/shields Concise, consistent, and legible badges in SVG and raster format ","date":"2021-02-02","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/:2:1","tags":["项目管理","GIT"],"title":"Gitlab-CICD配置","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/"},{"categories":["项目管理"],"content":"2.2. sebbo2002/gitlab-badges This server acts like a very tiny shields.io to generate SVG badges for your private GitLab instance. Uses shield.io’s gh-badges to generate them. ","date":"2021-02-02","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/:2:2","tags":["项目管理","GIT"],"title":"Gitlab-CICD配置","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/"},{"categories":["项目管理"],"content":"2.3. gitlab-ci-using-badges-for-each-job ","date":"2021-02-02","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/:2:3","tags":["项目管理","GIT"],"title":"Gitlab-CICD配置","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E9%85%8D%E7%BD%AE/"},{"categories":["PROGRAM"],"content":"1. Jquery JS库。 ","date":"2021-01-29","objectID":"/post/program-js-web%E6%8F%92%E4%BB%B6/:1:0","tags":["PROGRAM","JS/TS"],"title":"WEB常用库","uri":"/post/program-js-web%E6%8F%92%E4%BB%B6/"},{"categories":["PROGRAM"],"content":"1.1. 插件 1.1.1. Datatableslink 一个高度灵活的工具，可以将任何HTML表格添加高级的交互功能 引入 cdn.datatables.net/1.10.21/css/jquery.dataTables.min.css cdn.datatables.net/1.10.21/js/jquery.dataTables.min.js ‵‵‵ 简单使用 $(document).ready(function(){ $('#myTable').DataTable(); }); ","date":"2021-01-29","objectID":"/post/program-js-web%E6%8F%92%E4%BB%B6/:1:1","tags":["PROGRAM","JS/TS"],"title":"WEB常用库","uri":"/post/program-js-web%E6%8F%92%E4%BB%B6/"},{"categories":["PROGRAM"],"content":"sweetalart2 一个美观，响应，可定制，可访问（WAI-ARIA）替代JAVASCRIPT的弹出框【零依赖】。 ","date":"2021-01-29","objectID":"/post/program-js-web%E6%8F%92%E4%BB%B6/:2:0","tags":["PROGRAM","JS/TS"],"title":"WEB常用库","uri":"/post/program-js-web%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"关于 成立于2015年6月。 全球最大的、最优秀的、最规范的综合类人力外包服务平台,没有之一。 ","date":"2020-09-10","objectID":"/post/%E6%97%A5%E5%B8%B8-upwork/:1:0","tags":["日常"],"title":"日常-Upwork","uri":"/post/%E6%97%A5%E5%B8%B8-upwork/"},{"categories":null,"content":"其他类似网站 程序员接单网站 http://www.topcoder.com TopCoder是一个面向平面设计师和程序员的网站，它采用比赛、评分、支酬等方式吸引众多平面设计师和程序员业余工作。网站主要领域均在编程方面。 http://www.toptal.com Toptal 号称全球精英自由职业者平台，宣称只筛选前3%的自由职业开发者和设计师。加入 Toptal，申请人必须通过筛选，包括英语和沟通能力，以及各种专业领域的技术考试，比如限时算法测试、现场编程等。 ","date":"2020-09-10","objectID":"/post/%E6%97%A5%E5%B8%B8-upwork/:1:1","tags":["日常"],"title":"日常-Upwork","uri":"/post/%E6%97%A5%E5%B8%B8-upwork/"},{"categories":null,"content":"第三方库 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:0","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"gensim 包含了浅层词嵌入的文本处理模块 包含了浅层词嵌入的文本处理模块，以及常用的自然语言处理相关方法，如 TF-IDF、word2vec 等模型。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:1","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"matplotlib 数据可视化 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:2","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"nltk 比较传统的自然语言处理模块 自带很多语料，以及全面的传统自然语言处理算法，比如字符串处理、卡方检验等，非常适合自然语言入门使用。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:3","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"numpy 支持大量的维度数组与矩阵运算 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:4","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"opencv 非常庞大的图像处理库 实现了非常多的图像和视频处理方法，如图像视频加载、基础特征获取、边缘检测等，处理图像通常都需要其支持。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:5","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"pandas 数据分析工具包 基于 NumPy 构建，纳入了大量的库和标准数据模型. ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:6","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"scikit-learn 基于 SciPy 进行延伸的机器学习工具包 包含大量的机器学习算法模型，有 6 大基本功能：分类、回归、聚类、数据降维、模型选择和数据预处理。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:7","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"scipy 集成了数学、科学和工程的计算包 用于有效计算 Numpy 矩阵，使 Numpy 和 Scipy 协同工作。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:1:8","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"平台 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:2:0","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"PyTorch 支持更加快速地构建项目。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:2:1","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"PaddlePaddle 中文文档全面，对于汉语的相关模型比较丰富。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:2:2","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"TensorFlow 相对成熟、应用广泛、服务全面、提供学习视频和其认证计划。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/:2:3","tags":null,"title":"python-6-数据分析-第三方库","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-03-python/"},{"categories":null,"content":"挑战 在尝试使用数据挖掘的方法来解决业务问题，却发现巨大挑战不在于算法本身，而是数据如何清洗、特征如何设计、效果如何优化，这些与业务极度相关的问题。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/:1:0","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"结构(关键是思维) ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/:2:0","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"基础知识 WHAT 数据挖掘就是寻找数据中隐含的知识并用于产生商业价值。 WHY 需要一种规范的解决方案，能够利用并且充分利用这些数据里的每一个部分(维度众多)，通过一些自动化的机器学习算法，从数据中自动提取价值。 数据挖掘就提供了这样一系列的框架、工具和方法，可以处理不同类型的大量数据，并且使用复杂的算法部署，去探索数据中的模式。 TODO 分类问题 聚类问题:聚类的算法比较适合一些不确定的类别场景。 回归问题:最大特点是，生成的结果是连续的，而不像分类和聚类生成的是一种离散的结果。 关联问题:最常见的一个场景就是推荐. HOW 应用最多的 CRISP-DM（Cross-industry Standard Process for Data Mining，跨行业数据挖掘标准流程）方法论. 1. 业务理解（Business Understanding）从业务出发，到业务中去 2. 数据理解（Data Understanding）数据理解阶段始于数据的收集工作，重点是在业务理解的基础上，对我们所掌握的数据要有一个清晰、明确的认识，了解有哪些数据、哪些数据可能对目标有影响、哪些可能是冗余数据、哪些数据存在不足或缺失. 3. 数据准备（Data Preparation）基于原始数据，去构建数据挖掘模型所需的数据集的所有工作，包括数据收集、数据清洗、数据补全、数据整合、数据转换、特征提取等一系列动作。 4. 构建模型（Modeling）对于同一个数据挖掘的问题类型，可以有多种方法选择使用。如果有多重技术要使用，那么在这一任务中，对于每一个要使用的技术要分别对待。一些建模方法对数据的形式有具体的要求 5. 评估模型（Evaluation）评估之后会有两种情况，一种是评估通过，进入到上线部署阶段；另一种是评估不通过，那么就要反过来再进行迭代更新 6. 模型部署（Deployment）部署是一个挖掘项目的结束，也是一个数据挖掘项目的开始. 在大多数的数据挖掘项目中，数据准备是最困难、最艰巨的一步。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/:2:1","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"数据挖掘过程 理解业务和数据 思想问题 避免对业务的轻视。 1. 真正理解业务场景与挖掘需求. 2. 要做一个成功的数据挖掘项目，就要去`深入学习业务`，明白业务的关键点，在项目的`需求阶段与业务方进行充分的沟通`，在`发现偏差时及时调整`，甚至在制定 OKR 的时候也与业务方来共同制定，这样在做项目的时候才不会出现南辕北辙的问题。 明白可以为和不可以为 1. 明白了业务的要求以及目标，还需要明白数据挖掘要解决的点在哪里。数据挖掘并不是万能的。 2. 第一个是数据不完美。从总体上来看，似乎我们的数据量很大、很充足，但数据的真实性、准确性、完整性具体到每一条数据的时候或者某一个需求的时候，是不完美的，甚至是匮乏的。你要解决这些问题需要付出大量的工作，甚至超出了业务本身，这就会造成入不敷出的情况，这个项目开展的必要性可能就要受到质疑了。 3. 第二个是业务条件不完美。 4. 数据挖掘只能在有限的资源与条件下去提供最大化的解决方案 5. 需要与业务方进行深入的沟通，同时对你所掌握的数据有充分的认识，对业务的难点和重点有明确的区分。建立需求多方评估机制，让业务专家与技术专家参与进来，评估需求的合理性以及你的数据情况，确认问题是否可以通过数据挖掘得到有效解决；或者是对需求进行拆解，以最大化在数据限制和业务限制前提下的项目效果。 业务背景与目标 数据挖掘是一种方法，需求的产生必然是因为某种分析需求、某个问题或者某个业务目标的需求。如果一开始就不能对问题进行准确的定位，那么后面该如何使用合适的数据选择合适的算法，都是无稽之谈。 数据挖掘工程师自行去理解业务，那很可能出现偏差，和业务方的需求产生分歧。所以这时就应该展开沟通，并成立专家小组来对目标进行评审。 把握数据 这一步有点类似可行性分析。看得到的数据能否支撑挖掘需求。 从粗粒度到细粒度，对数据的认知 1. 是否有数据 2. 有多少数据 3. 是什么样的数据:有哪些属性可以被用到. 4. 标签:针对特定的项目，比如说有监督学习任务 准备数据（开始收集、处理数据） 这个环节看起来好像是一个非核心环节，实际上在整个过程中却是最重要、最耗时的环节。 找到数据 这一步需要掌握一些数据库的使用技巧，如常用的关系型数据库 MySQL、大数据使用的 Hbase、Hive、搜索引擎数据库 ES、内存数据库 Redis，还有图数据库，如 Neo4j 或者 JanusGraph等，甚至还要跟各种业务部门沟通协商以获取数据. 找到数据之后，需要进行简单的整理，如用统一的 id 把数据整合在一起等。 数据探索 为了尽可能获得足够多的特征，要对数据进行分析、预处理以及转换等基础工作，以构建出更加贴合你所要预测结果的特征，这使得数据维度大量扩展，所以我把这个环节叫作把数据变多或者数据升维。 可以看到你的数据是否存在问题，比如异常值、数据的偏差、缺失，等等。如果是数值型的数据，还可以通过计算均值、方差、中位数、标准差、最大值、最小值等去探索、扩展。 数据清洗(最烦琐、最头疼) 处理扩展后的数据、解决所发现的问题，同时又要顾及处理后的数据是否适合应用于下一个步骤，所以我也把这一步骤称作把数据变少。 缺失值的处理 需要区分这些数据缺失的情况，因为有些是业务所允许的缺失，而有些则是错误情况导致的。 关于缺失值的处理，一般就 3 种情况：删掉有缺失值的数据；补充缺失值；不做处理。当然这些处理方式也依赖于数据是否可以被补充、缺失值是否重要，以及你所选用的算法能否处理缺失的情况等因素。 异常值的处理 异常值通常说的是那些与样本空间中绝大多数数据分布差距过大的数据：错误的情况(需要对数据进行修正，或者直接丢弃)和正常的情况（需要重视，分析后边的问题.需要根据你的业务需求进行处理。如果你的目标就是发现异常情况，那么这种异常值就需要保留下来，甚至需要特别关照。如果你的目标跟这些异常值没有关系，那么可以对这些异常值做一些修正，比如限定最大值和最小值的标准等，从而防止这些数据影响你后面模型的效果）。 数据偏差的处理 没有什么数据是非常对等和均衡的，越是天然的数据越是符合正态分布的规律。 数据偏差可能导致后面训练的模型过拟合或者欠拟合. 如果你需要比较均衡的样本，那么通常可以考虑丢弃较多的数据，或者补充较少的数据。在补充较少的数据时，又可以考虑使用现有数据去合成一些数据，或者直接复制一些数据从而增加样本数量。当然了，每一种方案都有它的优点和缺点，具体的情况还是要根据目标来决定，哪个对目标结果的影响较小就采取哪种方案。 数据标准化 防止某个维度的数据因为数值的差异，而对结果产生较大的影响。 在有些算法中，每一个维度的数据标准都需要进行统一；而在另外一些算法中，则需要统一数据的类型。 归一化。 特征选择 尽可能留下较少的数据维度，而又可以不降低模型训练的效果。 维度越多，数据就会越稀疏，模型的可解释性就会变差、可信度降低。过多维度还会造成运算的缓慢。同时那些多余的维度可能会对模型的结果产生不好的影响。 需要用到特征选择的技巧，比如自然语言处理里的关键词提取，或者去掉屏蔽词，以减少不必要的数据维度。对于数值型的数据，可以使用主成分分析等算法来进行特征选择。 构建训练集与测试集 在训练之前，你要把数据分成训练集和测试集，有些还会有验证集。 如果是均衡的数据，即各个分类的数据量基本一致，可以直接随机抽取一定比例的数据作为训练样本，另外一部分作为测试样本。 如果是非均衡的数据，比如在风控型挖掘项目中，风险类数据一般远远少于普通型数据，这时候使用分层抽样以保障每种类型的数据都可以出现在训练集和测试集中。 训练集和测试集的构建也是有方法的: 留出法，就是直接把整个数据集划分为两个互斥的部分，使得训练集和测试集互不干扰，这个是最简单的方法，适合大多数场景； 交叉验证法，先把数据集划分成 n 个小的数据集，每次使用 n-1 个数据集作为训练集，剩下的作为测试集进行 n 次训练，这种方法主要是为了训练多个模型以降低单个模型的随机性； 自助法，通过重复抽样构建数据集，通常在小数据集的情况下非常适用。 思想准备 准备数据可能是数据挖掘所有环节中，最苦、最累、耗时最长的一环了. 而且当你的模型出现错误，结果达不到预期，往往需要重新回到数据准备环节进行处理，反复迭代几次最终才能达到你期望的目标。 数据建模（如何选择算法）模型训练 首先你得明白你面对的是什么问题，虽然算法众多，但是要解决的难题往往有共同点，针对每一类型的问题，就可以找到对应的算法，再根据算法的特性去进行选择。 分类问题（寻找决策边界） 分类是有监督的学习过程（首先要有一批已经有标签结果的数据）。 【二分类】只有“是”或“否”。 【多分类】 在二分类的基础上，将标签可选范围扩大。 【多标签分类】对于二分类和多分类，一条内容最后的结果只有一个，标签之间是互斥的关系。多标签分类下的一条数据可以被标注上多个标签。 【算法】像 KNN 算法、决策树算法、随机森林、SVM 等都是为解决分类问题设计的。 聚类问题 聚类是无监督的。 聚类就是把一个数据集划分成多个组的过程，使得组内的数据尽量高度集中，而和其他组的数据之间尽量远离。这种方法是针对已有的数据进行划分，不涉及未知的数据。 互斥 一个元素只存在于一个小组。 【第一种：基于划分的聚类，通常用于互斥的小组】 相交 一条数据可能既存在于 A 组，也存在于 B 组之中。 【第二种：基于密度的聚类，可以用来解决数据形状不均匀的情况。】有些数据集分布并不均匀，而是呈现不规则的形状，而且组和组之间有一片空白区域，这个时候用划分的方法就很难处理，但是基于密度的聚类不会受到分布形状的影响，只是根据数据的紧密程度去聚类。 层次 一个大组还可以细分成若干个小组。 【第三种：基于层级的聚类，适用于需要对数据细分的情况。】要把数据按照层次进行分组，可以使用自顶向下的方法，使得全部数据只有一个组，然后再分裂成更小的组，直到满足你的要求。如有从属关系，需要细分的数据，就非常适合这种方法。同样，也可以使用自底向上的方法，最开始每一条数据都是一个组，然后把离得近的组合并起来，直到满足条件。 模糊 一个用户并不绝对属于某个小组，只是用概率来表示他和某个小组的关系。假设有五个小组，那么他属于这五个小组的模糊关系就是[0.5,0.5,0.4,0.2,0.7]。 【最后一种：基于模型的聚类。】首先假设我们的数据符合某种概率分布模型，比如说高斯分布或者正态分布， 那么对于每一种类别都会有一个分布曲线，然后按照这个概率分布对数据进行聚类，从而获得模糊聚类的关系。 回归问题（找到最优拟合） 与分类问题十分相似.监督学习。分类方法输出的是离散的标签，回归方法输出的结果是连续值。 回归就是要通过拟合数据找到一个函数。这条线可能不通过任何一个数据点，而是使得所有数据点到这条线的距离都是最短的，或者说是损失最小的。 回归方法和分类方法可以相互转化。在使用回归方法得到函数方程式以后，你可以根据对新数据运算的结果进行区间分段，高于某个阈值给定一个标签，低于该阈值给定另外一个标签；相反，对于通过分类方法得到的标签，你可以根据给定标签的概率值为其增加一些运算逻辑，将标签转换到一个连续值的结果上。。 关联问题 关联分析。无监督学习。 【目标】是挖掘隐藏在数据中的关联模式并加以利用。关联分析是要在已有的数据中寻找出数据的相关关系，以期望能够使用这些规则去提升效率和业绩。 关联分析被广泛地用于各种商品销售分析、相关推荐系统分析、用户行为分析等情况。 但是在进行大量数据的关联分析时，你会发现各种奇怪的组合，这可能是数据偏差产生的影响，所以在最终结果应用的时","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/:2:2","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"算法详解 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/:2:3","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"分类算法 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/:1:0","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析-02-算法简介","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"最近邻算法（K-NearestNeighbor）KNN：近朱者赤，近墨者黑 找到 K 个与新数据最近的样本，取样本中最多的一个类别作为新数据的类别。 【距离最近】关于距离该怎么计算呢？最常见的一个计算方法就是欧式距离，即两点之间的连线，如果放在地图上就是两个房子的直线距离。当然除了欧式距离，还有很多距离计算的方式，比如曼哈顿距离、切比雪夫距离等。 优缺点 优点 【简单易实现】KNN 算法最后实际上并没有抽象出任何模型，而是把全部的数据集直接当作模型本身，当一条新数据来了之后跟数据集里面的每一条数据进行对比。 【对于边界不规则的数据效果较好】最终的预测是把未知数据作为中心点，然后画一个圈，使得圈里有 K 个数据，所以对于边界不规则的数据，要比线性的分类器效果更好。 缺点 【只适合小数据集】每次预测新数据都需要使用全部的数据集。 【数据不平衡效果不好】特别多的数据最后在投票的时候会更有竞争优势。 【必须要做数据标准化】使用距离来进行计算，如果数据量纲不同，数值较大的字段影响就会变大，所以需要对数据进行标准化，比如都转换到 0-1 的区间。 【不适合特征维度太多的数据】 只能处理小数据集，如果数据的维度太多，那么样本在每个维度上的分布就很少。比如我们只有三个样本，每个样本只有一个维度，这比每个样本有三个维度特征要明显很多。 关于 K（距离最近的样本数） 的选取 当K 越小的时候容易过拟合；K 越大的时候容易欠拟合。 对于 K 的取值，一种显而易见的办法就是从 1 开始不断地尝试，查看准确率。随着 K 的增加，一般情况下准确率会先变大后变小，然后选取效果最好的那个 K 值就好了。\r当然，关于 K 最好使用奇数，因为偶数在投票的时候就困难了，如果两个类别的投票数量是一样的，那就没办法抉择了，只能随机选一个。\r ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/:1:1","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析-02-算法简介","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"决策树 算法原理 把所有样本数据中出现的情况组合都构建入这棵树的时候，我们的算法也就完成了对样本的学习。最终形成的这棵树上，所有的叶子节点都是要输出的类别信息，所有的非叶子节点都是特征信息。当一个新的数据来了之后，就按照对应的判断条件，从根节点走到叶子节点，从而获得这个数据的分类结果。 【如何选择一个特征作为根节点？下一次决策又该选取哪个特征作为节点？】决策树算法使用了一种称作信息增益的方法来衡量一个特征和特征之间的重要性，信息增益越大表明这个特征越重要，那么就优先对这个特征进行决策。 实际上决策树实现的时候都采用了贪心算法，来寻找一个最近的最优解，而不是全局的最优解。 算法优缺点 不同版本 决策树最初的版本称为 ID3（ Iterative Dichotomiser 3 ），ID3 的缺点是无法处理数据是连续值的情况，也无法处理数据存在缺失的问题，需要在准备数据环节把缺失字段进行补齐或者删除数据。后来有人提出了改进方案称为 C4.5，加入了对连续值属性的处理，同时也可以处理数据缺失的情况。同时，还有一种目前应用最多的 CART（ Classification And Regression Tree）分类与回归树，每次分支只使用二叉树划分，同时可以用于解决回归问题。 CART优点 【非常直观，可解释极强】:在生成的决策树上，每个节点都有明确的判断分支条件，所以非常容易看到为什么要这样处理，比起神经网络模型的黑盒处理，高解释性的模型非常受金融保险行业的欢迎。 【预测速度比较快】 由于最终生成的模型是一个树形结构，对于一条新数据的预测，只需要按照条件在每一个节点进行判定就可以。通常来说，树形结构都有助于提升运算速度。 【既可以处理离散值也可以处理连续值】还可以处理缺失值。 CART缺点 【容易过拟合】在极端的情况下，我们根据样本生成了一个最完美的树，那么样本中出现的每一个值都会有一条路径来拟合，所以如果样本中存在一些问题数据，或者样本与测试数据存在一定的差距时，就会看出泛化性能不好，出现了过拟合的现象。 【需要处理样本不均衡的问题】如果样本不均衡，某些特征的样本比例过大，最终的模型结果将会更偏向这些特征。 【样本的变化会引发树结构巨变】 关于剪枝 【决策树容易过拟合】需要使用剪枝的方式来使得模型的泛化能力更好，所以剪枝可以理解为简化我们的决策树，去掉不必要的节点路径以提高泛化能力。剪枝的方法主要有预剪枝和后剪枝两种方式。 【预剪枝】在决策树构建之初就设定一个阈值，当分裂节点的熵阈值小于设定值的时候就不再进行分裂了；然而这种方法的实际效果并不是很好，因为谁也没办法预料到我们设定的恰好是我们想要的。 【后剪枝】后剪枝方法就是在我们的决策树已经构建完成以后，再根据设定的条件来判断是否要合并一些中间节点，使用叶子节点来代替。在实际的情况下，通常都是采用后剪枝的方案。 扩展 【随机森林】为了更好地解决泛化及树结构变动等问题，从决策树演进出来随机森林算法。根据我们前面讲的模型集成方法，随机森林就是使用了 bagging 方案构建了多棵决策树，然后对所有树的结果来进行平均计算以获得最终的结果。 【GBDT】在随机森林的基础上，研究者又提出了梯度提升决策树算法（Gradient Boosting Decision Tree，GBDT），GBDT 是基于 boosting 的策略。与随机森林一样的是，GBDT 也会构建多棵决策树；但不同的是，GBDT 构建的多棵树之间是有联系的，每个分类器在上一轮分类器的残差基础上进行训练。 【XGBoost】一个非常火热的模型，有“机器学习大杀器”之称，在很多比赛中都获得了非常好的结果。但实际上 XGBoost 不算是一个算法，而是对 GBDT 的一种工程实现，它优化了 GBDT 里面的求解过程，并加入了很多工程上的优化项目，使得数据处理、运算速度等环节都有了很大的提升。 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/:1:2","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析-02-算法简介","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"朴素贝叶斯 ","date":"2020-09-03","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/:1:3","tags":["数据分析","数据挖掘"],"title":"大数据架构笔记-数据分析-02-算法简介","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-02-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"},{"categories":["设计模式"],"content":"1. 行为型 创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。 1.1. 观察者模式 *** 1.2. 模板模式 1.3. 策略模式 1.4. 职责链模式 1.5. 迭代器模式 1.6. 状态模式 1.7. 访问者模式 1.8. 备忘录模式 1.9. 命令模式 1.10. 解释器模式 1.11. 中介模式 ","date":"2020-08-29","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%A1%8C%E4%B8%BA%E5%9E%8B/:0:1","tags":["设计模式","PROGRAM"],"title":"设计模式-行为型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%A1%8C%E4%B8%BA%E5%9E%8B/"},{"categories":["设计模式"],"content":"1. 结构型 结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。不常用的有：门面模式、组合模式、享元模式。 1.1. 代理模式 在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。 1.1.1. 第一种方法 代理类和原始类需要实现相同的接口。将原始类依赖注入到代理类中。 1.1.2. 第二种方法 【如果不知道原始类的接口】。一般都是采用继承的方式。让代理类继承原始类（使用super），然后扩展附加功能。 1.1.3. 第三种方法 【如果需要代理的类太多】可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）. public class MetricsCollectorProxy { private MetricsCollector metricsCollector; public MetricsCollectorProxy() { this.metricsCollector = new MetricsCollector(); } public Object createProxy(Object proxiedObject) { Class\u003c?\u003e[] interfaces = proxiedObject.getClass().getInterfaces(); DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject); return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler); } private class DynamicProxyHandler implements InvocationHandler { private Object proxiedObject; public DynamicProxyHandler(Object proxiedObject) { this.proxiedObject = proxiedObject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long startTimestamp = System.currentTimeMillis(); Object result = method.invoke(proxiedObject, args); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; String apiName = proxiedObject.getClass().getName() + \":\" + method.getName(); RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return result; } } } //MetricsCollectorProxy使用举例 MetricsCollectorProxy proxy = new MetricsCollectorProxy(); IUserController userController = (IUserController) proxy.createProxy(new UserController()); Spring AOP 底层的实现原理就是基于动态代理。用户\u0008配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。 1.1.4. 应用场景(比如egg中middleware) 1.1.4.1. 业务系统的非功能性需求开发 比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。 这部分工作都是可以在 Spring AOP 切面中完成的。 1.1.4.2. 代理模式在 RPC、缓存中的应用 通过远程代理，将网络通信、数据编解码等细节隐藏起来。 针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。 1.2. 桥接模式 将抽象和实现解耦，让它们可以独立变化。 一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。 通过组合关系来替代继承关系，避免继承层次的指数级爆炸。 1.2.1. JDBC package com.mysql.jdbc; import java.sql.SQLException; public class Driver extends NonRegisteringDriver implements java.sql.Driver { static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } /** * Construct a new driver and register it with DriverManager * @throws SQLException if a database error occurs. */ public Driver() throws SQLException { // Required for Class.forName().newInstance() } } 执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。 当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。 public class DriverManager { private final static CopyOnWriteArrayList\u003cDriverInfo\u003e registeredDrivers = new CopyOnWriteArrayList\u003cDriverInfo\u003e(); //... static { loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); } //... public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException { if (driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver)); } else { throw new NullPointerException(); } } public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\"user\", user); } if (password != null) { info.put(\"password\", password); } return (getConnection(url, info, Reflection.getCallerClass())); } //... } “抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口","date":"2020-08-29","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E7%BB%93%E6%9E%84%E5%9E%8B/:0:1","tags":["设计模式","PROGRAM"],"title":"设计模式-结构型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E7%BB%93%E6%9E%84%E5%9E%8B/"},{"categories":null,"content":"数据类型 ","date":"2020-08-28","objectID":"/post/program-php-%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"PHP-基础","uri":"/post/program-php-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"array 数组(键为数字)和字典（键值对）都是array。 方法 array_merge 如果这两个数组中有相同的字符串键名，后者将替换前者。 但如果使用的是array_merge_recursive()则可保留，并作一个子数组存在。 如果数组中包含相同的数字键名，则后面的不会覆盖前面的值，而是后面的键值按顺序依次增加，附在后边。 ","date":"2020-08-28","objectID":"/post/program-php-%E5%9F%BA%E7%A1%80/:1:1","tags":null,"title":"PHP-基础","uri":"/post/program-php-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"ThinkPHP ","date":"2020-08-28","objectID":"/post/program-php-%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"PHP-基础","uri":"/post/program-php-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"使用LOG use think\\Log; Log::record('[ WECHAT ] ' . var_export($temp_teturn_arr, true), 'info'); // 打印变量 ","date":"2020-08-28","objectID":"/post/program-php-%E5%9F%BA%E7%A1%80/:2:1","tags":null,"title":"PHP-基础","uri":"/post/program-php-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"使用环境变量 使用getenv ","date":"2020-08-28","objectID":"/post/program-php-%E5%9F%BA%E7%A1%80/:2:2","tags":null,"title":"PHP-基础","uri":"/post/program-php-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"基础 ClickHouse有非常优异的查询性能，非常适合海量数据在线查询分析场景。 ","date":"2020-08-26","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/:1:0","tags":["数据库"],"title":"后端-数据库-CLICKHOUSE","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/"},{"categories":null,"content":"查询优势 行式数据库查询一列的数据，查询的时候也必须把其他的数据顺便查出来，所以会有磁盘IO的性能问题。 列式数据库只需要把这一列查询出来就行了，其他的没有关系的不关心，瞬间就减少了数据量呀，这个优点尤其是在海量数据的时候尤其明显，查询速度秒杀行式数据库。 mysql在做查询优化的时候，最常用的手段就是建立索引，可是我们想一想，数据量一旦大的时候，索引也会成倍的增长。 列式数据库则不然，他的每一列就是索引，减少了额外建立索引的内容。 【缺点】查询全列数据。 ","date":"2020-08-26","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/:1:1","tags":["数据库"],"title":"后端-数据库-CLICKHOUSE","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/"},{"categories":null,"content":"压缩优势【磁盘IO】 列式数据库按照一列列来存贮，每一列的数据的相同性极高，这就为压缩埋下了很好的种子，压缩比可以达到很大，可以达到5～20倍以上。 ","date":"2020-08-26","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/:1:2","tags":["数据库"],"title":"后端-数据库-CLICKHOUSE","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/"},{"categories":null,"content":"使用场景 行式数据库主要应用于传统的业务场景中 列式数据库则应该发挥他查询速度方面的优势，主要用于海量数据分析一类的方面。 数据分析场景特点： 1. 读多于写:数据一次性写入后，分析师需要尝试从各个角度对数据做挖掘、分析，直到发现其中的商业价值、业务变化趋势等信息。 2. 大宽表(列数高达数百甚至数千列)，读大量行但是少量列，结果集较小. 3. 数据批量写入(存档)，且数据不更新或少更新. 4. 无需事务，数据一致性要求低。（对于事务需求较少，通常是导入历史日志数据，或搭配一款事务型数据库并实时从事务型数据库中进行数据同步。多数OLAP系统都支持最终一致性。） 5. 灵活多变，不适合预先建模。 ","date":"2020-08-26","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/:1:3","tags":["数据库"],"title":"后端-数据库-CLICKHOUSE","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/"},{"categories":null,"content":"clickhouse特点 ClickHouse支持在建表时，指定将数据按照某些列进行sort by。 主键索引。ClickHouse支持主键索引，它将每列数据按照index granularity（默认8192行）进行划分，每个index granularity的开头第一行被称为一个mark行。主键索引存储该mark行对应的primary key的值。 ClickHouse支持对任意列创建任意数量的稀疏索引。其中被索引的value可以是任意的合法SQL Expression，并不仅仅局限于对column value本身进行索引。之所以叫稀疏索引，是因为它本质上是对一个完整index granularity（默认8192行）的统计信息，并不会具体记录每一行在文件中的位置。 数据Sharding 数据Partitioning 数据TTL 高吞吐写入能力 有限支持delete、update 主备同步 ClickHouse计算层 多核并行 分布式计算 向量化执行与SIMD 动态代码生成Runtime Codegen 近似计算 复杂数据类型支持 ","date":"2020-08-26","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/:1:4","tags":["数据库"],"title":"后端-数据库-CLICKHOUSE","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%97%E5%BC%8F-clickhouse/"},{"categories":["PROGRAM"],"content":" 从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。 大部分设计模式要解决的都是代码的可扩展性问题。 了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。 创建型设计模式 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。不常用的有：原型模式。 创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:0:0","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1. 单例模式 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:0","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.1. 为什么使用单例模式 1.1.1. 处理资源冲突（多线程环境下） 如何解决： 1. 对象级别的锁(只能解决同一个对象在不同的线程下顺序执行，不同对象之间并不共享同一把锁) ```java public class Logger { private FileWriter writer; public Logger() { File file = new File(\"/Users/wangzheng/log.txt\"); writer = new FileWriter(file, true); //true表示追加写入(FileWriter 本身就是线程安全的，它的内部实现中本身就加了对象级别的锁) } public void log(String message) { synchronized(this) { writer.write(mesasge); } } } ``` 2. 把对象级别的锁，换成类级别的锁(可以解决问题) ```java public class Logger { private FileWriter writer; public Logger() { File file = new File(\"/Users/wangzheng/log.txt\"); writer = new FileWriter(file, true); //true表示追加写入 } public void log(String message) { synchronized(Logger.class) { // 类级别的锁 writer.write(mesasge); } } } ``` 3. 分布式锁（实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情） 4. 并发队列（比如 Java 中的 BlockingQueue）：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。 5. 使用单例模式（思路简单一些）：不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。 1.1.2. 表示全局唯一类（有些数据在系统中只应保存一份） 配置信息类。 唯一递增 ID 号码生成器。 日志类。 数据库连接池类。 线程池类。 文件系统。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:1","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.2. 如何实现一个单例 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例； 考虑对象创建时的线程安全问题； 考虑是否支持延迟加载； 考虑 getInstance() 性能是否高（是否加锁）。 1.2.1. 饿汉式 ```java public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static final IdGenerator instance = new IdGenerator();//在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的,这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例） private IdGenerator() {} public static IdGenerator getInstance() { return instance; } public long getId() { return id.incrementAndGet(); } } // 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程 // 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好 ``` 1.2.2. 懒汉式(相对于饿汉式的优势是支持延迟加载,但是不支持高并发) ```java public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static synchronized IdGenerator getInstance() {//getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了.偶尔用到可以接受 if (instance == null) { instance = new IdGenerator(); } return instance; } public long getId() { return id.incrementAndGet(); } } ``` 1.2.3. 双重检测 ```java public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static IdGenerator getInstance() { if (instance == null) { synchronized(IdGenerator.class) { // 此处为类级别的锁 if (instance == null) { instance = new IdGenerator(); } } } return instance; } public long getId() { return id.incrementAndGet(); } } //解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序 ``` 1.2.4. 静态内部类 ```java public class IdGenerator { private AtomicLong id = new AtomicLong(0); private IdGenerator() {} private static class SingletonHolder{ private static final IdGenerator instance = new IdGenerator(); } public static IdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); } } //SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。 ``` 1.2.5. 枚举 ```java public enum IdGenerator { INSTANCE; private AtomicLong id = new AtomicLong(0); public long getId() { return id.incrementAndGet(); } } ``` ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:2","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.3. 单例存在哪些问题 大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。 1.3.1. 单例对 OOP 特性的支持不友好 IdGenerator 的使用方式违背了基于接口而非实现的设计原则。 从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。 1.3.2. 单例会隐藏类之间的依赖关系 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。 1.3.3. 单例对代码的扩展性不友好 单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。 1.3.4. 单例对代码的可测试性不友好 单例类这种硬编码式的使用方式，导致无法实现 mock 替换。 成员变量相当于一种全局变量。 1.3.5. 单例不支持有参数的构造函数（参数只有在new instance的时候有用） 第一种解决思路：在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。 第二种解决思路是：将参数放到 getIntance() 方法中。 第三种解决思路是：将参数放到另外一个全局变量（配置对象）中。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:3","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.4. 替代方案 为了保证全局唯一，除了使用单例，我们还可以用静态方法（操作静态变量）来实现。 静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。 第2中方法 ```java // 1. 老的使用方式 public demofunction() { //... long id = IdGenerator.getInstance().getId(); //... } // 2. 新的使用方式：依赖注入 public demofunction(IdGenerator idGenerator) { long id = idGenerator.getId(); } // 外部调用demofunction()的时候，传入idGenerator IdGenerator idGenerator = IdGenerator.getInsance(); demofunction(idGenerator); ``` 类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:4","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.5. 如何理解单例模式中的唯一性？ 单例模式创建的对象是进程唯一的。在进程间是不唯一的. 进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。 线程唯一 ```java public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static final ConcurrentHashMap\u003cLong, IdGenerator\u003e instances = new ConcurrentHashMap\u003c\u003e(); private IdGenerator() {} public static IdGenerator getInstance() { Long currentThreadId = Thread.currentThread().getId(); instances.putIfAbsent(currentThreadId, new IdGenerator()); return instances.get(currentThreadId); } public long getId() { return id.incrementAndGet(); } } ``` Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。 对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader） ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:5","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.6. 如何实现集群环境下的单例？ 具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）.进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。 为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:6","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.7. 如何实现一个多例模式？ “多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象.多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。 对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象。 枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:1:7","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2. 工厂模式 当创建逻辑比较复杂（if-else 分支判断，组合其他类对象，做各种初始化操作），是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。代码复用：\u0008创建代码抽离到独立的工厂类之后可以复用。隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:2:0","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.1. 简单工厂（工厂方法模式的一种特例） 根据不同的特性，创建不同的对象。 ```java public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension); if (parser == null) { throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); } String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; } } // 为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创 建。 // 大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的 public class RuleConfigParserFactory { // 工厂类中创建对象的方法一般都是 create 开头（静态的方法） public static IRuleConfigParser createParser(String configFormat) { IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(configFormat)) { parser = new JsonRuleConfigParser(); } else if (\"xml\".equalsIgnoreCase(configFormat)) { parser = new XmlRuleConfigParser(); } else if (\"yaml\".equalsIgnoreCase(configFormat)) { parser = new YamlRuleConfigParser(); } else if (\"properties\".equalsIgnoreCase(configFormat)) { parser = new PropertiesRuleConfigParser(); } return parser; } } ``` 第二种方式，工厂模式和单例模式的结合。 ```java public class RuleConfigParserFactory { private static final Map\u003cString, RuleConfigParser\u003e cachedParsers = new HashMap\u003c\u003e(); static { cachedParsers.put(\"json\", new JsonRuleConfigParser()); cachedParsers.put(\"xml\", new XmlRuleConfigParser()); cachedParsers.put(\"yaml\", new YamlRuleConfigParser()); cachedParsers.put(\"properties\", new PropertiesRuleConfigParser()); } public static IRuleConfigParser createParser(String configFormat) { if (configFormat == null || configFormat.isEmpty()) { return null;//返回null还是IllegalArgumentException全凭你自己说了算 } IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); return parser; } } ``` ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:2:1","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.2. 工厂方法 工厂方法模式比起简单工厂模式更加符合开闭原则。 ```java public interface IRuleConfigParserFactory { IRuleConfigParser createParser(); } public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new JsonRuleConfigParser(); } } public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new XmlRuleConfigParser(); } } public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new YamlRuleConfigParser(); } } public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new PropertiesRuleConfigParser(); } } ``` 【使用】可以为工厂类再创建一个简单工厂(第二种)，也就是工厂的工厂，用来创建工厂类对象。 需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。 2.2.1. 使用场景 当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。 避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。 【本质】简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中,工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中. ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:2:2","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.3. 抽象工厂（了解） 【解决的问题】在简单工厂和工厂方法中，类只有一种分类方式。如果有多种分类方法，就需要抽象工厂模式。让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。 public interface IConfigParserFactory { IRuleConfigParser createRuleParser(); ISystemConfigParser createSystemParser(); //此处可以扩展新的parser类型，比如IBizConfigParser } public class JsonConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new JsonRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new JsonSystemConfigParser(); } } public class XmlConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new XmlRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new XmlSystemConfigParser(); } } // 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:2:3","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.4. 设计一个依赖注入框架（DI容器） DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。 一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。 DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。 DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。但是，大部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直接影响到我们排查问题的效率。 2.4.1. 配置解析 将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。 例如spring的配置文件 配置文件beans.xml： \u003cbeans\u003e \u003cbean id=\"rateLimiter\" class=\"com.xzg.RateLimiter\"\u003e \u003cconstructor-arg ref=\"redisCounter\"/\u003e \u003c/bean\u003e \u003cbean id=\"redisCounter\" class=\"com.xzg.redisCounter\"\u003e \u003cconstructor-arg type=\"String\" value=\"127.0.0.1\"\u003e \u003cconstructor-arg type=\"int\" value=1234\u003e \u003c/bean\u003e \u003c/beans\u003e 2.4.2. 创建对象(反射语法) 只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。 使用反射(一种动态加载类和创建对象的机制)机制，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。 2.4.3. 对象的生命周期管理 例如spring框架 scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。 还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。 2.4.4. 如何实现 2.4.5. spring的循环依赖 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:2:4","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"3. 建造者模式（Builder） 【问题】构造方法的参数过多，容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。 可以使用set解决上边的问题，必须的参数放在构造方法中，非必须的使用set。 【问题升级 合法校验（Preconditions）】必填的配置项有很多。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。 【问题升级2 依赖关系（Dependencies）】假设配置项之间有一定的依赖关系。 【问题升级3 不可变（Immutable）】希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:3:0","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"3.1. 使用建造者模式 把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。 ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。 public class ResourcePoolConfig { private String name; private int maxTotal; private int maxIdle; private int minIdle; private ResourcePoolConfig(Builder builder) { this.name = builder.name; this.maxTotal = builder.maxTotal; this.maxIdle = builder.maxIdle; this.minIdle = builder.minIdle; } //...省略getter方法... //我们将Builder类设计成了ResourcePoolConfig的内部类。 //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。 public static class Builder { private static final int DEFAULT_MAX_TOTAL = 8; private static final int DEFAULT_MAX_IDLE = 8; private static final int DEFAULT_MIN_IDLE = 0; private String name; private int maxTotal = DEFAULT_MAX_TOTAL; private int maxIdle = DEFAULT_MAX_IDLE; private int minIdle = DEFAULT_MIN_IDLE; public ResourcePoolConfig build() { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等 if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(\"...\"); } if (maxIdle \u003e maxTotal) { throw new IllegalArgumentException(\"...\"); } if (minIdle \u003e maxTotal || minIdle \u003e maxIdle) { throw new IllegalArgumentException(\"...\"); } return new ResourcePoolConfig(this); } public Builder setName(String name) { if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(\"...\"); } this.name = name; return this; } public Builder setMaxTotal(int maxTotal) { if (maxTotal \u003c= 0) { throw new IllegalArgumentException(\"...\"); } this.maxTotal = maxTotal; return this; } public Builder setMaxIdle(int maxIdle) { if (maxIdle \u003c 0) { throw new IllegalArgumentException(\"...\"); } this.maxIdle = maxIdle; return this; } public Builder setMinIdle(int minIdle) { if (minIdle \u003c 0) { throw new IllegalArgumentException(\"...\"); } this.minIdle = minIdle; return this; } } } // 这段代码会抛出IllegalArgumentException，因为minIdle\u003emaxIdle ResourcePoolConfig config = new ResourcePoolConfig.Builder() .setName(\"dbconnectionpool\") .setMaxTotal(16) .setMaxIdle(10) .setMinIdle(12) .build(); 【缺点】如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的，可以不使用此模式。另外，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:3:1","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"4. 原型模式 【问题】如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。 如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到。 我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:4:0","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"4.1. 使用原型模式 拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:4:1","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"4.2. 原型模式的实现方式：深拷贝和浅拷贝 浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。 在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。 【实现1】递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。 【实现2】先将对象序列化，然后再反序列化成新的对象。 【实现3】先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。 ","date":"2020-08-24","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/:4:2","tags":["设计模式","PROGRAM"],"title":"设计模式-创建型","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"categories":null,"content":"朴素贝叶斯（NB） 在统计资料的基础上，依据某些特征，计算各个类别的概率，从而实现分类。 主体、特征和类别三个元素。 主体和类别好确定。特征的值不好确定（离散值）【连续值通过划分区间可变为离散值】【少的样本可通过正态分布获得特征值】 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"优点： 简单、易实现、适合文本。 容易并行。 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:1:1","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"缺点： 独立性假设。 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:1:2","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"模型 概率值。p(y) p(x|y) ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:1:3","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"实践（文章分类） 数据预处理 样本拆分训练集和测试集，并且ID化。 训练模型 测试 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:1:4","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"决策树（DT） 直接使用决策树解决分类问题，实际工作中不是很常用。 但是经常会使用他衍生出来的其他算法（randforest/gbdt等）。 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"信息熵、香农定理 描述混乱程度、纯度、不确定度 信息量 信息量是对信息的度量。 信息的大小跟随机事件的概率有关。越小概率的事情发生了产生的信息量越大；越大概率的事情发生了产生的信息量越小。 信息量的公式： 𝐡(𝐱) = −𝒍𝒐𝒈𝟐𝒑(𝒙) ，【负号是为了确保信息一定是正数或者是 0，总不能为负数；普遍传统，使用 2 作为对数的底】。 信息量度量的是一个具体事件发生了所带来的信息，而熵则是在结果出来之前对可能产生的信息量的期望——考虑该随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望。 𝐇(𝐱) = −𝒔𝒖𝒎(𝒑(𝒙)𝒍𝒐𝒈𝟐𝒑(𝒙)) 信息熵还可以作为一个系统复杂程度的度量，如果系统越复杂，出现不同情况的种类越多， 那么他的信息熵是比较大的。 如果一个系统越简单，出现情况种类很少（极端情况为 1 种情况，那么对应概率为 1，那么对应的信息熵为 0），此时的信息熵较小。 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"模型 数据结构，树 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"ID3（迭代的二分器） 目标：挑选信息增益最大的属性，优先选择。 信息增益 总的信息熵-其中某个特征值的信息熵就是信息增益。 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:2:3","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"C4.5（ID3的后继） ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:2:4","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"CART（与ID3大约同时独立地发明） ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:2:5","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"二分类（LR） ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:3:0","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"逻辑回归 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:4:0","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"模型 权重 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:4:1","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"深度学习 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:5:0","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"模型 隐向量 ","date":"2020-07-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/:5:1","tags":null,"title":"大数据架构笔记-7-分类算法","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-7-%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"1. Ansible 参考Ansible中文权威指南 参考拉勾教育 Ansible 是基于 Python 语言开发的，只需要在一台普通的服务器上运行即可，不需要在客户端服务器上安装客户端。 Ansible 是基于 SSH 远程管理，而 Linux 服务器基本都开启了 SSH 服务，所以 Ansible 不需要为配置工作添加额外的支持。 ","date":"2020-07-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:0","tags":["运维"],"title":"自动化运维管理工具","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"1.1. 配置(/etc/ansible) 1.1.1. hosts文件 定义主机列表 // 未分组的机器保留在顶部 [webservers] // 组名 ixdba1.net // 可以使用域名、主机名、IP（一般用IP） ixdba2.net // 其后还可以用空格跟变量 192.168.1.2 ansible_ssh_user=breeze ansible_ssh_pass='123456' [dbservers] db.ixdba1.net db.ixdba2.net www[01:50].ixdba.net // 可以使用数字范围 db[a:f].ixdba.ent // 可以使用字母范围 变量 ansible_ssh_host 被管理主机的真实IP ansible_ssh_port 被管理主机的端口 ansible_ssh_user 被管理主机的用户名 ansible_ssh_pass 被管理主机的密码 ansible_ssh_private_key_file 密钥文件路径 ansible_sudo_pass 使用sudo连接时的密码 ansible_sudo_exec 指定sudo命令的路径 ansible_shell_type shell的类型，默认sh ansible_connection ssh连接的类型 ansible_[python/perl/ruby]_interpreter 解释器的路径 1.1.2. ansible.cfg 默认配置，保持默认即可。 一般将host_key_checking设置为false，关闭yes/no的确认。 ","date":"2020-07-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:1","tags":["运维"],"title":"自动化运维管理工具","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"1.2. 执行模式 管理机是安装 Ansible 的机器，远程主机是 Ansible 批量操作的对象，可以是一个或一组主机. 1.2.1. 命令行模式（ad-hoc） 一般用于测试、临时应用等场景。 常用参数 ansible 主机或组(在 /etc/ansible/hosts 里进行指定) -m 模块名(默认是command模块) -a '模块参数（要在远程机器上执 行的命令）' ansible参数 1.2.2. playbook（多个想要执行的任务[上下关联]放到一个 playbook 中） 主用用于正式环境，通过编写 playbook 文件，可实现固定的、批量的对系统或服务进行配置以及维护工作。 1.2.2.1. 文件格式 由 YMAL 语言编写。通过 ansible-playbook 命令进行解析。 文件的第一行应该以“—”（三个连字符）开始，表明 YMAL 文件的开始； 在同一行中，# 之后的内容表示注释，类似于 shell 、Python 和 Ruby； YMAL 中的列表元素以“-”开头，然后紧跟着一个空格，后面为元素内容； 同一个列表中的元素应该保持相同的缩进，否则会被当作错误处理； play 中的 hosts、variables、roles、tasks 等对象的表示方法都是键值中间以“:”分隔表示，“:”后面还要增加一个空格。 1.2.2.2. 文件组成 playbook 是由一个或多个“play”组成的列表。 playbooks 主要有以下四部分构成，分别如下： Target 部分，定义将要执行 playbook 的远程主机组； Variable 部分，定义 playbook 运行时需要使用的变量； Task 部分，定义将要在远程主机上执行的任务列表； Handler 部分，定义 task 执行完成以后需要调用的任务。 示例 - name: create user // 功能概述 hosts: [ip] // 指定主机 remote_user: root // 指定登陆远程主机的用户 gather_facts: false vars: user1: testuser // 定义了一个变量 tasks: // 指定了一个任务 - name: start createuser // 人物描述 user: name=\"{{user1}}\" // 模块： 模块参数 - hosts: hadoophosts remote_user: root tasks: - name: create hadoop user user: name=hadoop state=present - name: create hadoop directory and chmod/chown file: path=/opt/hadoop state=directory mode=0755 owner=hadoop group=hadoop - name: synchronize hadoop program synchronize: src=/data/hadoop/ dest=/opt/hadoop - name: Setting environment variables shell: echo \"export JAVA_HOME=/usr/jdk\" \u003e\u003e /etc/profile - hosts: 172.16.213.231 remote_user: root tasks: - name: modify selinux // 关闭远程主机的SELINUX replace: path=/etc/selinux/config regexp=\"enforcing\" replace=disabled backup=yes - hosts: 172.16.213.231 remote_user: root tasks: - lineinfile: dest=/etc/profile insertafter='ulimit(.*)' line=\"ulimit -c unlimited\" // 在 /etc/profile 文件中找到以 ulimit 开头的行，并在后面添加一行内容“ulimit -c unlimited” - lineinfile: dest=/etc/profile line=\"export JAVA_HOME=/usr/jdk\" 在 /etc/profile 文件的最后添加一个 JAVA_HOME 路径； - lineinfile: dest=/etc/selinux/config regexp='SELINUX=(.*)' line='SELINUX=disabled' 修改 /etc/selinux/config 文件中以“SELINUX=”开头的行，将其替换为“SELINUX=disabled”，其实就是关闭 selinux - lineinfile: dest=/etc/resolv.conf regexp='search(.*)' state=absent // /etc/resolv.conf 文件找查找以 search 开头的行，然后将其删除掉。 - hosts: 172.16.213.231 remote_user: root tasks: - name: ps command shell: hostname register: host_result - debug: var=host_result - debug: var=host_result.stdout - debug: 'msg=\"output: {{host_result.stdout}}\"' - set_fact: var1=\"{{host_result.stdout}}\" - set_fact: var2=\"This is a string\" - debug: msg=\"{{var1}} {{var2}}\" - hosts: 172.16.213.231 remote_user: root gather_facts: true tasks: - name: connection shell: echo \"connection . {{inventory_hostname}} $(hostname).\" \u003e\u003e /tmp/local.log connection: local - name: delegate_to shell: echo \"delegate_to . {{inventory_hostname}} $(hostname).\" \u003e\u003e /tmp/local.log delegate_to: localhost - name: local_action local_action: shell echo \"local_action. {{inventory_hostname}} $(hostname)\" \u003e\u003e /tmp/local.log 1.2.2.2.1. Target(Hosts 和 Users) hosts：用于指定要执行任务的远程主机. remote_user：用于指定在远程主机上执行任务的用户. 1.2.2.2.2. Task 各任务按次序逐个在 hosts 中指定所有远程主机上的执行，即在所有远程主机上完成第一个任务后再开始第二个。 在运行自上而下某 playbook 时，如果中途发生错误，则所有已执行任务都将回滚，因此在更正 playbook 后需要重新执行一次。 1.2.2.2.3. Handler handlers 和“notify”配合使用. 1.2.2.2.4. tags Ansible 具有幂等性，因此会自动跳过没有变化的部分；但是当一个 playbook 任务比较多时，一个个的判断每个部分是否发生了变化，也需要很长时间。因此，如果确定某些部分没有发生变化，就可以通过 tags 跳过这些代码片断。 1.2.2.3. playbook模块 1.2.2.3.1. unarchive 模块 实现解压缩，也就是将压缩文件解压分发到远程不同节点上。 src，源文件路径，这个源文件在管理机上； dest，指定远程主机的文件路径； mode，设置远程主机上文件权限。 1.2.2.3.2. lineinfile、replace 模块 替换模块为 replace 和 lineinfile。 replace 模块可以根据指定的正则表达式替换远程主机下某个文件中的内容 path regexp replace backup lineinfile，此模块也可以实现 replace 的功能，但 lineinfile 功能更加强大 1.2.2.3.3. register、set_fact、debug 模块 使用 register 选项，可以将当前 task 的输出结果赋值给一个变量. debug 模块，此模块用于在调试中输出信息。 msg 可以输出自定义信息，并且变量需要双大括号包含起来； var 参数只能输出变量，并且不需要双大括号。 set_fact 和 register 的功能很类似，它也可以将 task 输出赋值给变量。set_fact 更像 shell 中变量的赋值方式，可以将某个变量的值赋值给另一个变量，也可以将字符串赋值给变量。 1.2.2.3.4. delegate_to、connection 和 local_action 模块(管理机本地执行) 在管理机本机上执行一些操作，该如何实现呢？其实现的方法有很多，可以通过 delegate_to（任务委派","date":"2020-07-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:2","tags":["运维"],"title":"自动化运维管理工具","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"1.3. 大数据运维实战 1.3.1. hosts 1.3.2. ssh 1.3.3. jdk ","date":"2020-07-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:3","tags":["运维"],"title":"自动化运维管理工具","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"2. Puppet ","date":"2020-07-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:0","tags":["运维"],"title":"自动化运维管理工具","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"3. Saltstack ","date":"2020-07-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:0","tags":["运维"],"title":"自动化运维管理工具","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"概述 推荐系统即检索系统。(召回率、准确率) 根据用户的输入从结果数据库中读取数据。 另外有算法系统根据历史数据，生成推荐的结果数据。 基于内容的推荐算法(Content Base) ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:0:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"步骤 根据Item的数据信息（元数据等）生成关键词的倒排序列（库）（特征建立和建模）。 根据用户输入分词生成关键词B。 根据关键词B查倒排序列库，找到Item。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:1:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"优点 提升推荐结果的相关性。 结果可解释（容易被用户感知）。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:2:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"缺点 无个性化。 依赖于对Item的深度分析。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:3:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"优化 在步骤2中，根据用户的行为数据分析，生成用户的兴趣模型（关键字）。 这样具有了个性化。 但是依然推荐精度低，如果用户行为稀疏导致覆盖率低。 基于协同的推荐算法(Collaboration Filtering) ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:4:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"优点 充分利用群体智慧。 推荐精度高于CB。 利于挖掘隐含的相关性。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:5:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"缺点 推荐结果解释性差。 对时效性强的item不适用。 新用户冷启动问题。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:6:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"步骤 首先有一个UI矩阵（user-item的矩阵）（user-item的score（根据用户行为分析得到分数））（一般是稀疏矩阵）。 第二步，见下边。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:7:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"User Based CF 根据UI矩阵，生成UU矩阵（UU相似度，余弦相似度）。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:7:1","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"Item Based CF 根据UI矩阵，生成II矩阵（II相似度，余弦相似度）。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:7:2","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"对比 【性能】UB适合用户较少的场合、IB适合Item较少的场合。 【领域】UB适合时效性强，用户个性化兴趣不太明显的领域；IB适合长尾物品丰富，用户个性化需求强烈的领域。 【实时性】UB用户有新行为，不一定造成推荐结果立即变化；IB用户有新行为，一定会导致推荐结果变化。 【冷启动】新用户和新物品。 【可解释】UB很难解释；IB根据用户历史行为可解释。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:7:3","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"代码实现 倒排式 map阶段获得\u003cleft,right,leftscore,rightscore\u003e. reduce阶段，将map过来的数据，扫一遍求得所有item的相似度（每一条求积，相同的\u003cleft,right\u003e求和即可）。 可以扩展成关键字对item的相似度、用户与用户的相似度，物品与物品的相似度。 分块式 对冷启动的处理 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:7:4","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"用户冷启动 热门排行榜。有行为之后，再个性化推荐。 注册信息，提供粗粒度的个性化。 导入用户社交信息，基于用户推荐。 注册时，收集感兴趣的信息。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:8:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"物品冷启动 基于内容推荐。 必须第一时间展现给用户（询问）。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:9:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"系统冷启动 引入专家知识（人工标记等），通过一定高效的方式迅速建立起物品的相关性矩阵。 ","date":"2020-07-20","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/:10:0","tags":null,"title":"大数据架构笔记-6-推荐系统","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-6-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"CAP 分布式系统的核心是可扩展性，通过对服务、存储的扩展，来提高系统的处理能力，通过对多台服务器协同工作，来完成单台服务器无法处理的任务，尤其是高并发或者大数据量的任务。 除了对可扩展性的需求，分布式系统还有不出现单点故障、服务或者存储无状态等特点。 CAP 理论可以表述为，一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）这三项中的两项。 在分布式系统中，由于系统的各层拆分，P 是确定的，CAP 的应用模型就是 CP 架构和 AP 架构。分布式系统所关注的，就是在 Partition Tolerance 的前提下，如何实现更好的 A，和更稳定的 C。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:1:0","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"应用 不要把精力浪费在如何设计能满足三者的完美分布式系统上，而要合理进行取舍。 不同业务对于一致性的要求是不同的。 CAP 理论中是忽略网络延迟的。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:1:1","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"AP和CP的取舍 如何在保持相对一致性的前提下，提高系统的可用性。 ZooKeeper 是 CP（CP指的是写数据之后，要花时间去同步数据，使各处的数据一致，期间不可用,强一致，低可用）。 很多分布式系统设计时的选择是AP，如BASE。 Eureka 是 Spring Cloud 微服务技术栈中的服务发现组件，是AP架构。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:1:2","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"BASE 在工程实践中，基于 CAP 定理逐步演化，就提出了 Base 理论（比如 NoSQL 系统、微服务架构）。 Base 是三个短语的简写，即基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:2:0","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"基本可用 强调了分布式系统在出现不可预知故障的时候，允许损失部分可用性，相比正常的系统，可能是响应时间延长，或者是服务被降级（主要的服务正常）。 秒杀中的限流、降级. ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:2:1","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"软状态 软状态可以对应 ACID 事务中的原子性（硬状态）。 允许系统中的数据存在中间状态（比如支付中…），允许系统在多个不同节点的数据副本存在数据延时。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:2:2","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"最终一致性 数据必须在一个时间期限之后达到各个节点的一致性。 重试、补偿等方式. ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:2:3","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"ACID ACID 是一种强一致性模型，强调原子性、一致性、隔离性和持久性，主要用于在数据库实现中。 Base 理论面向的是高可用、可扩展的分布式系统，ACID 适合传统金融等业务，在实际场景中，不同业务对数据的一致性要求不一样，ACID 和 Base 理论往往会结合使用。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:3:0","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"全局时钟和逻辑时钟 多节点的时间同步问题：不同机器上的物理时钟难以同步，导致无法区分在分布式系统中多个节点的事件时序。 问题的关键点在于节点间的交互要在事件的发生顺序上达成一致，而不是对于时间达成一致。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:4:0","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"数据一致性模型(外部一致性) 数据一致性模型可以分为强一致性和弱一致性，除此以外，所有其他的一致性都是弱一致性的特殊情况。 在互联网领域的绝大多数场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:5:0","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"强一致性 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:5:1","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"弱一致性 不一致性窗口。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:5:2","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"最终一致性 最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 因果一致性 因果一致性要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。例如评论回复。 会话一致性 约定了系统能保证在同一个有效的会话中实现“读己之所写”的一致性，就是在你的一次访问中，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 分布式的 Session 一致性问题。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:5:3","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"Paxos 开源分布式锁组件 Google Chubby 的作者 Mike Burrows 说过，这个世界上只有一种一致性算法，那就是 Paxos 算法，其他的算法都是残次品。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:6:0","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"Quorum 机制 在各种一致性算法中都可以看到Quorum 机制的身影，主要数学思想来源于抽屉原理。 用一句话解释那就是，在 N 个副本中，一次更新成功的如果有 W 个，那么我在读取数据时是要从大于 N－W 个副本中读取，这样就能至少读到一个更新的数据了。 和 Quorum 机制对应的是 WARO，也就是Write All Read one，是一种简单的副本控制协议，当 Client 请求向某副本写数据时（更新数据），只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。 ","date":"2020-07-15","objectID":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/:6:1","tags":["分布式"],"title":"分布式-01-基础","uri":"/post/%E5%88%86%E5%B8%83%E5%BC%8F-01-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"TF-IDF 阮大神的TF-IDF与余弦相似系列文章。 优点是简单快速，结果比较符合实际情况。缺点是，单纯以\"词频\"衡量一个词的重要性，不够全面，有时重要的词可能出现次数并不多。而且，这种算法无法体现词的位置信息，出现位置靠前的词与出现位置靠后的词，都被视为重要性相同。 为后续的（bm25、word2vec，中文分词）做铺垫。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:1:0","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"术语 词频（Term Frequency，缩写为TF）。如果某个词很重要，它应该在文章中多次出现。 停用词（stop words）。对找到结果毫无帮助、必须过滤掉的词。的 是 在 常见词 少见词 如果某个词比较少见，但是它在文章中多次出现，那么它很可能就反映了这篇文章的特性，正是所需要的关键词。 用统计学语言表达，就是在词频的基础上，要对每个词分配一个\"重要性\"权重。 这个权重叫做逆文档频率（Inverse Document Frequency，缩写为IDF），它的大小与一个词的常见程度成反比。 知道了\"词频”（TF）和\"逆文档频率”（IDF）以后，将这两个值相乘，就得到了一个词的TF-IDF值。某个词对文章的重要性越高，它的TF-IDF值就越大。所以，排在最前面的几个词，就是这篇文章的关键词。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:1:1","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"算法 计算TF 计算IDF 需要一个语料库，计算IDF。 计算TFIDF TFxIDF。 TF-IDF与一个词在文档中的出现次数成正比，与该词在整个语言中的出现次数成反比。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:1:2","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"使用 自动提取关键词。 搜索每个文档，都可以分别计算一组搜索词（“中国”、“蜜蜂”、“养殖”）的TF-IDF，将它们相加，就可以得到整个文档的TF-IDF。这个值最高的文档就是与搜索词最相关的文档。 自动摘要：句子的信息量用\"关键词\"来衡量。如果包含的关键词越多，就说明这个句子越重要。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:1:3","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"相似度 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:2:0","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"文本相似（可能语义不相似） 基本思路是：如果这两句话的用词越相似，它们的内容就应该越相似。 LCS最大公共子序列。 利用中文分词。 余弦相似性（cosine similiarity） 通过两个向量夹角的大小，来判断向量的相似程度。夹角越小，就代表越相似。 余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫\"余弦相似性”。 算法（word2Vec） 第一步：分词（找出关键词） 第二步：列出所有的词（注意顺序）（去重） 第三步：计算词频 第四步：写出词频向量（与第二步的顺序一致） 第五步：计算词频向量的相似度 应用 找出相似文章。 （1）使用TF-IDF算法，找出两篇文章的关键词； （2）每篇文章各取出若干个关键词（比如20个），合并成一个集合，计算每篇文章对于这个集合中的词的词频（为了避免文章长度的差异，可以使用相对词频）； （3）生成两篇文章各自的词频向量； （4）计算两个向量的余弦相似度，值越大就表示越相似。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:2:1","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"语义相似（可能文本不相似）需要依靠用户行为 基于共现的行为（推荐-协同过滤）。 基于共现的窗口（word2vec词嵌入模型）。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:2:2","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"分词 上述说明，关键是分词。分词的好坏，直接关系后续的算法。 不存在完美的分词方法。看业务。 搜索引擎：通过搜索找到更多内容，中文分词粒度细。 推荐系统：为让用户更好地理解内容，中文分词粒度粗。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:3:0","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"基础理论 分词表达方案（计算机表达方式） 首先，一个句子中每个字都有一个index。 bit位表示。 大数据/架构/笔记 1001010 序列表示。 大数据/架构/笔记 {0,3,5} jieba表示。 大数据/架构/笔记 BMEBEBE （S：single B：begin M：middle E：End） 常见分词方法 参考浅谈分词算法 分词中涉及到三个基本问题：分词规范（即所谓Golden Data，大家所有的模型都在统一的数据集上进行训练和评测，这样比较才会具有可参考性。不同的业务场景有差异）、歧义切分和未登录词的识别。 歧义切分梁南元最早对歧义字段进行了两种基本的定义：【交集型切分歧义】：汉字串AJB称作交集型切分歧义，如果满足AJ、JB同时为词（A、J、B分别为汉字串）。此时汉字串J称作交集串。如，大学生（大学/学生）、研究生物（研究生/生物）、结合成（结合/合成）.【组合型切分歧义】：汉字串AB称作多义组合型切分歧义，如果满足A、B、AB同时为词。如，起身（他|站|起|身|来/明天|起身|去北京）、学生会（我在|学生会|帮忙/我的| 想要正确的做出切分判断，一定要结合上下文语境，甚至韵律、语气、重音、停顿等。 未登录词，一种是指已有的词表中没有收录的词，另一种是指训练语料中未曾出现过的词。而后一种含义也可以被称作集外词，OOV（out of vocabulary），即训练集以外的词。通常情况下未登录词和OOV是一回事，我们这里不加以区分。 【新出现的普通词汇】，一般对于大规模数据的分词系统，会专门集成一个新词发现模块，用于对新词进行挖掘发现，经过验证后加入到词典当中。【专有名词】，在分词系统中我们有一个专门的模块，命名体识别（NER name entity recognize），用于对人名、地名以及组织机构名等单独进行识别。【专业名词和研究领域名称】，这个在通用分词领域出现的情况比较少，如果出现特殊的新领域，专业，就会随之产生一批新的词汇。【其他专用名词】，包含其他新产生的产品名、电影、书籍等等。 分词模型对于未登录词的处理将是衡量一个系统好坏的重要指标。 基于词典分词（机械分词）通常作为初分手段 基于词典的方法是经典的传统分词方法，这种方式很直观，我们从大规模的训练语料中提取分词词库，并同时将词语的词频统计出来，我们可以通过逆向最大匹配、N-最短路径以及N-Gram模型等分词方法对句子进行切分。 词典是语料库（前向查找语料库和后向查找语料库）。Trie树 最大长度查找（前{正}向查找从前往后、后{反}向查找从后往前） 有时前向查找和后向查找完全不一样。北京大学生活动中心 概率语言模型（最大概率分词）方法 切分词图（表示所有组词（语料库）可能）(有向无环图) DAG表示{0:[0,1,3],1:[1],2:[2,3,5],3:[3],4:[4,5],5:[5],6:[6,7],7:[7]} 表示` 广州本田雅阁汽车` 既然有多种组词可能，哪一种比较好，需要计算概率，选出概率最大的分词方式。 从统计思想的角度看，分词问题的输入是一个字串C=c1,c2……cn 输出是一个词串S=w1,w2,w3…..wm m\u003c=n.对于一个特定的字符串C，会与多个分词方案S对应，分词的任务就是在这些S中找出一个切分方案S，实测P(S|C)的值最大。 P(S|C) ∝ P(S)*P(C|S) 用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。P(C|S)恒等1. 问题变成求P(S)的概率即P(W1, W2, W3, W4 ..)。 根据联合概率的公式展开：P(W1, W2, W3, W4 ..) = P(W1) * P(W2|W1) * P(W3|W2, W1) * P(W4|W1,W2,W3) * .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) * P(W2|W1) * P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。 我们最多只看到前两个词，有研究表明，大于4个以上的模型并不会取得更好的效果（显然n越大，我们需要找寻n元组的词出现的频率就越低，会很直接的导致数据稀疏问题），通常情况下我们使用的是2-gram模型居多。 贝叶斯 数学之美番外篇：平凡而又神奇的贝叶斯方法 P(B|A) = P(AB) / P(A) 其实这个就等于：P(B|A) * P(A) = P(AB) 朴素贝叶斯 我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) * P(d2|h+) * P(d3|h+) * .. 。这个就是所谓的条件独立假设，也正是朴素贝叶斯方法的朴素之处。 有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。 层级贝叶斯模型 隐马可夫模型（HMM）就是一个简单的层级贝叶斯模型。 基于字分词 不同于基于词典的分词方法，需要依赖于一个事先编制好的词典，通过查词典的方式作出最后的切分决策；基于字的分词方法将分词过程看作是字的分类问题，其认为每个字在构造一个特定词语时都占据着一个确定的构词位置（词位）。 在实际生产环境中，我们往往会融合多种方法来提高准确率和召回率，比如在github中经常被提及的结巴分词就融合了n-gram词典分词和HMM字分词，大家具体用到的时候要根据实际环境进行选择和搭配，必要的时候要对模型进行重train和调整。 马尔科夫模型是对一个序列数据建模，但有时需要对两个序列建模（机器翻译、语音识别、词性标注、拼音纠错等）。 hmm隐马模型 状态值集合Q={q1,q2,…,qN}，其中N为可能的状态数； 观测值集合V={v1,v2,…,vM}，其中M为可能的观测数； 转移概率矩阵A=[aij]，其中aij表示从状态i转移到状态j的概率； 发射概率矩阵（也称之为观测概率矩阵）B=[bj(k)]，其中bj(k)表示在状态j的条件下生成观测vk的概率； 初始状态分布π（状态的初始概率）. ####### 应用（3类问题） 评估问题：计算给定观测序列出现的概率。Forward-backward算法 解码问题： 6. 将状态值集合Q置为{B,E,M,S}，分别表示词的开始、结束、中间（begin、end、middle）及字符独立成词（single）；观测序列即为中文句子。比如，“今天天气不错”通过HMM求解得到状态序列“B E B E B E”，则分词结果为“今天/天气/不错”。 7. 先将句子分成单个字浅谈分词算法（3）基于字的分词方法（HMM） 8. 给定观测序列，计算状态序列。 9. 用到了viterbi算法。 学习问题：模型参数未知，是观测序列的概率最大。极大似然估计的方法估计参数。BaumWelch EM算法 CRF LSTM ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:3:1","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"jieba原理解析 简介 三种分词模式：精确模式（适合文本分析）、全模式（可以成词的词语都扫描出来）、搜索引擎模式（对长词再次切分）。 支持繁体分词。 支持自定义词典。 基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的DAG图。 采用了动态规划查找最大概率路径，找出基于词频的最大切分组合。 对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法。 分词步骤 【准备工作】加载登录词典、建立Trie树分词模型（之后弃用，Trie树嵌套dict，占内存。改成前缀词典）。 【一】得到句子，先进行清洗，如果包含特殊字符，将其分离。 【二】建立分词的DAG词图（如{0:[0,1,3]}）。 【三】计算全局概率Route（根据上方的DAG图），从右往左反向计算最大概率（概率对数相加，防止相乘下溢），得到基于前缀词典的词频最大切分组合。 【四】Token识别，讲中文和英文数字分开处理。 【五】对于未登录词，加载隐马HMM概率图模型。 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:3:2","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"分布式批量分词 ","date":"2020-06-30","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/:3:3","tags":null,"title":"大数据架构笔记-4-NLP-中文分词","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-4-nlp-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"},{"categories":null,"content":"参考HDP Installation Documentation 参考amarmesic/ambari-hdp-docker ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:0:0","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"概述 版本依赖.https://supportmatrix.hortonworks.com。 ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:1:0","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"Apache Ambari Installation ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:2:0","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"准备 Set Up Password-less SSH Set Up Service User Accounts Enable NTP on the Cluster and on the Browser Host 启用NTP服务。 Check DNS and NSCD 使用docker-compose部署的时候，使用hostname参数。 Configuring iptables 关闭防火墙。 Disable SELinux and PackageKit and check the umask Value 关闭SELinux。 Download and set up database connectors 像Druid, Hive, Ranger, Oozie和Superset这样的组件需要一个可操作的数据库。 在安装过程中，您可以选择使用现有的数据库，或者让Ambari安装一个新的实例(对于Hive)。 为了让Ambari连接到您选择的数据库，您必须在安装组件之前从数据库供应商直接下载必要的数据库驱动程序和连接器。 为了更好地为安装或升级做准备，请在设置环境时设置数据库连接器。 Configuring a Database Instance for Ranger MySQL、Oracle、PostgreSQL或Amazon RDS数据库实例必须运行并可供Ranger使用。Ranger安装将创建两个新用户(默认名称:rangeradmin和rangerlogger)和两个新数据库(默认名称:Ranger和Ranger audit)。 可以创建好mysql数据库，在Ambari安装向导过程中，指定连接数据。 Install Databases for HDF services 在安装Schema Registry,、SAM、Druid和Superset时，需要一个关系数据存储来存储元数据。 您可以使用MySQL、Postgres、Oracle或MariaDB。 如果使用Superset在现有的HDP集群上安装，可以跳过安装说明，因为MySQL是与Druid一起安装的。在这种情况下，配置数据库。 ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:2:1","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"安装Ambri 从2.7.5开始，使用源安装，需要使用用户和密码下载源文件。 ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:2:2","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"安装、配置和部署一个集群 配置过程中需要指定现有的数据库。 启动服务 ambari-server start ambari-server status ambari-server stop 如果您计划为Hive或Oozie使用一个现有的数据库实例，那么您必须在安装Hadoop集群之前准备好使用一个现有的数据库。 在启动时，会对数据库一致性进行检查。如果出现任何问题，启动会中止，并报告DB configs consistency check failed。 登入 启动安装向导 选择版本 Install Options Confirm Hosts Choose Services Assign Masters Assign Slaves and Clients Customize Services Review Install, Start and Test Complete ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:2:3","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"遇到问题 ","date":"2020-06-24","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/:3:0","tags":null,"title":"大数据架构笔记-1-集群安装-HDP-AMBARI","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-hdp-ambari/"},{"categories":null,"content":"本文以3.2.1版本为主 参考大数据运维实战 参考尚硅谷大数据资料 选择发行版 对于初学入门的话，建议选择 Apache Hadoop 版本最好，因为它的社区活跃、文档、资料详实。 企业环境：在国内大型互联网企业中，使用较多的是 CDH【收费】 或 HDP 发行版本，个人推荐采用 HDP 发行版本，原因是部署简单、性能稳定。 版本兼容选择 组件 old new Hadoop 2.7.2 3.1.3 Zookeeper 3.4.10 3.5.7 MySQL 5.6.24 5.7.16 Hive 1.2.1 3.1.2 Flume 1.7.0 1.9.0 Kafka 0.11-0.2 2.11-2.4.1 Kafka Eagle 1.3.7 1.4.5 Azkaban 2.5.0 3.84.4 Spark 2.1.1 3.0.0 Hbase 1.3.1 2.0.5 Phoenix 4.14.1 5.0.0 Sqoop 1.4.6 1.4.6 Presto 0.189 0.189 Kylin 2.5.1 3.0.1 Atlas 0.8.4 2.0.0 Ranger 2.0.0 2.0.0 Solr 5.2.1 7.7.0 hadoop搭建 参考官方文档开始集群 官方文档支持5种搭建方式,参考hadoop 生态圈介绍 1. 单机模式：非分布式。默认模式。作为一个JAVA进程，调试有用。 2. 伪分布式操作模式：单节点。伪分布式。作为分开的JAVA进程。通常使用这种模式进行开发和调试工作。 3. 全分布式部署。 4. HA Cluster，即高可用集群模式 5. HA + Federation Cluster，即高可用联邦集群模式 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:0:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"伪分布式部署 伪分布式安装 Hadoop 只需要一台机器，硬件配置最低为 4 核 CPU、8G 内存即可 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:1:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"全分布式集群搭建 参考官方文档从若干节点到千级节点。 官方文档并不涉及安全和高可用。 将硬件划分为功能。 通常，集群中的一台机器被指定为NameNode(hadoop文件系统的管家)，而另一台机器被指定为ResourceManager(yarn的管家，主要管理任务的执行，例如MapReduce任务)。这些是主节点。 其他服务(如Web App Proxy Server和MapReduce Job History Server)通常在专用硬件或共享基础设施上运行，这取决于负载。 集群中的其他机器同时充当DataNode和NodeManager。这些是workers(从节点)。 视业务、资金等情况而定，因为该模式日后也可以安全升级成高可用模式。 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:2:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"安装java Linux安装JDK完整步骤 配置环境变量 JAVA_HOME CLASSPATH PATH ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:2:1","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"安装hadoop 下载获取二进制压缩包。 解压到指定目录并新建tmp目录,设置环境变量（PATH）即可。 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:2:2","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"hadoop集群配置（非安全） Hadoop的Java配置由两种类型的重要配置文件驱动 只读默认配置 - core-default.xml, hdfs-default.xml, yarn-default.xml and mapred-default.xml. 特定站点的配置 - etc/hadoop/core-site.xml, etc/hadoop/hdfs-site.xml, etc/hadoop/yarn-site.xml and etc/hadoop/mapred-site.xml 另外，您可以通过在etc/hadoop/hadoop-env.sh和etc/hadoop/ yarn-env.sh中设置站点特定的值来控制在发行版的bin目录中找到的Hadoop脚本。 HDFS守护进程是NameNode、SecondaryNameNode（主要做文件的合并工作）和DataNode。YARN守护进程是ResourceManager、NodeManager和WebAppProxy。如果要使用MapReduce，那么MapReduceJobHistoryServer也将运行。对于大型安装，它们通常运行在不同的主机上。 特定站点的配置 环境变量 使用etc/hadoop/hadoop-env.sh以及可选的etc/hadoop/mapred-env.sh和etc/hadoop/yarn-env.sh脚本对Hadoop守护进程的处理环境进行特定于站点的自定义。 至少配置一下JAVA_HOME.（还可配一下user） 可以使用下表中显示的配置选项来配置各个守护程序: 守护进程 环境变量 描述 NameNode HDFS_NAMENODE_OPTS 例如export HDFS_NAMENODE_OPTS=\"-XX:+UseParallelGC -Xmx4g\" NameNode HDFS_NAMENODE_USER 默认为hdfs，可以设置为root DataNode HDFS_DATANODE_OPTS DataNode HDFS_DATANODE_USER 默认为hdfs，可以设置为root Secondary NameNode HDFS_SECONDARYNAMENODE_OPTS Secondary NameNode HDFS_SECONDARYNAMENODE_USER 默认为hdfs，可以设置为root ResourceManager YARN_RESOURCEMANAGER_OPTS NodeManager YARN_NODEMANAGER_OPTS WebAppProxy YARN_PROXYSERVER_OPTS Map Reduce Job History Server MAPRED_HISTORYSERVER_OPTS 其他有用的参数 HADOOP_PID_DIR - 目录 the daemons’ process id files are stored. HADOOP_LOG_DIR - 目录 the daemons’ log files are stored. Log files are automatically created if they don’t exist. HADOOP_HEAPSIZE_MAX - The maximum amount of memory to use for the Java heapsize. Units supported by the JVM are also supported here. If no unit is present, it will be assumed the number is in megabytes. By default, Hadoop will let the JVM determine how much to use. This value can be overriden on a per-daemon basis using the appropriate _OPTS variable listed above. For example, setting HADOOP_HEAPSIZE_MAX=1g and HADOOP_NAMENODE_OPTS=\"-Xmx5g\" will configure the NameNode with 5GB heap. 在大多数情况下，您应该指定HADOOP PID DIR和HADOOP LOG DIR目录，以便它们只能由将要运行HADOOP守护进程的用户写入。否则，可能会出现符号链接攻击。 在/etc/profile.d配置HADOOP_HOME HADOOP_HOME=/path/to/hadoop export HADOOP_HOME 配置Hadoop守护进程 etc/hadoop/core-site.xml（） 参数 值 描述 重要程度 fs.defaultFS 访问HDFS文件系统的URI,默认端口是8020 hdfs://host:port/ 主节点 1 io.file.buffer.size 131072 Size of read/write buffer used in SequenceFiles. hadoop.tmp.dir 默认为/tmp/hadoop-${user.name},最好不要定义在/tmp中，默认namenode和datanode会用到 hadoop.http.staticuser.user 静态用户，默认dr.who The user name to filter as, on static web filters while rendering content. An example use is the HDFS web UI (user to be used for browsing files). io.compression.codecs 逗号分隔的压缩编解码器类列表，可用于压缩/解压缩 etc/hadoop/hdfs-site.xml NameNode配置 参数 值 描述 dfs.namenode.name.dir 本地文件系统路径用于存放（元数据信息） namespace and transactions logs persistently. 如果这是一个以逗号分隔的目录列表，那么为了冗余，名称表将复制到所有目录中。默认为 file://${hadoop.tmp.dir}/dfs/name，一般都改一下 dfs.hosts / dfs.hosts.exclude List of permitted/excluded DataNodes. If necessary, use these files to control the list of allowable datanodes. dfs.blocksize 268435456 HDFS blocksize of 256MB for large file-systems. dfs.namenode.handler.count 100 More NameNode server threads to handle RPCs from large number of DataNodes. dfs.replication 默认为3 数据副本数 dfs.namenode.secondary.http-address 默认0.0.0.0:9868 The secondary namenode http server address and port. DataNode配置 参数 值 描述 dfs.datanode.data.dir Comma separated list of paths on the local filesystem of a DataNode 用于存放数据的blocks. 如果这是一个以逗号分隔的目录列表，那么为了冗余，数据将复制到所有目录中。默认为 file://${hadoop.tmp.dir}/dfs/data，一般都改一下 etc/hadoop/yarn-site.xml ResourceManager和NodeManager配置。 Parameter Value Notes yarn.acl.enable true / false Enable ACLs? Defaults to false. yarn.admin.acl Admin ACL ACL to set admins on the cluster. ACLs are of for comma-separated-usersspacecomma-separated-groups. Defaults to special value of * which means anyone. Special value of just space means no one has access. yarn.log-aggregation-enable false Configuration to enable or disable log aggregation ResourceManager单独配置 Parameter Value Notes yarn.resourcemanager.address ResourceManager host:port for clients to submit jobs. host:port If set, overrid","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:2:3","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"HA Cluster，即高可用集群模式 一般来说，分为NN的高可用和RM的高可用。在完全分布式的基础上，增加备用NN和RM节点。 NN高可用，也就是集群里面会部署两台NN（最多也只能两台），以形成主备NN节点，达到高可用的目的。RM高可用与NN高可用类似，也是在集群里部署备用RM节点。 主备模式。当Active的NN/RM出现问题无法工作时，Standby的那台则立即无缝切入，继续保障集群正常运转。 这种模式是很多企业都使用的，但是依然有缺陷。性能瓶颈依然存在——仅有一台NN/RM，由于无法横向扩展，其很可能会超负载运行。 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:3:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"HA + Federation Cluster，即高可用联邦集群模式 解决了单纯HA模式的性能瓶颈。 整个HA集群再划分为两个以上的集群，不同的集群之间通过Federation进行连接。 不同集群间可以共享数据节点，也可以不共享，可以互相访问和操作数据，也可以不。集群之间的数据相互独立，不能不经过NN访问DN的数据 这样便做到了HA集群的横向扩展，从而移除了单纯HA模式同时仅有1台NN/RM工作所带来的性能瓶颈。 Federation模式，相当于在多个集群之上又构建了一个集群层次。 从数据访问的角度看，也可以简单的将其理解为一台路由器，而每一个HA集群则是单独的网络，不同网络间通过Federation路由器进行沟通。 此模式是目前hadoop生态中最高的一种模式，适用于规模较大的企业。 作者：mtide_net 链接：https://www.jianshu.com/p/c3a834e45ae3 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:4:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"启动 完成所有必要的配置后，将文件分发到所有机器上的HADOOP CONF DIR目录。这应该是所有机器上的相同目录。 通常，建议HDFS和YARN作为单独的用户运行。在大多数安装中，HDFS进程作为HDFS执行。YARN通常使用YARN帐户。 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:5:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"第一次启动 必须格式化namenode。生成集群元数据，生成fsimage(持久化)。 $HADOOP_HOME/bin/hdfs namenode -format \u003ccluster_name\u003e 启动集群。./start-all.sh ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:5:1","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"查看集群状态 jps查看进程。 ./hadoop fs -ls / ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:6:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"查看端口 进程 端口 功能 namenode 9870 namenode 9000 datanode 9864 datanode 9866 datanode 9867 datanode 40599 resourcemanager 8030 resourcemanager 8031 resourcemanager 8032 resourcemanager 8033 resourcemanager 8088 nodemanager 8040 nodemanager 8042 nodemanager 13562 nodemanager 39547 historyserver 8188 historyserver 10200 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:7:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"hadoop命令 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:8:0","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"hdfs HDFS 上面的文件，只能创建和删除，无法更新一个存在的文件，如果要更新 HDFS 上的文件，需要先删除这个文件，然后提交最新的文件即可。 hdfs namenode -format // 格式化namenode hdfs --daemon start namenode // 启动namenode hadoop fs -ls / //查看 hdfs 根目录数据 hadoop fs -mkdir /logs //在 hdfs 根目录创建一个 logs 目录 hadoop fs -put /data/test.txt /logs // 从本地上传一个文件到 hdfs 的 /logs 目录下 hadoop fs -cat /logs/test.txt // 查看 hdfs 中一个文本文件的内容 hadoop fs -text /logs/db.gz // HDFS 上的压缩文件通过“-text”参数也能直接查看，因为默认情况下 Hadoop 会自动识别常见的压缩格式 hadoop fs -rm -r /logs/test.txt // 删除 hdfs 上一个文件 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:8:1","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":"Mapreduce share/hadoop/mapreduce，找到一个名为 hadoop-mapreduce-examples-3.2.1.jar 的 jar 文件.包含了一个 wordcount 功能，它主要功能是用来统计一系列文本文件中每个单词出现的次数。 hadoop jar /opt/hadoop/current/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar wordcount /demo /output 最后的两个路径都是 HDFS 上的路径，第一个路径是分析读取文件的目录，必须存在；第二个路径是分析任务输出结果的存放路径，必须不存在，分析任务会自动创建这个目录。 part-r-00000，表示输出文件名，常见的名称有 part-m-00000、part-r-00001，其中，带 m 标识的文件是 mapper 输出，带 r 标识的文件是 reduce 输出的，00000 为 job 任务编号，part-r-00000 整个文件为结果输出文件。 默认 mapreduce 的运行环境是 local（本地），要让 mapreduce 在 yarn 上运行，需要做几个参数配置就行了。 ","date":"2020-06-17","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/:8:2","tags":null,"title":"大数据架构笔记-1-hadoop安装配置命令","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-1-%E9%83%A8%E7%BD%B2-apache/"},{"categories":null,"content":" 对战机甲。 ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:0:0","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"C/C++ 基于Mbed，可以使用线上IDE. 接口文档 The micro:bit DAL is built on top of ARM mbed and hence uses yotta as an offline build system. ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:1:0","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"YOTTA Yotta is a module management system for C++ and C designed to make it easier to build better software by re-using code. We built yotta for Mbed OS, but you can use it for projects on other platforms too. yotta教程. Yotta构建两种东西：模块和可执行文件。 ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:1:1","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"API ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:1:2","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"Bluetooth Bluetooth Developer Studio ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:1:3","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"JS(Makecode) Microsoft MakeCode是一个用于创建JavaScript/积木块在线编辑器的框架。 Microsoft MakeCode(基于PXT)是用户编辑器中的名称，而PXT在 GitHub 的源码中使用。 MakeCode可将代码转成用于下载的hex文件（UF2文件格式）。 UF2是一种文件格式，由Microsoft为PXT(也称为Microsoft MakeCode)开发，特别适合通过MSC(海量存储类;又名可移动闪存驱动器)烧写微控制器。 ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:2:0","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"文档 模块都是全局变量，直接调用。 bluetooth.onBluetoothConnected(function () { basic.showLeds(` . # # # . . . . # . . # # # . . # . . . . # # # . `) }) bluetooth.onBluetoothDisconnected(function () { basic.showLeds(` . . # . . . . # . . . . # . . . . # . . . . # . . `) }) bluetooth.startLEDService() basic.showLeds(` . # # # . . # . . . . # # # . . . . # . . # # # . `) basic.forever(function () { }) basic bluetooth 安卓手机的话，只有三星能够正常配对（据说还有小米），因此，你在编写 MicroBit的代码时，务必使用非配对的蓝牙模式。 可以使用makecode编写Ble程序。 LED Service ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:2:1","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"MicroPython MicroPython文档 ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:3:0","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"Bluetooth Microbit的硬件支持BLE。MicroPython中的BLE协议栈要占12kb的RAM，而MicroBit的RAM只有16kB，没有足够的空间。 所以使用radio模块，比BLE简单，但是在教育场景下已够用。 ","date":"2020-05-27","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/:3:1","tags":null,"title":"嵌入式-MicroBit-概述","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-microbit-%E6%A6%82%E8%BF%B0/"},{"categories":null,"content":"展开语法 在函数调用时使用展开语法。 function myFunction(x, y, z) {} var args = [0, 1, 2]; myFunction(...args); 在 new 表达式中应用 var dateFields = [1970, 0, 1]; // 1970年1月1日 var d = new Date(...dateFields); 构造字面量数组时使用展开语法 var parts = [\"shoulders\", \"knees\"]; var lyrics = [\"head\", ...parts, \"and\", \"toes\"]; // [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"] 数组拷贝(执行的都是浅拷贝) var arr = [1, 2, 3]; var arr2 = [...arr]; // like arr.slice() arr2.push(4); 连接多个数组 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; var arr3 = [...arr1, ...arr2]; 构造字面量对象时使用展开语法 var obj1 = { foo: \"bar\", x: 42 }; var obj2 = { foo: \"baz\", y: 13 }; var clonedObj = { ...obj1 }; // 克隆后的对象: { foo: \"bar\", x: 42 } var mergedObj = { ...obj1, ...obj2 }; // 合并后的对象: { foo: \"baz\", x: 42, y: 13 } var obj1 = { foo: \"bar\", x: 42 }; var obj2 = { foo: \"baz\", y: 13 }; const merge = (...objects) =\u003e ({ ...objects }); var mergedObj = merge(obj1, obj2); // Object { 0: { foo: 'bar', x: 42 }, 1: { foo: 'baz', y: 13 } } var mergedObj = merge({}, obj1, obj2); // Object { 0: {}, 1: { foo: 'bar', x: 42 }, 2: { foo: 'baz', y: 13 } } 只能用于可迭代对象(比如 Set) ","date":"2020-05-07","objectID":"/post/js-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["JS"],"title":"JS-表达式和运算符","uri":"/post/js-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"原则 高可用 高性能 一致性 扩展性 方案 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:0:0","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"一：主备，主库读写，备库冗余 性能一般。建立高效的索引和引入缓存来增加性能。 扩展性差。通过分库分表来扩展。 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:1:0","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"二：双主架构，两个同时提供服务，负载均衡 存在一致性问题。 主键冲突问题。ID统一由分布式ID生成服务来生成。 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:2:0","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"三：主从架构，一主多从，读写分离 主库挂了，影响写。 存在一致性问题。 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:3:0","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"四：双主+主从架构 存在一致性问题。 同步更多。 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:4:0","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"解决一致性问题 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:5:0","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"主库和从库 直接忽略。 强制读主。增加读缓存。 选择读主。缓存中增加标记，有标记读主，无标记读从。多了一层缓存读写。 半同步复制。等同步完成，写请求才返回。后果：请求时延增长，吞吐量降低。 数据库中间件。增加中间件成本更高。 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:5:1","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"DB和缓存 延迟淘汰缓存，延迟时间大于同步时间。 ","date":"2020-05-04","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/:5:2","tags":null,"title":"微服务架构笔记-数据库-架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5-%E6%9E%B6%E6%9E%84/"},{"categories":null,"content":"参考ElemeFE/node-interview 参考挑战一轮大厂后的面试总结 (含六个方向) - nodejs 篇 摘自图解Javascript原型链 基础 其他皆对象。 但是Js中并没有类（class）；Js是基于原型（prototype-based）来实现的面向对象（OOP）的编程范式的，但并不是所有的对象都拥有prototype这一属性.在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）. prototype是每个function定义时自带的属性，另外还有length。但是Js中function本身也是对象,直接new function生成的对象（没有prototype）的构造器就是这个[function]. proto（对象的隐式原型,指向其父类的prototype）与prototype（显式原型）. __proto__是每个对象都有的一个属性，而prototype是函数才会有的属性。 __proto__指向的是当前对象的原型对象，而prototype指向的是以当前函数作为构造函数构造出来的对象的原型对象。 实际上Function就是一个用于构造函数类型变量的类，或者说是函数类型实例的构造函数（constructor）；与之相似有的Object或String、Number等，都是Js内置类型实例的构造函数。比较特殊的是Object，它用于生成对象类型，其简写形式为{}. prototype和length是每一个函数类型自带的两个属性，而其它非函数类型并没有（开头的例子已经说明），这一点之所以比较容易被忽略或误解，是因为所有类型的构造函数本身也是函数，所以它们自带了prototype属性 var Person = function(){}; Person.prototype.type = 'Person'; Person.prototype.maxAge = 100; var p = new Person(); console.log(p.maxAge); p.name = 'rainy'; Person.prototype.constructor === Person; //=\u003e true p.__proto__ === Person.prototype; //=\u003e true console.log(p.prototype); //=\u003e undefined erson是一个函数类型的变量，因此自带了prototype属性，prototype属性中的constructor又指向Person本身；通过new关键字生成的Person类的实例p1，通过__proto__属性指向了Person的原型。这里的__proto__只是为了说明实例p1在内部实现的时候与父类之间存在的关联（指向父类的原型），在实际操作过程中实例可以直接通过.获取父类原型中的属性，从而实现了继承的功能。 prototype对象也有__proto__属性，向上追溯一直到null. 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:0:0","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"类型判断 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:1:0","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"typeof 判断类型 6大原始类型object(null)、undefined、string、number、boolean和function typeof undefined; // undefined typeof []; // object typeof '123'; // string typeof new String('123'); // object typeof null; // object *** function f1(){ // new Function(\"console.log('This is function f3!');\"); console.log('This is function f1!'); } typeof(f1); //=\u003e 'function' typeof(String) // function typeof(Number) // function typeof(Function) // function ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:1:1","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"instanceof 判断对象的__proto__（以及__proto__.__proto__…[原型链]）是否包含构造函数的原型(),判断是否是某个类型的实例 const s = new String('123'); s instanceof String; // true s instanceof Object; // true s.__proto__ = Object.prototype; s instanceof String; // false s instanceof Object; // true ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:1:2","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"constructor属性 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:1:3","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"toString方法 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:1:4","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"内置Symbol接口 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:1:5","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"作用域 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:2:0","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"let const 和 var ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 var a = []; for (var i = 0; i \u003c 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 var a = []; for (let i = 0; i \u003c 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 const声明一个只读的常量。一旦声明，常量的值就不能改变。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 ","date":"2020-04-30","objectID":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/:2:1","tags":["NODEJS","JS"],"title":"JS-NODEJS-基础","uri":"/post/js-nodejs-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"基础概念 关系型数据库遵循A（原子性）C（一致性）I（独立性）D（持久性）规则。 MongoDB是一个基于分布式文件存储(基于磁盘的)的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库(nosql)之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB支持的数据结构非常松散。类似json的bson格式。查询语言强大。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:0:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"NoSQL NoSQL用于超大规模数据的存储。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:1:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"分类 key-value：redis 文档型：mongoDb 图数据库：neo4j 列存储数据库，HBASE ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:1:1","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"概念 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 一个mongodb中可以建立多个数据库。 MongoDB的默认数据库为\"db”，该数据库存储在data目录中。 MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中 RDBMS MongoDB 数据库 数据库 表格 集合 行 文档 列 字段 表联合 嵌入文档 主键 主键 (MongoDB 提供了 key 为 _id ) ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:2:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 应用场景 一般用于静态数据的场合，事务性的场合（完整的业务流）不适用。 Mongo 适用于以下场景: a. 网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 b. 缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo 搭建的持久化缓存层可以避免下层的数据源过载。 c. 大尺寸、低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。 d. 高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库，Mongo 的路线图中已经包含对MapReduce 引擎的内置支持。 e. 用于对象及JSON 数据的存储：Mongo 的BSON 数据格式非常适合文档化格式的存储及查询。 MongoDB 的使用也会有一些限制，例如，它不适合于以下几个地方。 a. 高度事务性的系统：例如，银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。 b. 传统的商业智能应用：针对特定问题的BI 数据库会产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。 c. 需要SQL 的问题。复杂的跨文档（表）级联查询。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:3:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"游戏场景 使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:4:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"物流场景 使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:5:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"社交场景 使用 MongoDB 存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:6:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"物联网场景 使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:7:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"视频直播 使用 MongoDB 存储用户信息、礼物信息等。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:8:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"其他 2个及以上yes。 应用特征 Yes / No 应用不需要事务及复杂 join 支持 必须 Yes 新应用，需求会变，数据模型无法确定 想快速迭代开发 ？ 应用需要2000-3000以上的读写QPS（更高也可以） ？ 应用需要TB甚至 PB 级别数据存储 ? 应用发展迅速，需要能快速水平扩展 ? 应用要求存储的数据不丢失 ? 应用需要99.999%高可用 ? 应用需要大量的地理位置查询、文本查询 ？ 使用 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:9:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"启动 MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。 注意：/data/db 是 MongoDB 默认的启动的数据库路径(–dbpath)。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:10:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"前台启动 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:10:1","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"后台启动 --fork ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:10:2","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"使用配置文件启动 --config mongo.conf指定配置文件。 参考MongoDB 通过配置文件启动. ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:10:3","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"停止 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:11:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"查看进程，使用kill命令；不能使用kill -9 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:11:1","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"在客户端进去，使用shutdown命令 \u003e use admin; switched to db admin \u003e db.shutdownServer(); server should be down... 在主节点（primary）上运行shutdown命令时，服务器在关闭之前，会先等待备份节点追赶主节点以保持同步。这将回滚的可能性降至最低，但shutdown操作有失败的可能性。如几秒钟内没有备份节点成功同步，则shutdown操作失败，主节点不会停止运行。 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:11:2","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"日志 在启动mongod的时候，可以指定日志的级别，即（-v、-vv、-vvv、-vvvv、-vvvvv）或者在shell命令行执行命令修改mongodb/bin/mongod --dbpath mongodb/0707 --directoryperdb --fork -vvv 日志级别越大，输出的日志越详细，调至5时，这时mongod会在日志中记录几乎所有的操作，包括每一个请求所处理的内容。 MongoDB默认记录耗时超过100毫秒的查询信息。如果100毫秒不适合需求，可以通过setProfilingLevel命令来改变，下面这条命令表示记录查询时间超过500毫秒的消息 \u003e db.setProfilingLevel(1,500) { \"was\" : 0, \"slowms\" : 100, \"ok\" : 1 } 如果想要日志分割，如按天存放，有两种方法 方法一：每天定时的执行kill -USR1 进程号，这样就可以看到，每执行一次kill -USR1 进程号，那么就会重新生成一个日志文件 方法二：在MongoDB的shell行执行，每执行一次都会产生一个新的日志文件 \u003e db.adminCommand({\"logRotate\":1}) { \"ok\" : 1 } 要使分割日志生效，必须启动的时候使用–logpath，然后可以根据自己的需求，写shell或python脚本，然后crontab做成定时任务 ","date":"2020-04-27","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/:12:0","tags":null,"title":"后端-数据库-MONGODB","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-mongodb/"},{"categories":null,"content":"概念 人与人的关系。 ","date":"2020-03-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/:1:0","tags":null,"title":"产品设计-组织关系管理","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/"},{"categories":null,"content":"抽象 ","date":"2020-03-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/:2:0","tags":null,"title":"产品设计-组织关系管理","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/"},{"categories":null,"content":"单个人 基类 根属性，根方法。 基于基类继承 不同类型，不同属性不同方法不同对象。 每个类型一个数据表。 ","date":"2020-03-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/:2:1","tags":null,"title":"产品设计-组织关系管理","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/"},{"categories":null,"content":"单个人群（人的集合） 基类 根属性，根方法。 成员(属性) 发起者(创建者) 监管者 成员 基于基类继承 不同类型，不同属性不同方法不同对象。 水平 垂直 ","date":"2020-03-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/:2:2","tags":null,"title":"产品设计-组织关系管理","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB/"},{"categories":null,"content":"参考Apache Maven 入门篇 ","date":"2020-03-26","objectID":"/post/java-01-maven/:0:0","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"用来做什么 Maven 是一个项目管理和构建自动化工具。 Maven 使用惯例优于配置的原则 。 它要求在没有定制之前，所有的项目都有如下的结构： 目录 目的 ${basedir} 存放 pom.xml(用于描述项目，配置插件和管理依赖关系。)和所有的子目录 ${basedir}/src/main/java 项目的 java源代码 ${basedir}/src/main/resources 项目的资源，比如说 property文件 ${basedir}/src/test/java 项目的测试类，比如说 JUnit代码 ${basedir}/src/test/resources 测试使用的资源 ${basedir}/target/classes 编译后 的 classes ${basedir}/target JAR 文件（默认产生） ${basedir}/target/test-classes 测试class文件 Maven 默认的本地库是 ~/.m2/repository/，在 Windows 下是 %USER_HOME%.m2\\repository\\ 。 ","date":"2020-03-26","objectID":"/post/java-01-maven/:1:0","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"核心概念 POM (Project Object Model) 一个项目所有的配置都放置在 POM 文件中：定义项目的类型、名字，管理依赖关系，定制插件的行为等等。比如说，你可以配置 compiler 插件让它使用 java 1.5 来编译。 groupId, artifactId, packaging, version 叫作 maven 坐标，它能唯一的确定一个项目. packing默认是jar类型， \u003cpackaging\u003epom\u003c/packaging\u003e ---------\u003e 父类型都为pom类型 \u003cpackaging\u003ejar\u003c/packaging\u003e ---------\u003e 内部调用或者是作服务使用 \u003cpackaging\u003ewar\u003c/packaging\u003e ---------\u003e 需要部署的项目 大项目一般会分成几个子项目。在这种情况下，每个子项目就会有自己的 POM 文件，然后它们会有一个共同的父项目。这样只要构建父项目就能够构建所有的子项目了。子项目的 POM 会继承父项目的 POM。另外，所有的 POM都继承了一个 Super-POM。Super-POM 设置了一些默认值，比如在第一篇文章中提到的默认的目录结构，默认的插件等等，它遵循了惯例优于配置的原则。POM 标签大全详解 运行时候的 POM 要复杂的多。 如果你想看到运行时候的 POM 的全部内容的话，可以运行下面的命令： $mvn help:effective-pom Maven 插件 用了 mvn archetype:generate 命令来生成一个项目。那么这里的 archetype:generate 是什么意思呢？archetype 是一个插件的名字，generate是目标(goal)的名字。这个命令的意思是告诉 maven 执行 archetype 插件的 generate 目标。插件目标通常会写成 pluginId:goalId. 一个目标是一个工作单元，而插件则是一个或者多个目标的集合。 spotify/docker-maven-plugin Maven 生命周期 第二个命令是：mvn package。这里的 package 是一个maven的生命周期阶段 (lifecycle phase )。生命周期指项目的构建过程，它包含了一系列的有序的阶段 (phase)，而一个阶段就是构建过程中的一个步骤。 插件目标可以绑定到生命周期阶段上。一个生命周期阶段可以绑定多个插件目标。当 maven 在构建过程中逐步的通过每个阶段时，会执行该阶段所有的插件目标。 默认的生命周期 process-resources 阶段：resources:resources compile 阶段：compiler:compile process-classes 阶段：(默认无目标) process-test-resources 阶段：resources:testResources test-compile 阶段：compiler:testCompile test 阶段：surefire:test prepare-package 阶段：(默认无目标) package 阶段：jar:jar Maven 依赖管理 maven 提供了传递依赖的特性。所谓传递依赖是指 maven 会检查被依赖的 jar 文件，把它的依赖关系纳入最终解决的依赖关系链中。 scope 决定了依赖关系的适用范围。 Maven 仓库 寻找顺序：本地仓库\u003e中央仓库\u003e远程仓库\u003e报错。 本地仓库 mvn install把我们的 helloworld 项目安装到本地库. 一个项目被安装到了本地库后，你别的项目就可以通过 maven 坐标和这个项目建立依赖关系。 中央仓库 Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。 远程仓库 开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。 ","date":"2020-03-26","objectID":"/post/java-01-maven/:1:1","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"开始使用 ","date":"2020-03-26","objectID":"/post/java-01-maven/:2:0","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"安装 $ sudo update-alternatives --config java确定JAVA的安装位置。 在/etc/environment文件中追加JAVA_HOME. ","date":"2020-03-26","objectID":"/post/java-01-maven/:2:1","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"建立一个项目 mvn archetype:generate -DgroupId=com.mycompany.helloworld -DartifactId=helloworld -Dpackage=com.mycompany.helloworld -Dversion=1.0-SNAPSHOT archetype:generate 目标会列出一系列的 archetype 让你选择. ","date":"2020-03-26","objectID":"/post/java-01-maven/:2:2","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"先构建 mvn package ","date":"2020-03-26","objectID":"/post/java-01-maven/:2:3","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"后运行 java -jar target/gs-rest-service-0.1.0.jar java -cp target/helloworld-1.0-SNAPSHOT.jar com.mycompany.helloworld.App ","date":"2020-03-26","objectID":"/post/java-01-maven/:2:4","tags":null,"title":"微服务架构笔记-JAVA-MAVEN","uri":"/post/java-01-maven/"},{"categories":null,"content":"JVM","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"JVM体系结构 JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)。 参考JVM内存模型。 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:0:0","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"内存结构 Java 虚拟机在运行 Java 程序 时，把它所管理的内存划分为若干个不同的数据区域（运行时数据区域），主要包括以下五个部分：程序计数器、Java 堆、Java 虚拟机栈、方法区和本地方法栈。 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:0","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"程序计数器（Program Counter Register） 线程私有，它的生命周期与线程相同。 可以看做是当前线程所执行的字节码的行号指示器。 在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，如：分支、循环、跳转、异常处理、线程恢复（多线程切换）等基础功能。  如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（undefined）。 程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，所以此区域不会出现OutOfMemoryError的情况。 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:1","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"Java虚拟机栈（JVM Stacks） 线程私有的，它的生命周期与线程相同。 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 该区域可能抛出以下异常：当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:2","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"本地方法栈（Native Method Stacks） 线程私有。 与虚拟机栈非常相似，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 虚拟机规范中对本地方法（操作系统）栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。 甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:3","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"Java堆（Heap） 只有一个 被所有线程共享，在虚拟机启动时创建，用来存放对象实例，几乎所有的对象实例都在这里分配内存。 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。 Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:4","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"方法区（Method Area） 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代（Permanent Generation）来进行垃圾回收。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 运行时常量池（Runtime Constant Pool） 运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。3. 注：在 JDK1.7之前，HotSpot 使用永久代实现方法区；HotSpot 使用 GC 分代实现方法区带来了很大便利；从 JDK1.7 开始HotSpot 开始移除永久代。其中符号引用（Symbols）被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。在 JDK1.8 中，永久代已完全被元空间(Meatspace)所取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。直接内存（Direct Memory） ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:5","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"直接内存（Direct Memory） 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。 在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和 Native 堆中来回复制数据。 作者：军儿呀\r链接：https://juejin.im/post/5ad5c0216fb9a028e014fb63\r来源：掘金\r著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:1:6","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"深入理解堆与栈 参考Java中堆内存和栈内存详解 堆内存调优 DUMP内存快照分析 JProfiler工具使用 GC机制及算法详解 ","date":"2020-02-15","objectID":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/:2:0","tags":["JAVA"],"title":"JAVA-JVM底层原理与性能","uri":"/post/java-jvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"},{"categories":null,"content":"JVM","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"JAVA基本语法 参考速学堂 面向对象 核心：将物理事物用代码抽象出来，拟物化编程。 一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。 基本概念 基本语法 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由public static void main(String args[])方法开始执行。 数据类型 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:0:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"基本类型 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:1:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"浮点数 浮点常量默认是double的，单精度保存小数点7位； 浮点数是不精确的，避免浮点数之间的比较。 使用高精度，可使用java.math中的类 BigDecimal（不可变的、任意精度的有符号十进制数。）和类 BigInteger（不可变的任意精度的整数。） ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:1:1","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"Boolean 按bit位占内存. ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:1:2","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"引用类型 字符串是对象。 控制语句 带标签的break和continue public class Test18 {\rpublic static void main(String args[]) {\router: for (int i = 101; i \u003c 150; i++) {\rfor (int j = 2; j \u003c i / 2; j++) {\rif (i % j == 0){\rcontinue outer;\r}\r}\rSystem.out.print(i + \" \");\r}\r}\r}\r 方法重载（方法名称相同，形式参数类型不同，形式参数个数不同，形式参数顺序不同，可以重载）。 递归（递归头和递归体），尽量避免使用递归，效率低下。一般都可以使用循环或if替代。 String 最常用。 String类又称作不可变字符序列。 Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:2:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"常量池 全局字符串常量池(String Pool) 全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值(在堆中生成字符串对象实例)。 class文件常量池(Class Constant Pool) class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量(文本字符串、final常量等)和符号引用。 运行时常量池(Runtime Constant Pool) 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:3:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"内存分析 String str1 = \"abc\";在堆中会有一个“abc”实例，全局String Pool中存放着“abc”的一个引用值. String str2 = new String(\"def\");``生成两个实例，一个是“def”的实例对象，并且String Pool中存储一个“def”的引用值，还有一个是new出来的一个“def”的实例对象，与前边那个是不同的实例;str2.intern();返回String Pool中“def”的引用值，如果没有就将str2的引用值添加进去. 数组 数组是相同类型数据的有序集合。 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型，不允许出现混合类型。 数组类型可以是任何数据类型，包括基本类型和引用类型。 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:4:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"声明 type[] arr_name; //（推荐使用这种方式）\rtype arr_name[];\r 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。 声明一个数组的时候并没有数组真正被创建。 构造一个数组，必须指定长度。 int[] s = null; // 声明数组；\rs = new int[10]; // 给数组分配空间；\r\rMan[] mans; //声明引用类型数组； mans = new Man[10]; //给引用类型数组分配空间；\r ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:5:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"初始化 静态初始化 int[] a = { 1, 2, 3 };// 静态初始化基本类型数组；\rMan[] mans = { new Man(1, 1), new Man(2, 2) };// 静态初始化引用类型数组；\r 动态初始化 默认初始化 数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:6:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"遍历 通过for和下标进行遍历（读取或修改）。 增强for循环for-each是JDK1.5新增加的功能，专门用于读取数组或集合中所有的元素，即对数组进行遍历，不能修改。 String[] ss = { \"aa\", \"bbb\", \"ccc\", \"ddd\" };\rfor (String temp : ss) {\rSystem.out.println(temp);\r}\r ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:7:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"拷贝 System类里也包含了一个static void arraycopy(object src，int srcpos，object dest， int destpos，int length)方法，该方法可以将src数组里的元素值赋给dest数组的元素，其中srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多少个元素赋给dest数组的元素。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:8:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"java.util.Arrays类 包含了常用的数组操作，方便我们日常开发。Arrays类包含了：排序、查找、填充、打印内容等常见的操作。 Arrays.toString() // 打印\rArrays.sort() // 排序\rArrays.binarySearch(a, 12) // 返回元素索引\rArrays.fill(a, 2, 4, 100); //将2到4索引的元素替换为100;\r 通过实现Comparable接口的compareTo方法，可以自定义排序规则。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:9:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"多维数组 实际开发中用的非常少。最多到二维数组(学习容器后，我们一般使用容器，二维数组用的都很少)。 public class Test {\rpublic static void main(String[] args) {\r// Java中多维数组的声明和初始化应按从低维到高维的顺序进行\rint[][] a = new int[3][];\ra[0] = new int[2];\ra[1] = new int[4];\ra[2] = new int[3];\r// int a1[][]=new int[][4];//非法\r}\r}\rint[][] a = new int[3][];\r// a[0] = {1,2,5}; //错误，没有声明类型就初始化\ra[0] = new int[] { 1, 2 };\ra[1] = new int[] { 2, 2 };\ra[2] = new int[] { 2, 2, 3, 4 };\r ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:10:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"数组存对象 此处基本数据类型”1001”，本质不是Object对象。JAVA编译器会自动把基本数据类型“自动装箱”成包装类对象（需要对象的场合）。 Object[] a1 = {1001,\"高淇\",18,\"讲师\",\"2006-2-14\"};\rObject[] a2 = {1002,\"高小七\",19,\"助教\",\"2007-10-10\"};\rObject[] a3 = {1003,\"高小琴\",20,\"班主任\",\"2008-5-5\"};\r 通常情况下，我们使用javabean实现对象数组。 异常机制 就是当程序出现错误，程序安全退出的机制。 在Java的异常处理机制中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。 所谓异常处理，就是指程序在出现问题时依然可以正确的执行完。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:11:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"异常处理（采用面向对象的方式来处理异常） 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。 捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。 异常的处理方式有两种：使用“try/catch”捕获异常、使用“throws”声明异常。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:12:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"捕获异常 捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。 一个try语句必须带有至少一个catch语句块或一个finally语句块 。 如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。 有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。 通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。 即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。 finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。 try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。 所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。 public class Main2 { public static void main(String[] args) {\rtry(ResourceSome some = new ResourceSome();\rResourceOther other = new ResourceOther()) {\rsome.doSome();\rother.doOther();\r} catch(Exception ex) {\rex.printStackTrace();\r}\r}\r}\rclass ResourceSome implements AutoCloseable {\rvoid doSome() {\rSystem.out.println(\"do something\");\r}\r@Override\rpublic void close() throws Exception {\rSystem.out.println(\"some resource is closed\");\r}\r}\rclass ResourceOther implements AutoCloseable {\rvoid doOther() {\rSystem.out.println(\"do other things\");\r}\r@Override\rpublic void close() throws Exception {\rSystem.out.println(\"other resource is closed\");\r}\r}\r最终输出为：\rdo something\rdo other things\rother resource is closed\rsome resource is closed\r在 try 语句中越是最后使用的资源，越是最早被关闭。\r 在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:12:1","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"声明异常 如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。 如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。 throws和throw ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:12:2","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"异常分类 所有异常对象都是派生于Throwable类(java.lang.Throwable)的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。 Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:13:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"Error 表示代码运行时 JVM(Java 虚拟机)出现的问题. Error表明系统JVM已经处于不可恢复的崩溃状态中。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:13:1","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"Exception Exception是程序本身能够处理的异常. Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为： RuntimeException 运行时异常 CheckedException 已检查异常 RuntimeException 由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。 这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要通过增加“逻辑处理来避免这些异常”。 CheckedException 这类异常在编译时就必须做出处理，否则无法通过编译。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:13:2","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"自定义异常 自定义异常类只需从Exception类或者它的子类派生一个子类即可。 自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。 习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。 处理异常不可以代替简单测试—只在异常情况下使用异常机制。 不要进行小粒度的异常处理—应该将整个任务包装在一个try语句块中。 异常往往在高层处理。 ","date":"2020-02-15","objectID":"/post/java-02-%E5%9F%BA%E7%A1%80/:14:0","tags":["JAVA"],"title":"JAVA-基础","uri":"/post/java-02-%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"JVM","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"部分内容摘自速学堂 概念 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"类和对象 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"对象 对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 对象创建的过程 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:1","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"类 类是一个模板，它描述一类对象的行为和状态。 一个JAVA文件只能有一个public类，而且类名和文件名相同。可以有多个非public类。 构造方法 构造方法名和类名相同，虽然有返回值（对象的地址），不能定义返回值类型，不能在构造器中使用return返回某个值。 用于对象的初始化。 Java通过new关键词来调用构造器，从而返回该类的实例。 没有定义构造器的话，编译器会自动定义一个无参的构造函数。 构造方法也是方法，也可以重载。 如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。 静态初始化块，用于类的初始化操作 public class User3 {\rint id; //id\r String name; //账户名\r String pwd; //密码\r static String company; //公司名称\r static {\rSystem.out.println(\"执行类的初始化工作\");\rcompany = \"北京尚学堂\";\rprintCompany();\r} public static void printCompany(){\rSystem.out.println(company);\r} public static void main(String[] args) {\rUser3 u3 = new User3();\r}\r}\r ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:2","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"方法 方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:3","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"实例变量 每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:4","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"this\\static关键字(在方法区) this的本质就是“创建好的对象的地址”! 在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： a. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。 b. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! c. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。) d. 在static方法中不可直接访问非static的成员。 类方法引用在方法区、对象中的方法引用在堆，都指向方法区中类信息的方法代码。 this的使用场景 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:5","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"包 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。 Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类。 静态导入(static import)是在JDK1.5新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。 常用的包 包名 内容 java.lang\\ 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt\\ 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net\\ 包含执行与网络相关的操作的类。 java.io\\ 包含能提供多种输入/输出功能的类。 java.util\\ 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:6","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"内存底层 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"虚拟机内存模型 每执行一个方法，都会创建一个栈帧；堆存放对象；方法区存放类信息和常量和字符串等。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"垃圾回收机制 主要是堆中对象的管理回收。 JVM优化主要是垃圾回收机制优化。 对象创建new。 发现无用的对象（没有任何变量引用的对象）；回收无用对象占用的内存空间。 相关算法 引用计数法 每个对象有一个引用计数器，有变量引用加1，无变量引用减1. 优点：算法简单。缺点是循环引用的无用对象无法识别。 引用可达法（跟搜索算法） 所有引用关系使用图。 通用的分代垃圾回收机制 按生命周期长短划分年轻代、年老代、永久代。将处于不同状态的对象放到堆中不同的区域。 JVM将堆内存分为Eden、Survivor和Tenured/Old空间。 按照存活时间，往时间更长的区域移动。 JDK8之后没有永久代了。 MinorGC(清理年轻代，满了触发);Major（年老代）GC;Full GC（年轻代和年老代）. JVM调优 很大一部分工作就是对于Full GC的调节。 触发Full GC的原因： a. 年老代被写满； b. 永久代被写满； c. System.gc()被显式调用，只是通知JVM（建议），尽量少用； d. 上一次GC之后Heap的各域分配策略动态变化。 程序员无权调用垃圾回收器。 finalize方法，是java提供给程序员用来释放对象或资源的方法，尽量少用。 以下四种情况容易造成内存泄漏 创建大量无用的对象（比如大量拼接字符串，使用了string而不是stringBuilder）； 静态集合类（HashMap\\Vector\\List）的使用； 各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭； 监听器的使用。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"三大特征 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"继承 需求 代码复用。 事物抽象。 使用要点 父类也称作超类、基类、派生类等。 Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。 Java中类没有多继承，接口有多继承。 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。 方法重写 子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。 方法的重写需要符合下面的三个要点： 1.“==”： 方法名、形参列表相同。 2.“≤”：返回值类型和声明异常类型，子类小于等于父类。 3.“≥”： 访问权限，子类大于等于父类。 final关键字 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。 修饰方法：该方法不可被子类重写。但是可以被重载! 修饰类: 修饰的类不能被继承。比如：Math、String等。 继承和组合 is a使用继承，has a使用组合。 组合模式是将对象组合成树形结构（定义一个类属性为一个类的实例）以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 Object类 Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。 toString()方法. “==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。 Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。 Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。 JDK提供的一些类，如String、Date、包装类等，重写了Object的equals方法，调用这些类的equals方法， x.equals (y) ，当x和y所引用的对象是同一类对象且属性内容相等时（并不一定是相同对象），返回 true 否则返回 false。 super关键字 super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。 若是构造方法的第一行代码没有显式的调用super(...)或者this(...);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。 继承树追溯 依次上溯每个父类，查看每个父类中是否有h，直到Object； 构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"封装 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。 “高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 访问控制符 使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。 private 表示私有，只有自己类能访问 default表示没有修饰符修饰，只有同一个包的类能访问 protected表示可以被同一个包的类以及其他包中的子类访问 public表示可以被该项目的所有包中的所有类访问 protected 若父类和子类在同一个包中，子类可访问父类的protected成员，也可以访问父类对象的protected成员； 若父类和子类不在同一个包中，子类可访问父类的protected成员，不能访问父类对象的protected成员。 使用细节(使用private和public最多) 类的属性的处理: 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 这个约定就是javabean. ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"多态 多态指的是同一个方法调用，由于对象不同可能会有不同的行为。 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 多态的主要优势是提高了代码的可扩展性(避免大量的重载)，符合开闭原则。但是多态也有弊端，就是无法调用子类特有的功能. 类型的转换 父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型! 在向下转型过程中，必须将引用变量转成真实的子类类型(运行时类型)否则会出现类型转换异常ClassCastException。为了避免出现这种异常，我们可以使用instanceof运算符进行判断 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"特殊类 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"抽象类和抽象方法 使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 使用要点 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。 抽象方法必须被子类实现。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"Java 接口 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。 从接口的实现者角度看，接口定义了可以向外部提供的服务。 从接口的调用者角度看，接口定义了实现者能提供那些服务。 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。 接口和实现类不是父子关系，是实现规则的关系。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。 面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。 普通类：具体实现;抽象类：具体实现，规范(抽象方法);接口：规范! 定义 [访问修饰符] interface 接口名 [extends 父接口1，父接口2…] {\r常量定义； 方法定义；\r}\r 访问修饰符：只能是public或默认。 接口名：和类名采用相同命名机制。 extends：接口可以多继承。 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。 要点 子类通过implements来实现接口中的规范。 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 JDK7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 JDK8后，接口中也包含普通的静态方法和default（必须写default）方法。 面向接口 我们必须围绕某种稳定的东西开展，才能以静制动，实现规范的高质量的项目。 接口就是规范，就是项目中最稳定的东东! 面向接口编程可以让我们把握住真正核心的东西，使实现复杂多变的需求成为可能。 面向接口编程的概念比接口本身的概念要大得多。设计阶段相对比较困难，在你没有写实现时就要想好接口，接口一变就乱套了，所以设计要比实现难! java8新特性 默认方法（普通方法）必须加default。 静态方法。 默认方法可以调用静态方法。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"内部类 不是很常用。 把一个类放在另一个类的内部定义，称为内部类(innerclasses)。 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类只能使用public和default修饰。 内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。 内部类的作用： 1. 内部类提供了更好的封装。`只能让外部类直接访问，不允许同一个包中的其他类直接访问`。\r2. 内部类`可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性`。\r3. 接口只是解决了多重继承的部分问题，而`内部类使得多重继承的解决方案变得更加完整`。\r 内部类的使用场合： 1. 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在`只为外部类提供服务的情况下`可以优先考虑使用内部类。\r2. 使用内部类`间接实现多继承`：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。\r 内部类的分类 成员内部类 可以使用private、default、protected、public任意进行修饰。 非静态内部类 外部类里使用非静态内部类和平时使用其他类没什么不同 非静态内部类对象单独属于外部类的某个对象。 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 非静态内部类不能有静态方法、静态属性和静态初始化块。 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 成员变量访问要点： 内部类里方法的局部变量：变量名。 内部类属性：this.变量名。 外部类属性：外部类名.this.变量名。 内部类的访问： 外部类中定义内部类：new Inner() 外部类以外的地方使用非静态内部类：Outer.Inner varname = new Outer().new Inner()。 静态内部类 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。 匿名内部类 适合那种只需要使用一次的类。比如：键盘监听操作等等。·形参· 匿名内部类没有访问修饰符。 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。 new 父类构造器（参数列表）|实现接口（） { //匿名内部类的类体部分 }\r 局部内部类 定义在方法内部的，作用域只限于本方法，称为局部内部类。 局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:3","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"常用类 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:0","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"包装类 我们在实际应用中经常需要将基本数据转化成对象，以便于操作。比如：将基本数据类型存储到Object[]数组或集合中的操作等等。 为了解决这个不足，Java在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。 包装类均位于java.lang包 这八个类名中，除了Integer和Character类以外，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写而已。 这八个类中，除了Character和Boolean以外，其他的都是“数字型”，“数字型”都是java.lang.Number的子类。Number类是抽象类，因此它的抽象方法，所有子类都需要提供实现。Number类提供了抽象方法：intValue()、longValue()、floatValue()、doubleValue()，意味着所有的“数字型”包装类都可以互相转型。 作用 作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。 包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化!)。 public class Test {\r/** 测试Integer的用法，其他包装类与Integer类似 */\rvoid testInteger() {\r// 基本类型转化成Integer对象\r Integer int1 = new Integer(10);\rInteger int2 = Integer.valueOf(20); // 官方推荐这种写法\r // Integer对象转化成int\r int a = int1.intValue();\r// 字符串转化成Integer对象\r Integer int3 = Integer.parseInt(\"334\");\rInteger int4 = new Integer(\"999\");\r// Integer对象转化成字符串\r String str1 = int3.toString();\r// 一些常见int类型相关的常量\r System.out.println(\"int能表示的最大整数：\" + Integer.MAX_VALUE); }\rpublic static void main(String[] args) {\rTest test = new Test();\rtest.testInteger();\r}\r}\r 自动装箱和拆箱(编译器实现) 自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。 Integer i = 5 自动执行了 Integer i = Integer.valueOf(5)\rInteger i = 5;int j = i; 这样的过程就是自动拆箱。\r 自动装箱过程是通过调用包装类的valueOf()方法实现的，而自动拆箱过程是通过调用包装类的 xxxValue()方法实现的(xxx代表对应的基本数据类型，如intValue()、doubleValue()等)。 所以自动装箱与拆箱的功能是所谓的“编译器蜜糖(Compiler Sugar)”，虽然使用这个功能很方便，但在程序运行阶段您得了解Java的语义。 包装类的缓存 整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。 超过范围后，对象之间不能再使用==进行数值的比较，而是使用equals方法。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:1","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"String相关类 String 不可变。final value substring()会生成新的字符串。 在遇到字符串常量之间的拼接时，编译器会做出优化，即在编译期间就会完成字符串(显示常量)的拼接。因此，在使用==进行String对象之间的比较时，我们需要特别注意 String类的下述方法能创建并返回一个新的String对象: concat()、 replace()、substring()、 toLowerCase()、 toUpperCase()、trim()。 提供查找功能的有关方法: endsWith()、 startsWith()、 indexOf()、lastIndexOf()。 提供比较功能的方法: equals()、equalsIgnoreCase()、compareTo()。 其它方法: charAt() 、length()。 StringBuilder 可变。 效率高，不做线程同步检查，线程不安全。局部变量可用。 抽象类AbstractStringBuilder的子类。 重载的public StringBuilder append(…)方法 可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。 方法 public StringBuilder delete(int start,int end) 可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。 方法 public StringBuilder deleteCharAt(int index) 移除此序列指定位置上的 char，仍然返回自身对象。 重载的public StringBuilder insert(…)方法 可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。 方法 public StringBuilder reverse() 用于将字符序列逆序，仍然返回自身对象。 方法 public String toString() 返回此序列中数据的字符串表示形式。 和 String 类含义类似的方法： public int indexOf(String str)\rpublic int indexOf(String str,int fromIndex)\rpublic String substring(int start)\rpublic String substring(int start,int end)\rpublic int length() char charAt(int index)\r StringBuffer 可变。 效率低，做线程同步检查，线程安全。 抽象类AbstractStringBuilder的子类。 方法与上类似。 对比 String s =\"a”; 创建了一个字符串,s = s+\"b”; 实际上原来的\"a\"字符串对象已经丢弃了，现在又产生了另一个字符串s+\"b”(也就是\"ab”)。 如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的时间和空间性能，甚至会造成服务器的崩溃。 相反，StringBuilder和StringBuffer类是对原字符串本身操作的，可以对字符串进行修改而不产生副本拷贝或者产生少量的副本。因此可以在循环中使用。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:2","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"时间处理相关类 Date类(java.util.Date) long类型表示毫秒数。 System.currentTimeMills() 获取当前的毫秒数。 Date() 分配一个Date对象，并初始化此对象为系统当前的日期和时间，可以精确到毫秒)。 Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间(称为“历元(epoch)”，即 1970 年 1 月 1 日 00:00:00 GMT)以来的指定毫秒数。 boolean after(Date when) 测试此日期是否在指定日期之后。 booleanbefore(Date when) 测试此日期是否在指定日期之前。 boolean equals(Object obj) 比较两个日期的相等性。 long getTime() 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 String toString() 把此 Date 对象转换为以下形式的 String：dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun、 Mon、Tue、Wed、 Thu、 Fri、 Sat)。 日期操作一般使用Calendar类，而字符串的转化使用DateFormat类。 DateFormat类和SimpleDateFormat类 把时间对象转化成指定格式的字符串。反之，把指定格式的字符串转化成时间对象。 DateFormat是一个抽象类，一般使用它的的子类SimpleDateFormat类来实现。 Calendar日历类和GregorianCalendar类 GregorianCalendar calendar = new GregorianCalendar(2999, 10, 9, 22, 10, 50);\rint year = calendar.get(Calendar.YEAR); // 打印：1999\rint month = calendar.get(Calendar.MONTH); // 打印：10\rint day = calendar.get(Calendar.DAY_OF_MONTH); // 打印：9\rint day2 = calendar.get(Calendar.DATE); // 打印：9\r// 日：Calendar.DATE和Calendar.DAY_OF_MONTH同义\rint date = calendar.get(Calendar.DAY_OF_WEEK); // 打印：3\rcalendar2.set(Calendar.YEAR, 2999);\rcalendar2.set(Calendar.MONTH, Calendar.FEBRUARY); // 月份数：0-11\rcalendar2.set(Calendar.DATE, 3);\rcalendar2.set(Calendar.HOUR_OF_DAY, 10);\rcalendar2.set(Calendar.MINUTE, 20);\rcalendar2.set(Calendar.SECOND, 23);\rcalendar3.add(Calendar.MONTH, -7); // 月份减7\rcalendar3.add(Calendar.DATE, 7); // 增加7天\r ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:3","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"Math类（ java.lang.Math） 提供了一系列静态方法用于科学计算;其方法的参数和返回值类型一般为double型。 如果需要更加强大的数学运算能力，计算高等数学中的相关内容，可以使用apache commons下面的Math类库。 Math.random()，但是通常我们需要的随机数范围并不是[0, 1)之间的double类型的数据。 如果使用Math.random()计算过于复杂的话，我们可以使用例外一种方式得到随机数，即Random类，这个类是专门用来生成随机数的，并且Math.random()底层调用的就是Random的nextDouble()方法。 Random类位于java.util包下。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:4","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"file类（ java.io.File） 读取文件、生成文件、删除文件、修改文件的属性时经常会用到本类 常见构造方法：public File(String pathname) 以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir（System.getProperty(‘user.dir’)）中存储. createNewFile() delete() mkdir() chuang’jia mkdirs() ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:5","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"枚举 枚举类型的定义包括枚举声明和枚举体。 enum 枚举名 {\r枚举体（常量列表）\r}\r 枚举体就是放置一些常量。 所有的枚举类型隐性地继承自 java.lang.Enum。 枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。 可以直接通过枚举类型名使用它们。 当你需要定义一组常量时，可以使用枚举类型。 尽量不要使用枚举的高级特性，事实上高级特性都可以使用普通类来实现，没有必要引入枚举，增加程序的复杂性! ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:6","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"其他 工具类的构造器做好是私有化的。 GameUtil.class.getClassLoader().getResource(path);可以帮助我们获得程序运行类加载器，加载资源的根目录，从而获得相对资源位置。 ","date":"2020-02-15","objectID":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:7","tags":["JAVA"],"title":"JAVA-面向对象","uri":"/post/java-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"1. 2015年 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:0:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.1. 互联网恐慌 用生物学思维重新理解商业； 何须转型，只要增长； ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:1:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.2. 资本寒冬 最适合创业的人是聪明、年轻、贫穷的人； 年轻人创业，失去的是锁链，赢得的是整个世界； 钱是世界上最聪明的东西，最负责任的东西； 经济越发达，资本越不值钱； 资本寒冬，不是大家不投了，是暂时不知道投什么资产合适； 寒武纪出现的两性繁殖，其实是为了获取物种的多样性； 资本和雄性一样，都花心；雌性，指的是互联网创业者； 商场上只讲力量; 王石真正值得尊敬，我真正等着看这场大戏的是，代表创业者、代表知识和人力资本的持有者，他怎么样通过堂堂正正的规则下的博弈，去引来浩瀚如大海一般的资本力量，去击溃门口的野蛮人; ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:2:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.3. 两只“妖股” 资本最恐惧的是坐吃山空，资本一定要找到新的出路; ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:3:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.4. O2O大战 程维说滴滴烧钱，其实并非他们的初衷; 金字塔收入结构被打破，现在更像是仙人掌模式，只要你有手艺，就能借助互联网渠道展业，手艺人的地位真真切切的在上升; 每一代连接技术都会产生这样的奇迹，互联网也是这样，必然产生一代红利，然而享有者未必是连接者; 互联网基础设施已经构建好了，要重新思考红利; ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:4:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.5. IP 可以摆脱单平台的束缚，对用户产生吸引力的事物； 让人们有存在感、是一种社交货币、是新型交易入口； 在某些特定领域，IP可以帮助粉丝制造存在感； 传统的交易入口，靠流量和性价比（如店面和集市），但人格化的交易入口正在崛起； 稀缺性是商品的核心价值； 让人觉得信任的“人”，是稀缺的； 罗辑思维是人格化的交易，粉丝购买力不会因为流量变大而提高； IP能够为商品提供稀缺性，满足和彰显消费者的“分别心”； ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:5:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.6. 腾讯和阿里 合法赚钱，是用户用钱投票创造的价值； 银行的重要职能是为“风险”去定价； 马云一直在努力重新定义阿里这家公司——关键在于对大数据的掌握和运用； 阿里的收购逻辑，也可以用数据获取的角度去分析理解； 阿里让世界更清晰地看到人；腾讯让人更高效地得到世界； 在商业上，你老了，就是新一代的基础设施，你已经不会用了。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:6:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"1.7. 小米和华为 小米把硬件供应链撕开了一条口子，让智能手机门槛大大降低，值得尊敬。 线：拦路抢劫——小米的模式，是力求打造生态链，长久的赚钱； 点：坐地分赃——华为的模式，追求单品利润； 不去连线（进不去、守不住、跟不上），而是去造点； Apple，稳扎稳打，追求单品利润； 真诚才是成功的关键。 2. 2016年 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:7:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"2.1. 时间战场 宏观是我们必须接受的，微观才是我们能有所作为的； 现在所有的新兴产业本质上就是既要你的钱，还要你的命； 未来，在时间这个战场上，有两门生意会特别值钱：第一，就是帮别人省时间。第二，就是帮别人把省下来的时间浪费在那些美好的事物上。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:8:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"2.2. 服务升级 今日头条，践行“母爱逻辑”，就是孩子要什么，妈给你更多，惯得你没样。 我的商业生涯要走在这个逻辑的反面，走在父爱逻辑里。首先我得站得更高、看得更远，我得知道什么是好东西，然后我也许态度粗暴冷峻地跟我的用户说，来，这个是好东西，我把它称之为叫“父爱算法”。在这个算法世界当中，一定有它的一席之地，最好的服务是给你还不知道的好东西。这是下一个消费升级的方向。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:9:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"2.3. 智能革命 人工智能不是在复制人类，它是完全不同的另外一种存在。 人工智能不会提高玩家参与的门槛，是降低了参与门槛。 人工智能不仅是人的延伸，它是人的替代。 领导力和创造力。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:10:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"2.4. 认知税 世界越来越破碎，而那些治愈破碎的力量就会变得越来越值钱。这个力量我们称之为共同的认知。 越来越稀缺的东西，就越来越值钱。这背后的逻辑和过去几十年的房地产业一模一样。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:11:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"2.5. 共同体危机 有一个词，使用频率在2016年飙升了200倍——“后真相”。情绪的影响力已经超过了事实。 后真相（post-truth）的意思，不是没有真相，而是对这个世界来说，情绪的影响力已经超过了事实。 自律自律自律。 3. 2017年 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:12:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"3.1. 动车组脑洞 创新就是解决问题的能力。 创新必须是干一遍才知道。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:13:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"3.2. 热带雨林脑洞 新物种，往往是高价值的连接器（货满满，快手）。 流量思维已经过时。 过度到超级用户思维（小生态）。 会员经济在企业和消费者之间建立了一种可持续可信任的正式关系。 不管你对普通用户有多好，请先关照超级用户的感受，面朝超级用户。做让用户长脸的事，不做让用户丢脸的事。彼此觉得荣耀。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:14:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"3.3. 比特化脑洞 货正在一步步逼近人。 小米认知战。 做好自己，保持开放。 效率越来越高，分工越来越细。 4. 2018 5. 2019 贝聿铭：我从来没有考虑过这些问题，因为我一直沉浸在如何解决自己的问题中。 不解决一个个想象中的问题，回应一个个真实世界的挑战。 躬身入局。把自己放进去，把自己变成解决问题的关键变量。 容易赚的钱没了，往后大家都得做更辛苦的事。 别以为下沉市场就算更辛苦了，也别以为找细分需求就算更辛苦了，真正的机会，改造每一个只得被重构的传统产业，这才是一件具备创造力的苦差事。 每个人都能找到自己的着力点。往旁边看一看，迈出这么一小步，这就是你向上攀岩的着力点。 检验品牌，就是你愿意和他自拍。 利用中国红利和新基础设施创造一个世界级品牌。 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:15:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"5.1. 钱从哪里来 73%的劳动所得，个人辛苦赶出来的。27%理财所得。 人和人的连接，正在决定社会财富的创造、分配和转移。 你自己的本事，你和其他人连接的本事。 保险职业考验的是持续赢得用户尊重的能力。 本领可能会过时，资本可能会贬值，但是，人和人之间的连接是可以一直延续下去的。多和人连接保证没有坏处。 钱从自己的劳动里来，钱从更多的人和人的连接中来。 你是谁？你干啥？你为谁干？别人需要你吗？社会更好了吗？ ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:16:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"5.2. 教育在发生什么变化 ","date":"2019-12-27","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/:17:0","tags":null,"title":"日常-罗振宇-时间的朋友","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BD%97%E6%8C%AF%E5%AE%87-%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"},{"categories":null,"content":"关联 目的 ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:0:0","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"第三方应用登录 例如GITHUBOAuth applications are used to access the GitHub API.,在github注册一个OAuth APP(拿到key和secret)就可以让用户使用github账号登录本网站，本网站可以获取此用户在github上的授权信息。 ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:1:0","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"一处登录，处处登录；一处注销，处处注销 不同域名下，一处登录，处处登录，一处注销，处处注销。 ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:2:0","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"单点登录的实现方案(非前后端分离) 一般就包含以下三种： Cookies Session同步 分布式Session方式 Cookies 缺点： 不安全; 不能跨域实现免登。 Session同步 分布式Session 流程运行： 用户第一次登录时，将会话信息（用户Id和用户信息），比如以用户Id为Key，写入分布式Session； 用户再次登录时，获取分布式Session，是否有会话信息，如果没有则跳到登录页； 一般采用缓存中间件实现，建议使用Redis，因此它有持久化功能，方便分布式Session宕机后，可以从持久化存储中加载会话信息； 存入会话时，可以设置会话保持的时间，比如15分钟，超过后自动超时. ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:2:1","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"常见方案 要点有两个：存储信任和验证信任。 身份认证技术 cas（单点登录） 缺点：cas单点登录技术适用于传统应用的场景比较多， 官方示例也是以javaWeb为准， 对微服务化应用，前后端分离应用，支持性较差。 Spring Security OAuth2（第三方登录授权：github登陆） OAuth2是用来允许用户授权第三方应用访问他在另一个服务器上的资源的一种协议，它不是用来做单点登录的，但我们可以利用它来实现单点登录。 jwt (客户端token：原生) 安全控制框架 spring-security shiro ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:2:2","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"解决的问题 session共享的问题： （1）负载均衡（iphash），但是如果单点故障，还是需要重新登录。 （2）session共享，但是集群数量大的话，会造成效率缓慢。 方法：使用第三方redis，保存用户信息（UUID：token）。token保存在cookie中。 实现 以Spring Boot或者以SSM为基础。 知识点 cookie、session、sessionid与jsessionid ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:2:3","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"JSONP JSONP原理及实现跨域方式 难点 不同域名如何实现同时登录？ a.利用localStorage实现跨域通信。目前广泛采用的是postMessage和iframe相结合的方法。postMessage(data,origin)方法允许来自不同源的脚本采用异步方式进行通信，可以实现跨文本档、多窗口、跨域消息传递。localstorage的跨域存储方案. b. localStorage和cookie的跨域解决方案. 淘宝天猫的cookie同步问题？ a. 聊聊阿里淘宝SSO跨域登录过程 ","date":"2019-12-25","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/:3:0","tags":null,"title":"产品设计-单点登录","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"参考产品经理小技术（三）：二维码这把利刃，产品应该用到极致 第三方授权登录 参考微信的网页版扫码登陆原理 网页端扫描二维码登录 二维码是有失效时间以及失效状态的，一旦你扫过一次二维码或者在某段时间内没有扫描页面上的二维码，该二维码就失效了。 ","date":"2019-12-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%A4%9A%E7%AB%AF%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/:0:0","tags":null,"title":"产品设计-多端扫码设计","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%A4%9A%E7%AB%AF%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"客户端 获取一个有效的ID来生成二维码，并设置有效时间。超时需要重新生成。 使用长轮询（25s超时）请求服务器获取ID的绑定状态及登录状态。 只有登录状态才调到登录后的页面。 ","date":"2019-12-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%A4%9A%E7%AB%AF%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/:1:0","tags":null,"title":"产品设计-多端扫码设计","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%A4%9A%E7%AB%AF%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"服务端 维护ID与用户的绑定状态； 支持长轮询。 支持退出登录，即绑定状态失效。 ","date":"2019-12-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%A4%9A%E7%AB%AF%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/:2:0","tags":null,"title":"产品设计-多端扫码设计","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%A4%9A%E7%AB%AF%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"IaaS PaaS SaaS 参考IaaS，PaaS，SaaS 的区别. SaaS 模式下用户没有任何自主权，只能使用给定的应用程序；PaaS 模式下可以自己安装应用程序，但是不能定制操作系统；IaaS 模式下则是云服务商提供（虚拟的）硬件，从操作系统开始都可以自己选择和定制。 ripienaar/free-for-devA list of SaaS, PaaS and IaaS offerings that have free tiers of interest to devops and infradev. 单租户和多租户 摘自单租户\u0026多租户学习笔记 ","date":"2019-12-11","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/:0:0","tags":null,"title":"产品设计-SAAS","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/"},{"categories":null,"content":"单租户SaaS架构 被称作多实例架构，指的是为每个客户单独创建各自的软件应用和支撑环境。单租户SaaS被广泛引用在客户需要支持定制化的应用场合。 每个客户都有一份分别放在独立的服务器上的数据库和操作系统，或者使用强的安全措施进行隔离的虚拟网络环境中。 ","date":"2019-12-11","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/:1:0","tags":null,"title":"产品设计-SAAS","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/"},{"categories":null,"content":"多租户SaaS架构 应用都是运行在同样的一个或者一组服务器上，被称为“单实例”架构（Single Instance）。 多租户比较适合通用类需求的客户，即不需要对主线功能进行调整或者重新配置的客户。多个租户的数据是保存在相同的位置，并且通常是依靠分区来确保租户之间的数据隔离。 多租户可以分为几个不同的类别： a) 云中的简单虚拟化，其中只对硬件进行共享。它提供了最强的分离度，租户的数据彼此物理不可见，备份与恢复都很灵活，但是资源共享低，成本高。 b) 共享应用程序，对每个租户使用不同的数据库。租户间数据彼此逻辑不可见，上层应用程序的实现和独立数据库一样简单，但是备份恢复稍显复杂. c) 共享应用程序和数据库（效率最高，真正的多租户）。租户数据在数据表级别实现共享，它提供了最低的成本，但是引入了额外的编程复杂性（程序的数据访问需要用 tenantId 来区分不同租户），备份与恢复也更复杂。 搭建SaaS平台 参考将您的 web 应用程序转化为多租户 SaaS 解决方案 ","date":"2019-12-11","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/:2:0","tags":null,"title":"产品设计-SAAS","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/"},{"categories":null,"content":"概念 参考 云自助服务平台，可能和网上购物、在线商城有些类似，但里面提供的是相关服务，还是有些区别的. 产品：产品即服务，即是提供给用户的服务。产品有单价，有些产品是基础产品，用户购买正式产品必须免费提供的，产品可以提供给用户进行试用。 模块：产品包括很多模块，有些模块是必然会提供给用户的，比如 操作人员管理、操作日志 等，还有些模块是可选的，用户针对自己的情况进行购买，类似增值服务，比如移动端、企业主页等。另外还有些一次性的服务，比如系统数据对接，硬件设备购买等； 服务：用户所能享受到的服务，有一定的使用期限； 订单：用户根据所拥有的 服务 所下的订单（而不是产品哦，为什么？）； 购物车：在用户订单生成前先把产品放在购物车里，购物车有很多类别，有的购物车是对目前服务进行的延期，有些是把试用的产品转为正式，有些是对现有服务模块的增删，牵涉到追加购买等。购物车操作频繁、需要做非常多的校验，要和已经购买的服务做无缝的对接，这也是云SAAS产品和普通电商很大不同的地方。到了订单阶段，就相对比较简单了，生成订单后将购物车清空、可以生成多张订单，支付的时候再做一遍校验。 总体的概念流程是 模块-\u003e产品-\u003e购物车-\u003e订单-\u003e服务 ","date":"2019-12-11","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/:3:0","tags":null,"title":"产品设计-SAAS","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/"},{"categories":null,"content":"开源软件 forter/security-101-for-saas-startups chillzhuang/SpringBladeSpringBlade 是一个由商业级项目升级优化而来的SpringCloud分布式微服务架构、SpringBoot单体式微服务架构并存的综合型项目，采用Java8 API重构了业务代码，完全遵循阿里巴巴编码规范。采用Spring Boot 2 、Spring Cloud Greenwich 、Mybatis 等核心技术，同时提供基于React和Vue的两个前端框架用于快速搭建企业级的SaaS多租户微服务平台。 官网：https://bladex.vip sqreen/CTOSecurityChecklist. zuihou/zuihou-admin-cloud基于SpringCloud(Greenwich.RELEASE) + SpringBoot(2.1.2.RELEASE) 的SaaS 微服务脚手架，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关API、分布式事务、大文件断点分片续传等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用Eureka、Fegin、Ribbon、Zuul、Hystrix、JWT Token、Mybatis、SpringBoot、Redis、等主要框架和中间件。 async-labs/saasBuild your own SaaS business with SaaS boilerplate. Productive stack: React, Material-UI, Next, MobX, WebSockets, Express, Node, Mongoose, MongoDB. Written with TypeScript. Atarity/deploy-your-own-saasList of “only yours” cloud services for everyday needs fjb040911/Comb ","date":"2019-12-11","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/:4:0","tags":null,"title":"产品设计-SAAS","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-saas/"},{"categories":null,"content":"从无到有、从小到大，今日头条大数据平台实践经历的那些坑 基于刻到骨子里的数据驱动的思想，各种各样的数据需求源源不断的被提上来，这时不再是几个数据工程师单打独斗就能解决问题了，而让PM 和运营直接分析数据的门槛也很高。 面对这些情况，头条的做法是成立数据平台团队，把数据基础设施像 Hadoop、Hive、Spark、Kylin 等封装成工具，把这些工具结合通用的分析模式整合成完整的解决方案，再把这些解决方案通过平台的形式，提供给业务部门使用。 这里需要注意数据平台的发展是一个演进的过程，并不需要追求一开始就大而全，不同阶段采用的技术能匹配当时需求就好。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/:0:0","tags":null,"title":"大数据架构笔记-hadoop生态圈","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"（1）数据生成与采集——SDK、用户埋点 因为头条属于 C 端业务公司，主要以日志形式为主，数据的主要来源是用户行为，那么就采用事件模型来描述日志，以 SDK 形式接入，支持客户端、服务端埋点。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/:1:0","tags":null,"title":"大数据架构笔记-hadoop生态圈","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"（2）数据传输——Kafka 做消息总线连接在线和离线系统 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/:2:0","tags":null,"title":"大数据架构笔记-hadoop生态圈","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"（3）数据入库——数据仓库、ETL（抽取转换加载） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/:3:0","tags":null,"title":"大数据架构笔记-hadoop生态圈","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"（4）数据计算——计算引擎的演进 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/:4:0","tags":null,"title":"大数据架构笔记-hadoop生态圈","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"（5）数据门户——为业务的数据分析提供整体解决方案 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/:5:0","tags":null,"title":"大数据架构笔记-hadoop生态圈","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%84%E9%9C%80%E6%B1%82%E5%92%8C%E6%BC%94%E8%BF%9B%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"求职 简历要好好准备； 准备面试：先讲框架，再谈细节。优化细节，框架演化。 hadoop生态圈 从上往下，从底层往上层。 所有需要通过webserver提供服务。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:0:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"hadoop ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"3.0 新特性 Classpath isolation:增加此配置，防止不同版本jar包冲突。 Shell重写了。 支持HDFS中的擦除编码（Erasure Encoding）默认的EC策略可以节省50%的存储空间，同时还可以承受更多的存储故障。 DataNode内部添加了负载均衡（Disk Balancer）。 MapReduce任务级本地优化。 MapReduce内存参数自动推断。 基于cgroup的内存隔离和IO Disk隔离。 支持更改分配容器的资源Container resizing（内存和磁盘）。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"3.0默认端口发生变化（） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop Common ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"HDFS（分布式文件系统） 最底层 【存储】 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"YARN ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:5","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"MapReduce 【计算框架】 适用于离线的批量的数据计算。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:6","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"其他相关组件（独立项目） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Flume【日志收集工具】 Flume 是将数据从产生、传输、处理并最终写入目标路径的过程抽象为数据流，在具体的数据流中，数据源支持在 Flume 中定制数据发送方，从而支持收集各种不同协议数据。 Flume 数据流提供对日志数据进行简单处理的能力，如过滤、格式转换等。 Flume 还具有能够将日志写往各种数据目标（文件、HDFS、网络）的能力。在 Hadoop 平台，我们主要使用的是通过 Flume 将数据从源服务器写入 Hadoop 的 HDFS 上。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hbase（分布式数据库）【存储】 基于HDFS，数据还是存在于HDFS。 列存储。 最大优点是查询速度快，这对数据完整性要求不高的大数据处理领域，比如互联网，犹为重要。 非常适合需对数据进行随机读、写操作、比如每秒对PB级数据进行几千次读、写访问是非常简单的操作。 其次，Hbase构建在HDFS之上，其内部管理的文件全部存储在HDFS中。这使它具有高度容错性和可扩展性，并支持Hadoop mapreduce程序设计模型。 如果你的应用是交易历史查询系统、查询场景简单，检索条件较少、每天有千万行数据更新、那么Hbase将是一个很好的选择。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hive【SQL引擎】 本质是mapreduce。 将SQL转换到MapReduce上执行。 哪怕你不熟悉 MapReduce 程序，只要会写标准的 SQL 语句，也能对 HDFS 上的海量数据进行分析和计算。通常做统计。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Kafka【分布式消息队列】 最大特性就是可以实时的处理大量数据以满足各种需求场景：比如基于 Hadoop 平台的数据分析、低时延的实时系统、Storm/Spark 流式处理引擎等。 Kafka 现在它已被多家大型公司作为多种类型的数据管道和消息系统使用。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"mahout【机器学习】 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:5","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Oozie【工作流调度器】 Oozie 是一个基于工作流引擎的调度器，它其实就是一个运行在 Java Servlet 容器（如 Tomcat）中的 Javas Web 应用，你可以在它上面运行 Hadoop 的 Map Reduce 和 Pig 等任务，。 对于 Oozie 来说，工作流就是一系列的操作（如 Hadoop 的 MR，Pig 的任务、Shell 任务等），通过 Oozie 可以实现多个任务的依赖性。也就是说，一个操作的输入依赖于前一个任务的输出，只有前一个操作完全完成后，才能开始第二个。 Oozie 工作流通过 hPDL 定义（hPDL 是一种 XML 的流程定义语言），工作流操作通过远程系统启动任务。当任务完成后，远程系统会进行回调来通知任务已经结束，然后再开始下一个操作。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:6","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"pig Hive 可以把脚本和 SQL 语言翻译成 MapReduce 程序，扔给计算引擎去计算。Pig 与 Hive 类似，它定义了一种数据流语言，即 Pig Latin，它是 MapReduce 编程的复杂性的抽象. Pig Latin 可以完成排序、过滤、求和、关联等操作，支持自定义函数。Pig 自动把 Pig Latin 映射为 MapReduce 作业，上传到集群运行，减少用户编写 Java 程序的苦恼。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:7","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Spark【计算框架】 Spark 提供了内存中的分布式计算能力，相比传统的 MapReduce 大数据分析效率更高、运行速度更快。总结一句话：以内存换效率。 批量计算，spark core 实时计算， stream 还可以机器学习， mllib 还可以SQL ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:8","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Sqoop 通过 Sqoop（SQL-to-Hadoop）主要用于传统数据库和 Hadoop 之间传输数据。数据的导入和导出本质上是 MapreDuce 程序，充分利用了 MR 的并行化和容错性。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:9","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Storm【计算框架】【渐渐过时】 实时计算。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:10","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"zookeeper 集群管理，分布式锁服务 ZooKeeper 相当于一个和事佬的角色，如果两人之间发生了一些矛盾或者冲突，无法自行解决的话，这个时候就需要 ZooKeeper 这个和事佬从中进行调解，而和事佬调解的方式是站在第三方客观的角度，根据一些规则（如道德规则、法律规则），客观的对冲突双方做出合理、合规的判决。 节点丢失或重启，都会发起选举。 常见业务 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:11","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"搜索 搜索内容； 提供服务。 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"广告 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"推荐 职业方向 学习路线 雨雀文档 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Java SE核心知识（第一阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Java编程概述及基本语法 Java技术体系平台 Java核心机制与JVM运行原理 Java开发环境搭建 Java变量、数据类型、数组及运算符 Java流程控制结构 面向对象编程 高级类特性 Java API、异常机制、反射及IO流 Lambda表达式 函数式接口 ###Java集合与泛型 集合框架概述 Collection 系列集合 List系列集合与Set系列集合 Iterator 与 ListIterator Collections 工具类 集合中使用泛型 自定义泛型 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Java多线程技术 线程的原理 线程的创建与启动 创建线程的几种方式对比 继承 Thread 类与实现 Runnable 接口 创建线程方式对比 线程的控制 线程的调度 线程的优先级 线程的生命周期 多线程的安全问题与解决办法 线程的同步 互斥锁 线程的死锁问题 线程通信 生产者与消费者案例 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Java SE网路编程 网络编程基础知识 网络编程的主要问题 如何实现网络中主机的相互通讯 网络通讯要素 网络通信协议 OSI参考模型 TCP/IP参考模型(或TCP/IP协议) 数据的封装与拆封 Java.net.InetAddress 类 TCP 协议与UDP协议 基于TCP协议的网络编程 Socket 的TCP编程 基于UDP协议的网络编程 URL编程 针对HTTP协议的URLConnection ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Java Web数据可视化（第二阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Java Web 后端技术 Tomcat\u0026Nginx服务器中间件 Servlet规范组件 Ajax\u0026Json轻量级数据交互 Maven项目构建工具 Preformance 工具的使用及注意事项 Git项目协作工具 Spring依赖管理框架 SpringMVC表现层框架 Mybatis持久层框架 分布式架构理论 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"前端可视化技术 XML可扩展标记语言 HTML、CSS、JavaScript静态化技术 Jquery、Vue脚本框架 ECharts可视化组件 FusionCharts可视化组件 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"关系型数据库MySQL高级应用 MySQL基础 MySQL数据库对象 SQL结构化查询语言 JDBC操作 MySQL查询和慢查询日志分析 MySQL调优之索引优化 MySQL调优之存储引擎优化 MySQL调优之锁机制优化 MySQL高可用 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Linux 服务器应用实战 Linux系统基础 Linux网络基础 Linux安全策略 Shell编程基础及应用 Linux运维技巧 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"拉勾网招聘行业报表数据可视化项目实战 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:5","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop核心及生态圈技术栈（第三阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop核心之分布式文件系统HDFS 大数据概述 Hadoop概述 Apache Hadoop完全分布式集群部署 HDFS简介及应用场景 HDFS原理详解 HDFS Shell 操作 HDFS Java API 操作 HDFS原理输入及调优 双缓冲机制 HDFS源码剖析、设计模式及二次开发 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop核心之分布式计算框架MapReduce MapReduce设计目标及核心思想 MapReduce主要功能 MapReduce处理流程 MapReduce入门案例 Mapper抽象类与Reducer抽象类 MapReduce内置数据类型及自定义数据类型 如何确定Map和Reduce个数 MapReduce Shuffle过程之Combine合并机制 MapReduce Shuffle过程之Partition分区机制、自定义分区 MapReduce Shuffle之序列化 MapReduce Shuffle过程之自定义排序及二次排序 MapReduce Shuffle过程之数据压缩机制 自定义InputFormat及OutputFormat MapReduce生产级调优 MapReduce案例实战 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop核心之分布式资源调度框架Yarn 分布式资源调度及Yarn简介 Yarn架构及原理 Yarn核心组件之ResourceManager 资源管理器 Yarn核心组件之NodeManager 节点管理器 Yarn核心组件之Application Master 任务专员 Yarn核心组件之Container 容器 Yarn资源调度FIFO策略和应用 Yarn资源调度Fair策略和应用 Yarn资源调度Capacity策略和应用 Yarn多租户资源调度配置 Yarn生产级调优 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop生态圈技术栈（上） 数据仓库Hive高级应用 ETL转换抽取工具Sqoop ETL转换抽取工具CDC ETL转换抽取工具DataX 数据采集工具Flume 分布式协调服务组件ZooKeeper 海量列式非关系型数据库HBase ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop生态圈技术栈（下） 海量列式非关系型数据库HBase SQL语义级查询系统Impala 任务调度组件Oozie 任务调度组件Azkaban 任务调度组件airflow ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:5","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"分布式缓存Redis及Kafka消息中间件（第四阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"高性能分布式缓存Redis NoSQL\u0026Redis入门 分布式数据库CAP原理 Redis五大数据类型和基本操作命令 Redis总体配置Redis.conf Redis持久化（RDB和AOF） Redis事务控制 Redis发布和订阅 Redis（Master/Slave）主从复制 Java客户端Jedis 通讯协议及事件处理机制 Redis + Lua环境协作组件 Redis慢查询及监视器 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"高吞吐消息中间件Kafka Kafka架构 Kafka安装及高级应用 Kafka生产者原理 Kafka broker端原理 Kafka 集群 Kafka消费者源码剖析 Kafka深度调优 Flume+Kafka整合应用 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"PB级电商离线数仓项目实战（第五阶段） 大数据数据仓库实战项目-电商数仓教程V3.0最新版 数仓分层建设及理论梳理 数仓建设痛点剖析 数据血缘管理机制 质量监控策略 离线数仓全流程性能优化方案 电商行业离线数仓业务真实级源码构建与剖析 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"内存级快速计算引擎Spark（第六阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Scala编程 Scala基础 Scala控制结构和函数 Scala数组相关操作 Scala映射和元组 Scala继承、特质、高阶函数 Scala集合 Scala模式匹配和样例类 Scala偏函数 Scala Future及类型参数 Scala 高级类型 Scala 隐式转换和隐式参数 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Spark实战应用 Spark Core核心 Spark SQL结构化处理 Spark Streaming流处理 Spark GraphX图挖掘 Spark MLib机器学习 Spark综合案例实战 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"智慧物流项目（第七阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"数据采集 Flume/Maxwell ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"仓库缺货-销量预测 LigthGBM模型算法 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"运输车辆调度 动态规划算法 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"车辆位置/指标实时监控 实时指标Redis存储 SparkStreaming消费一致性，Exactly Once解决方案 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"轨迹回放 HBase海量历史数据存储 HBase应用及优化 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:5","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"多维度业务指标看板 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:6","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"实时计算领域最锋利的武器Flink（第八阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Flink基础 Flink 的应用场景和架构模型 Flink 入门程序 WordCount 和 SQL 实现 Flink 的编程模型与其他框架比较 Flink 常用的 DataSet 和 DataStream API Flink SQL \u0026 Table 编程和案例 Flink 集群安装部署和 HA 配置 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Flink进阶 Flink 常见核心概念分析 Flink 窗口、时间和水印 Flink 状态与容错 Flink Side OutPut 分流 Flink CEP 复杂事件处理 Flink 常用的 Source 和 Connector ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Flink高级实践及调优 Flink 高可用配置 Flink Exactly-once 实现原理解析 Flink反压问题排查 Flink数据倾斜问题处理 Flink并行度和资源设置 Flink生产环境作业监控 Flink维表关联方案 Flink海量数据高效去重 Flink与Kafka的整合 Flink 中 watermark 的定义和使用 Flink 中的聚合函数和累加器的设计和使用 自定义消息事件及Pattern ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Flink综合案例实战 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"大数据新技术实践（第九阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"OLAP列式数据库管理系统ClickHouse ClickHouse简介及应用场景 ClickHouse架构及原理 ClickHouse数据类型 ClickHouse列设计 ClickHouse物化列\u0026表达式列 ClickHouse实战案例 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"新型列式存储分布式数据库Kudu Kudu 简介及应用场景 Kudu 的高层设计 Kudu 中的角色 Kudu 中的概念与机制 Kudu 安装部署 Kudu 管理 Kudu操作接口 Kudu性能调优 Kudu实战案例 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"开源的分布式分析引擎Kylin Kylin的工作原理 Kylin的技术架构 Kylin的主要特点 Kylin快速入门 Cube优化 增量构建 查询和可视化 Cube Planner及仪表盘 流式构建 Kylin实战案例 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:3","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"实时统计分析开源数据存储Druid Druid原理及部署 Druid数据摄入 Druid客户端 Druid实战案例 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:4","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Elastic Stack 日志搜索、挖掘及可视化解决方案（第十阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:15:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Elasticsearch全文搜索引擎 认识全文搜索引擎 倒排索引机制 全文搜索引擎Elasticsearch介绍 Elasticsearch Single-Node Mode快速部署 Elasticsearch之入门使用 Elasticsearch之高级应用 Elasticsearch之企业级高可用分布式集群 Elasticsearch之数据模型构建 Elasticsearch之拉勾网亿级数据量搜索实战 Elasticsearch之深度应用及原理剖析 Elasticsearch 7.x分布式集群调优策略 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:15:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Logstash采集、Kibana展示方案 Intput插件应用及原理 自定义Intput插件 Filter插件 自定义Filter过滤插件 Output插件应用及原理 自定义Output插件 Kibana可视化组件 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:15:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"电商行业实时数仓项目（第十一阶段） Flink流式处理技术构建复杂的电商订单指标 ClickHouse快速电商业务查询 数据完整处理链条展现 电商大促峰值数据大数据解决方案 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:16:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Hadoop/Spark大数据处理算法及案例（第十二阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:17:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"大数据处理算法及案例（上） K-均值算法 KNN算法 朴素贝叶斯 马尔可夫链 推荐算法 成对文档相似性 算法案例实战应用 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:17:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"大数据处理算法及案例（下） 线性回归 Cox回归 皮尔逊（Pearson）相关分析 社交网络分析之推荐系统 社交网络分析之三角形计数 社交网络分析之情感分析 算法案例实战应用 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:17:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"机器学习（第十三阶段） ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:18:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Python 编程核心 交互式解释器 Python基础语法 Python面向对象 Python数据结构 Anaconda工具使用 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:18:1","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"Python编程实战 PySpark Python与SparkSql整合 Python与SparkStreaming整合 Python+SparkMllib机器学习实战项目 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:18:2","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"人才用户画像匹配系统（第十四阶段） 用户建模确定特征维度 标签分类及标签库设计 ETL计算 特征处理 推荐算法模型处理，人才和企业精准对接 ","date":"2019-12-10","objectID":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:19:0","tags":["大数据"],"title":"大数据架构笔记-hadoop生态圈-学习路线","uri":"/post/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-0-hadoop%E6%A6%82%E8%A7%88%E5%8F%8A%E7%94%9F%E6%80%81%E5%9C%88%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"演化 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:0:0","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"云原生 参考云原生架构概述 参考云原生应用：更快交付，降低风险，拓展业务 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:1:0","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"CNCF组织 在讲云原生之前，我们先了解一下CNCF，即云原生计算基金会，2015年由谷歌牵头成立，基金会成员目前已有一百多企业与机构，包括亚马逊、微软。思科等巨头。 目前CNCF所托管的应用已达14个，其公布的Cloud Native Landscape，给出了云原生生态的参考体系。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:1:1","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"云原生 CNCF给出了云原生应用的三大特征： a. 容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用，简化云原生应用程序的维护。在容器中运行应用程序和进程，并作为应用程序部署的独立单元，实现高水平资源隔离。 b. 动态管理：通过集中式的编排调度系统来动态的管理和调度。 c. 面向微服务：明确服务间的依赖，互相解耦。 云原生包含了一组应用的模式，用于帮助企业快速，持续，可靠，规模化地交付业务软件。云原生由微服务架构，DevOps 和以容器为代表的敏捷基础架构组成。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:1:2","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"The Twelve Factors 12-Factors经常被直译为12要素，也被称为12原则，12原则由公有云PaaS的先驱Heroku于2012年提出（https://12factor.net/），目的是告诉开发者如何利用云平台提供的便利来开发更具可靠性和扩展性、更加易于维护的云原生应用。具体如下： a. 基准代码 a. 显式声明依赖关系 a. 在环境中存储配置 a. 把后端服务当作附加资源 a. 严格分离构建、发布和运行 a. 无状态进程 a. 通过端口绑定提供服务 a. 通过进程模型进行扩展 a. 快速启动和优雅终止 a. 开发环境与线上环境等价 a. 日志作为事件流 a. 管理进程 另外还有补充的三点： a. API声明管理 a. 认证和授权 a. 监控与告警 距离12原则的提出已有五年多，12原则的有些细节可能已经不那么跟得上时代，也有人批评12原则的提出从一开始就有过于依赖Heroku自身特性的倾向。不过不管怎么说，12原则依旧是业界最为系统的云原生应用开发指南。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:1:3","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"无服务(serverless) 参考什么是Serverless无服务器架构？ 架构体系 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:2:0","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"服务发现 参考微服务中的服务发现 服务实例需要动态分配网络地址，而且，一组服务实例可能会因为自动扩展、失败或者升级发生动态变化，因此 你的客户端代码应该使用更加精细的服务发现机制。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:3:0","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"客户端发现模式 服务实例的网络地址在服务启动的时候被登记到服务注册表中 ，当实例终止服务时从服务注册表中移除。服务实例的注册一般是通过心跳机制阶段性的进行刷新。 优点：该模式除了服务注册表之外没有其他的活动部分了，相对来说还是简单直接的，而且，由于客户端知道相关的可用服务实例，那么就可以使用更加智能的，特定于应用的负载均衡机制，比如一致性哈希（客户端和负载均衡在同一个主机）。 缺点：客户端与服务注册表紧耦合了，你必须为每一种消费服务的客户端对应的编程语言和框架实现服务发现逻辑。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:3:1","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"服务端发现模式 客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。和客户端发现一样，服务实例通过服务注册表进行服务的注册和注销。 优点：服务发现的细节对客户端来说是抽象的，客户端仅需向负载均衡器发送请求即可。一些部署环境已经提供了该功能。比如K8S。 缺点：除非部署环境已经提供了负载均衡器，否则这又是一个需要额外设置和管理的可高可用的系统组件。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:3:2","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"服务注册表 服务注册表 是服务发现的关键部分，它是一个包含服务实例网络地址的的数据库。一个服务注册表需要高可用和实时更新，客户端可以缓存从服务注册表获取的网络地址。然而，这样的话缓存的信息最终会过期，客户端不能再根据该信息发现服务实例。因此，服务注册表对集群中的服务实例使用复制协议来维护一致性。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:3:3","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"服务的注册和注销 服务实例自己注册自己(self-registration 模式) 服务实例自己负责通过服务注册表对自己进行注册和注销，另外如果有必要的话，服务实例可以通过发送心跳请求防止注册过期. 优点:相对简单，而且不强制使用其他的系统组件。 缺点:它使得服务实例和服务注册表强耦合 ，你必须在每一个使用服务的客户端编程语言和架构代码中实现注册逻辑。 系统的其他组件管理服务实例的注册(third-party registration 模式) 服务实例本身并不负责通过服务注册表注册自己，相反的，通过另一个被称作 service registrar系统组件来处理注册。 service registrar通过轮询或者订阅事件来检测一些运行实例的变化，当它检测到一个新的可用服务实例时就把该实例注册到服务注册表中去，service registrar还负责注销已经被终止的服务实例. 优势:使得服务从服务注册表中被解耦，你不必为开发者使用的每种开发语言和框架实现服务注册的逻辑，相反，服务实例的注册被一个专有服务以集中式的方式处理。 缺点:它被内置在部署环境中，不然这又是一个需要被设置和管理的高可用系统组件。 ","date":"2019-11-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/:3:4","tags":null,"title":"微服务架构笔记-架构历史及架构","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"需求（可实现的功能） ","date":"2019-11-15","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/:1:0","tags":null,"title":"产品设计-站内信","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/"},{"categories":null,"content":"基本功能 点到点的消息传送：用户给用户发送站内信，管理员给用户发送站内信； 点到面的消息传送：管理员给用户群发消息。 ","date":"2019-11-15","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/:1:1","tags":null,"title":"产品设计-站内信","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/"},{"categories":null,"content":"具体的场景 企业公告通知：应用场景较广，便捷性较强，当企业存在公告类内容，可及时进行全量或定量推送，让平台内的用户知悉； 企业营销类活动：主要适用于电商类企业，可根据用户属性不定期进行推送营销类活动通知，提高活动传播度和收益。 企业助手相关通知：如交易、物流、收发货等通知，一方面用户能及时知晓商品的第一动向，另外也能在一定程度上减少企业的短信成本。 用户资产信息通知：如积分变动、优惠券到期前通知，凸显用户资产信息重要性的同时，又唤醒沉默用户进行消费优惠券，从而促进订单转化。 用户间互动：如私信、问答、评论、点赞、回复，提高平台内用户活跃度，从而形成用户之间主动互动的良性循环。 订阅通知：主要针对用户自主定制的内容类通知，减少用户错过自己感兴趣的内容。 ","date":"2019-11-15","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/:1:2","tags":null,"title":"产品设计-站内信","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/"},{"categories":null,"content":"实现 “站内信”的实现，主要是通过数据库插入记录来实现的。 参考关于站内信的开发思路. 参考站内信的实现思路表的设计. ","date":"2019-11-15","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/:2:0","tags":null,"title":"产品设计-站内信","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/"},{"categories":null,"content":"思想 面向百万用户量，但是低活跃的情况，需要用户登录之后，自己拉去属于自己的消息。 站内信应该有生命周期。 ","date":"2019-11-15","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/:2:1","tags":null,"title":"产品设计-站内信","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%AB%99%E5%86%85%E4%BF%A1/"},{"categories":null,"content":"解决的问题 将日志统一收集到一个地方集中管理(统一收集、过滤清洗)。 处理日志，输出运维、研发可用的数据（可视化界面、监控、告警、日志搜索）。 满足【开发、运维、运营】功能需求（实时看日志、统计历史日志、实时行为分析[流式计算]、用户轨迹跟踪等）、性能需求（具有高吞吐能力、高扩展性、高容错性）等 组件 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:0:0","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"消息队列 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:1:0","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Kafka 一种高吞吐量的分布式发布订阅消息系统，它适合处理海量日志发布订阅，提供消息磁盘持久化、支持物理分片存储、多组消费等特性。 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:1:1","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"日志采集 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:2:0","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Elastic APM ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:2:1","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Filebeat ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:2:2","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Flume 一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，它支持在日志系统中定制各类数据发送方，用于【收集数据】；同时提供对数据进行简单处理【过滤】，并写到各种数据接受方（可定制）【分发】。 【缺点】 java 开发的，会比较占用机器资源。 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:2:3","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Prometheus ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:2:4","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"rsyslog The rocket-fast system for log processing ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:2:5","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"搜索引擎 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:3:0","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Elasticsearch 一个开源实时分布式搜索引擎，具备如下特征：零配置，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:3:1","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"可视化 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:4:0","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Grafana ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:4:1","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Kibana 思路 【日志接入】开发业务日志SDK（下文为描述方便，称之为 BizLogSDK），嵌于各业务App；或者Http请求。 【日志缓冲】从业务服务端收集日志并集中输出到Kafka； 根据不同需求（查询、统计），由Flume对数据预处理并分发； Flume 的下游组件对日志内容进行消费； 架构 ","date":"2019-11-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/:4:2","tags":["微服务","日志平台，ELK"],"title":"微服务架构笔记-08-中间件-日志平台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-08-%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"与微服务 服务化的本质是“分治”（服务拆分、服务治理）。 服务化的模式比如SOA、ESB、微服务等。 高内聚、低耦合。 ","date":"2019-11-06","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"分布式-概念（与微服务的关系）","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"与中间件 中间件起到的是标准化的作用； 中间件只是起到承载这些标准化想法的介质、工具，可以起到引导和约束的效果，以此起到大大降低系统复杂度和写作成本的作用； MQ框架标准化了不同应用程序间非实时异步通讯的方式； RPC框架标准化了不同应用程序间实时通讯的方式； DAL（Data Access Layer，数据访问层）框架标准化了应用程序和数据库之间通讯的方式。 识别相对稳定的部分是什么，如何把他们提炼出来，并且围绕这些点进行标准化，才是我们需要掌握的，建立中间件的能力。 ","date":"2019-11-06","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"分布式-概念（与微服务的关系）","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"分布式系统包含前两者（涉及多个进程协作才能提供一个完整功能的系统都是） ","date":"2019-11-06","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"分布式-概念（与微服务的关系）","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/"},{"categories":["算法","数据科学"],"content":"开始机器学习","date":"2019-11-06","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/","tags":["算法","机器学习"],"title":"数据科学-面经整理","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"},{"categories":["算法","数据科学"],"content":"目标 不能零零散散地自学，必须系统化学习。 对算法原理公式推导理解深刻、熟悉用法、并且知道工业界算法模型如何落地应用。 ","date":"2019-11-06","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/:1:0","tags":["算法","机器学习"],"title":"数据科学-面经整理","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"},{"categories":["算法","数据科学"],"content":"算法原理的基础知识和应用场景 ","date":"2019-11-06","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/:2:0","tags":["算法","机器学习"],"title":"数据科学-面经整理","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"},{"categories":["算法","数据科学"],"content":"主流的算法 ","date":"2019-11-06","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/:2:1","tags":["算法","机器学习"],"title":"数据科学-面经整理","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"},{"categories":["算法","数据科学"],"content":"应用场景 NLP Bert，Attention机制； 搜索推荐 storm 机器学习算法 GBDT必问； Xgboost； LR； 决策树； 常见机器学习模型的损失函数。 ","date":"2019-11-06","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/:2:2","tags":["算法","机器学习"],"title":"数据科学-面经整理","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"},{"categories":null,"content":"MYSQL基本教程 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:0:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"面试必备（原理） 数据库解决全量IO的问题。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:1:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"事务隔离 在数据库系统中，事务隔离级别(isolation level)决定了数据在系统中的可见性。隔离级别从低到高分为四种：未提交读(Read uncommitted)，已提交读(Read committed)，可重复读(Repeatable read)，可串行化(Serializable)。他们的区别如下表所示。 隔离级别 脏读 不可重复读 幻读 未提交读(RU) 可能 可能 可能 已提交读(RC) 不可能 可能 可能 可重复读(RR) 不可能 不可能 可能 可串行化 不可能 不可能 不可能 脏读(dirty read)是指一个事务可以读到其他事务还未提交的数据。不可重复读(non-repeatable read)是指在一个事务中同一行被读取了多次，可以读到不同的值。幻读(phantom read)是指在一个事务中执行同一个语句多次，读到的数据行发生了改变，即可能行数增加了或减少了。对于MySQL来说，默认的事务隔离级别是RR，通过上表我们可知RR是可重复读的，因此可以解释这个现象。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:1:1","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"索引 数据存在磁盘上的data page（默认4K）中。（分治） 建表之前创建schema，指定字段类型（实际上是空间），是为了确定表中每一行的长度。方便查找。 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 建立索引的字段必须是数据表中最常用来查询（where）的字段。 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 缺点过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。 索引也是数据，也需要查询，大了之后也需要提高速度。这个时候有一个B+数。树干在内存，树叶在磁盘。 因为有了索引，数据表变大了，查询不一定会变慢。WHERE只有索引，是不会慢的。但是并发量比较大，查询比较复杂，速度还是比较慢的（磁盘IO影响）。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:1:2","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"MYSQL配置及优化 配置项 描述 默认值 wait_timeout wait_timeout过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放，拖累系统性能，不过也不能把这个指设置的过小，否则你可 能会遭遇到“MySQL has gone away”之类的问题 max_connections 最大连接数.并法高，调高此值；但是会消耗内存，合适的值（SHOW STATUS LIKE ‘max%connections’;max_used_connections / max_connections * 100% （理想值≈85%）） 151 back_log 如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log 默认值是80，最多512，可设置为128 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:2:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"MYSQL优化 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:3:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"数据库云 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:4:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"RDS(Aliyun) RDS for MySQL 物理备份文件恢复到自建数据库; 数据同步方案概览 跨阿里云账号迁移RDS实例 如需执行增量数据迁移(或者数据同步)，需开启Binlog并满足以下要求： binlog_format设置为row。 binlog_row_image设置为full。 Binlog日志应至少保留24小时（建议3天以上）。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:4:1","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"SQL语句 mysql的创建表的语句后面有auto_increment=4.AUTO_INCREMENT=n命令来重设自增的起始值。但是如果设置的n比目前的数值小的话，执行的sql不会报错，但是不会生效！ \u003c\u003e 不相等 in 在区间 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:5:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"常用操作 删除字段：ALTER TABLE table_NAME DROP COLUMN column_NAM ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:5:1","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"联查JOIN SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 普通的用法：SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons, Orders WHERE Persons.Id_P = Orders.Id_P 。 默认使用inner join，INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “Persons” 中的行在 “Orders” 中没有匹配，就不会列出这些行。 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons INNER JOIN Orders ON Persons.Id_P = Orders.Id_P ORDER BY Persons.LastName 使用left join, LEFT JOIN 关键字会从左表 (Persons) 那里返回所有的行，即使在右表 (Orders) 中没有匹配的行。 使用right join, RIGHT JOIN 关键字会从右表 (Orders) 那里返回所有的行，即使在左表 (Persons) 中没有匹配的行。 受用full join,FULL JOIN 关键字会从左表 (Persons) 和右表 (Orders) 那里返回所有的行。如果 “Persons” 中的行在表 “Orders” 中没有匹配，或者如果 “Orders” 中的行在表\"Persons” 中没有匹配，这些行同样会列出。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:5:2","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"模糊查询 SELECT 字段 FROM 表 WHERE 某字段 Like 条件 条件 %表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。 _ 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。 [ ] 表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围（使用-），要求所匹配对象为它们中的任一个。 [^ ] 表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。 由于通配符的缘故，导致我们查询特殊字符”%\"、\"_\"、\"[“的语句无法正常实现，而把特殊字符用” “括起便可正常查询。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:5:3","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"HAVING子句 在SELECT语句中使用HAVING子句来指定一组行或聚合的过滤条件。 HAVING子句通常与GROUP BY子句一起使用，放在其后，以根据指定的条件过滤分组之后的结果。如果省略GROUP BY子句，则HAVING子句的行为与WHERE子句类似。 请注意，HAVING子句将过滤条件应用于每组分行，而WHERE子句将过滤条件应用于每个单独的行。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:5:4","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"设计规范 参考MySQL数据库设计规范 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:6:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"表结构 建议表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。 建议反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如user_name属性在user_account，user_login_log等表里冗余一份，减少join查询。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:6:1","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"线上禁止使用的SQL语句 强制禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:6:2","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"官方docker镜像 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:7:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"配置 默认的配置文件/etc/mysql/my.cnf。 自定义配置文件 启动参数 可以使用command指定启动参数。 version: '3.1' services: db: image: mysql command: --default-authentication-plugin=mysql_native_password restart: always ports: - '3306:3306' environment: MYSQL_ROOT_PASSWORD: example volumes: - ./db_data:/var/lib/mysql:Z adminer: image: adminer restart: always ports: - 8080:8080 环境变量 注意，如果用一个已经包含数据库的数据目录启动容器，那么下面的变量都不会有任何影响:在容器启动时，任何预先存在的数据库都不会改变。 MYSQL_ROOT_PASSWORD 强制性的，设置root超级用户的密码 MYSQL_DATABASE 可选的，指定镜像启动时，创建的数据库名称 MYSQL_USER, MYSQL_PASSWORD 可选的，用于创建上述数据库的用户和密码 MYSQL_ALLOW_EMPTY_PASSWORD 可选的（yes），允许可以不设置root密码，不建议，不安全 MYSQL_RANDOM_ROOT_PASSWORD 可选的（yes），设置root一个随机密码，会在stdout打印 (GENERATED ROOT PASSWORD: .....). MYSQL_ONETIME_PASSWORD 设置root一次性密码，登录之后必须修改 MYSQL_INITDB_SKIP_TZINFO 任何非空值，禁用时区加载 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:7:1","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"存储 默认存储路径/var/lib/mysql. ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:7:2","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"首次启动 首次启动容器时，将创建一个具有指定名称的新数据库，并使用提供的配置变量对其进行初始化。 此外，它将执行在/docker-entrypoint-initdb.d中找到的扩展名为.sh，.sql和.sql.gz的文件。 文件将按字母顺序执行。 You can easily populate your mysql services by mounting a SQL dump into that directory and provide custom images with contributed data. 默认情况下，SQL文件将导入到MYSQL_DATABASE变量指定的数据库中。 ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:7:3","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"答疑解惑 删除数据的时候可能会出现MYSQL SAFE UPDATE MODE； 1273 - Unknown collation: ‘utf8mb4_0900_ai_ci’; RDS MySQL出现“OPERATION need to be executed set by ADMIN”报错 可以使用mysql workbench来导出和导入数据,注意需要删除AUTO_INCREMENT=321属性。 解决MySQL报错：[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains no… 微信昵称emoji表情 原因：MySQL的utf8编码方式的数据为三个字节。MySQL的utf8编码改为utf8mb4编码方式。 解决方法： 1. 查看数据库是否支持，SHOW CHAR SET WHERE Charset LIKE \"%utf8%\"; 2. 修改数据库支持：ALTER DATABASE [$Database] CHARACTER SET [$Character_Set] COLLATE [$Collation_Name]; 3. 修改表支持：ALTER TABLE [$Table] CONVERT TO CHARACTER SET [$Character_Set] COLLATE [$Collation_Name]; 4. 重启： ","date":"2019-10-21","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/:8:0","tags":["数据库","MySQL"],"title":"后端-数据库-MYSQL","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%8C%E5%BC%8F-mysql/"},{"categories":null,"content":"搜索引擎规则 ","date":"2019-10-21","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/:0:0","tags":null,"title":"产品设计-开源产品","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"categories":null,"content":"Robots协议 爬虫的\"盗亦有道”-Robots协议. Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots ExclusionProtocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取. 根据协议，网站管理员可以在网站域名的根目录下放一个robots.txt 文本文件，里面可以指定不同的网络爬虫能访问的页面和禁止访问的页面，指定的页面由正则表达式表示。网络爬虫在采集这个网站之前，首先获取到这个文件，然后解析到其中的规则，然后根据规则来采集网站的数据。 注意，这个协议的存在更多的是需要网络爬虫去遵守，而起不到防止爬虫的功能。 ","date":"2019-10-21","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/:1:0","tags":null,"title":"产品设计-开源产品","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"categories":null,"content":"方便爬取，提升搜索 设置title; ","date":"2019-10-21","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/:2:0","tags":null,"title":"产品设计-开源产品","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"categories":null,"content":"注意事项 只有企业可注册微信开放平台。 ","date":"2019-10-12","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/:1:0","tags":null,"title":"小程序-微信小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"集成腾讯接口 ","date":"2019-10-12","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/:2:0","tags":null,"title":"小程序-微信小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"AI类 微信OCR识别 五官定位 人脸检测与分析 ","date":"2019-10-12","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/:2:1","tags":null,"title":"小程序-微信小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"安全类 珊瑚图片内容安全 珊瑚文本内容安全 ","date":"2019-10-12","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/:2:2","tags":null,"title":"小程序-微信小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"地图类 逆地址解析 地址解析 关键词输入提示 驾车路线规划 步行路线规划 坐标转化 地点搜索 ","date":"2019-10-12","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/:2:3","tags":null,"title":"小程序-微信小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"内容类 腾讯云正版曲库直通车 ","date":"2019-10-12","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/:2:4","tags":null,"title":"小程序-微信小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"参考阿里巴巴为什么不用 ZooKeeper 做服务发现？ 优点 阿里巴巴中间件内部也维护了一个面向大规模生产的、高可用、更易监控和运维的 ZooKeeper 的代码分支 TaoKeeper，如果以我们近 10 年在各个业务线和生产上使用 ZooKeeper 的实践，给 ZooKeeper 用一个短语评价的话，那么我们认为 ZooKeeper 应该是 “The King Of Coordination for Big Data”！ 可以使用 ZooKeeper，但是大数据请向左，而交易则向右，分布式协调向左，服务发现向右。 缺点 ","date":"2019-10-11","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper/:0:0","tags":null,"title":"微服务架构笔记-分布式-ZooKeeper","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper/"},{"categories":null,"content":" 在传统的前台-后台架构中，各个项目相对独立，许多项目都在重复发明同样的轮子，即让项目本身越来越臃肿，也让开发效率越来越低。 为提高开发效率，我们有必要整合出一个中间组织，为所有的项目提供一些公共资源。而这个中间组织，就是人们所说的“中台”。 适合从N到N+1的非创业公司。 ","date":"2019-10-10","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/:0:0","tags":null,"title":"微服务架构笔记-中台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/"},{"categories":null,"content":"大中台，小前台 前台即包括各种和用户直接交互的界面，比如web页面，手机app；也包括服务端各种实时响应用户请求的业务逻辑，比如商品查询、订单系统等等。 ","date":"2019-10-10","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/:1:0","tags":null,"title":"微服务架构笔记-中台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/"},{"categories":null,"content":"业务中台 各个项目的共通业务进行下沉，整合成通用的服务平台。 搜索中心 支付中心 商品中心 用户中心 可以认为是一个基于微服务的类SAAS的综合身份管理中心，主要给公司平台内的业务系统使用。 参考业务中台建设系列（一）：用户中台V1 需求 To B 统一管理下属账号，创建账号和注销账号； 统一管理下属权限，避免越权接触数据或越权操作等； 统一认证，所有系统只需要登录一次； 统一审计，记录下属所有操作日志。 组织如何注册。 组织如何实名。 组织如何登录（组织管理员如何登录） 员工怎么登录，手机密码、手机短信验证码、第三方登录（微信、QQ、微博等）、账号名称/ID。 怎么创建、删除、禁用员工账号。 管理员怎么邀请员工加入到这个虚拟“组织”。 组织如何分配员工权限（控制访问）。 To C 需要登录么 怎么登录，手机密码、手机短信验证码、第三方登录（微信、QQ、微博等） 怎么注册，手机号注册、邮箱注册 怎么能够注销账号 是否需要实名，如何实名 解决方案 业内其实有很成熟的解决方案，比如4A管理和IAM。 4A管理：集中账号管理（Account）、集中认证管理（Authentication）、集中授权管理（Authorization）和集中审计管理（Audit） IAM：Identity and Access Management，即身份识别与访问管理 设计思路 资源：（Resources页面、菜单、按钮、订单等）在各个业务系统中。 权限： 访问和操作资源的许可（Permit删除、编辑、审批等）。 角色： 角色也可以理解是权限的集合，是众多权限颗粒组成。【角色是与业务系统关联，业务系统限定了用户的角色】。 用户： 系统实际的操作员（User） 操作权限： 【页面权限】即用户登录系统可以看到的页面，由菜单来控制，菜单包括一级菜单或多级菜单。当系统赋予用户对应菜单的权限，那么用户就可以访问对应的菜单页面。【操作权限】：即页面的功能按钮，包括：查看、新增、修改、删除、审核等。当用户点击按钮时，系统将会校验用户的是否包含次操作权限，如果有，就可以进行下一步操作。【数据权限】 ：数据权限就是用户在同一页面看到的数据是不同的。 注意：在用户中台中，资源归属于各业务系统，但权限（权限控制）却是属于用户中台！ 用户可以属于1个组织也可以属于多个组织，这些组织之间可以是相关联（比如集团公司和子公司），也可以不关联。 【】【各个系统使用独立的组织（指组织机构）】，这样会更灵活一些。（有的业务系统需要组织架构来划分各种权限尤其是数据类权限） 平台的账号分为两类，一类是个人账号，一类是组织账号（组织有政府机构、企业、社会团体等）。个人账号非常常见，全部的C端应用和部分B端应用都是基于个人账号体系的。 账号体系 组织账号的实现上其实有两种方式：一种是为组织创建独立的账号（曾经在政府OA系统中设计过）；一种是将个人账号绑定到组织进而通过个人账号来登录。后者在平台中非常常见，比如各类SAAS平台. 在授权方面，个人账号和组织账号并无区别。 权限管理 用户中台的权限体系是基于RBAC概念，这个RBAC是【基于资源】的RBAC而非基于角色的RBAC。 各业务系统的权限是相互独立的，没有依赖关系。 业务系统的权限遵从于基于资源的RBAC。 数据权限受限于数据规则 权限并集：与 RBAC2 的静态职责分离-角色互斥原则相反，平台采用多角色权限取并集的设计。即在某个业务系统中，用户可以拥有多个角色。此时用户在该业务系统的权限等于各角色权限的并集 为满足以上几点，权限体系中必须有系统标识；数据资源权限中不仅有组织标识，还必须要有部门标识和创建者标识，部门标识和创建者主要是便于区分消费者和生产者。 用户组和角色组。 总结 个人账户统一原则：个人账户一次注册，全平台通用，类似于全网通行证和 SSO。 业务权限独立原则：每个子系统的权限体系是独立的，但是由用户中台统一管理维护。『个人账户统一原则』明确了账户体系是统一的，但是对于每个子系统而言，每个账户所能使用的功能和服务，所能查看的数据权限是独立维护的。 组织实体隔离原则：不同的组织实体之间，是相互隔离，独立管理的。每个组织实体可以自行组织自己的组织体系、账户体系和权限体系。不同的组织实体资源权限也是隔离的。 从属关系隔离原则：个体账户与组织实体的从属关系是基于单独的业务系统存在的，『个人账户统一原则』明确的仅是个人账户的全网统一，但组织实体、从属关系并没有统一，并且是隔离的。 如果要简化从属关系的管理，那么可以不遵循此原则，即个体账户与组织实体的从属关系是全平台统一的，与业务系统无关，但这会为降低平台的灵活性和扩展性。灵活性和复杂度之间通常要做一个取舍。 业务实现 功能模块 账户 认证 组织管理 权限管理 授权管理 鉴权中心 系统管理 交易中心 营销中心 ","date":"2019-10-10","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/:1:1","tags":null,"title":"微服务架构笔记-中台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/"},{"categories":null,"content":"技术中台 MQ RPC框架 分布式事务 分布式缓存 容器 分库分表 ","date":"2019-10-10","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/:1:2","tags":null,"title":"微服务架构笔记-中台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/"},{"categories":null,"content":"数据中台 数据建模 日志分析 用户画像 ","date":"2019-10-10","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/:1:3","tags":null,"title":"微服务架构笔记-中台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/"},{"categories":null,"content":"算法中台 语音识别 图像识别 搜索算法 推荐算法 人机对话 垃圾过滤 ","date":"2019-10-10","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/:1:4","tags":null,"title":"微服务架构笔记-中台","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E5%8F%B0/"},{"categories":null,"content":"Webhook 使用GO语言编写。 sudo apt-get install webhook安装。 Get或者Post都可以触发hook。 service webhook status 可以查看webhook状态。 ","date":"2019-09-23","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-webhook/:1:0","tags":null,"title":"运维-WEBHOOK","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-webhook/"},{"categories":null,"content":"使用 Usage of webhook: -cert string path to the HTTPS certificate pem file (default \"cert.pem\") HTTPS证书的路径 -header value response header to return, specified in format name=value, use multiple times to set multiple headers -hooks string hook json文件的路径 (default \"hooks.json\") -hotreload watch hooks file for changes and reload them automatically -ip string ip the webhook should serve hooks on (default \"0.0.0.0\") -key string path to the HTTPS certificate private key pem file (default \"key.pem\") -nopanic do not panic if hooks cannot be loaded when webhook is not running in verbose mode -port int port the webhook should serve hooks on (default 9000) -secure use HTTPS instead of HTTP -urlprefix string url prefix to use for served hooks (protocol://yourserver:port/PREFIX/:hook-id) (default \"hooks\") -verbose show verbose output 创建一个hooks.json文件 [ { \"id\": \"redeploy-webhook\", \"execute-command\": \"/var/scripts/redeploy.sh\", \"command-working-directory\": \"/var/webhook\" } ] 必须包含id和execute-command属性，其他属性为可选的。 属性列表如下： 属性 描述 id 指定hook的ID，这个只用来创建HTTP endpoint (http://yourserver:port/hooks/your-hook-id) execute-command hook触发执行的命令 command-working-directory 指定hook执行命令的工作路径 response-message string回复 response-headers specifies the list of headers in format {“name”: “X-Example-Header”, “value”: “it works”} that will be returned in HTTP response for the hook include-command-output-in-response - boolean whether webhook should wait for the command to finish and return the raw output as a response to the hook initiator. If the command fails to execute or encounters any errors while executing the response will result in 500 Internal Server Error HTTP status code, otherwise the 200 OK status code will be returned. include-command-output-in-response-on-error - boolean whether webhook should include command stdout \u0026 stderror as a response in failed executions. It only works if include-command-output-in-response is set to true. parse-parameters-as-json - specifies the list of arguments that contain JSON strings. These parameters will be decoded by webhook and you can access them like regular objects in rules and pass-arguments-to-command. pass-arguments-to-command specifies the list of arguments that will be passed to the command. Check Referencing request values page to see how to reference the values from the request. If you want to pass a static string value to your command you can specify it as { “source”: “string”, “name”: “argumentvalue” } pass-environment-to-command specifies the list of arguments that will be passed to the command 作为环境变量. If you do not specify the “envname” field in the referenced value, the hook will be in format “HOOK_argumentname”, otherwise “envname” field will be used as it’s name. Check Referencing request values page to see how to reference the values from the request. If you want to pass a static string value to your command you can specify it as { “source”: “string”, “envname”: “SOMETHING”, “name”: “argumentvalue” } pass-file-to-command specifies a list of entries that will be serialized as a file. Incoming data will be serialized in a request-temporary-file (otherwise parallel calls of the hook would lead to concurrent overwritings of the file). The filename to be addressed within the subsequent script is provided via an environment variable. Use envname to specify the name of the environment variable. If envname is not provided HOOK_ and the name used to reference the request value are used. Defining command-working-directory will store the file relative to this location, if not provided, the systems temporary file directory will be used. If base64decode is true, the incoming binary data will be base 64 decoded prior to storing it into the file. By default the corresponding file will be removed after the webhook exited. trigger-rule specifies the rule that will be evaluated in order to determine should the hook be triggered. Check Hook rules page to see the list of valid rules and their usage trigger-rule-mismatch-http-respons","date":"2019-09-23","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-webhook/:1:1","tags":null,"title":"运维-WEBHOOK","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-webhook/"},{"categories":null,"content":"学习资料 ","date":"2019-09-19","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:0","tags":null,"title":"数据科学-深度学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"深度学习500问 ","date":"2019-09-19","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:1:1","tags":null,"title":"数据科学-深度学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"开源平台 ","date":"2019-09-19","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:2:0","tags":null,"title":"数据科学-深度学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"飞桨致力于让深度学习技术的创新与应用更简单 ","date":"2019-09-19","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/:2:1","tags":null,"title":"数据科学-深度学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"精神面貌 必须是一个正能量的人。 不断学习。 ","date":"2019-08-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/:1:0","tags":["日常"],"title":"日常-面试","uri":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/"},{"categories":null,"content":"问公司 目标岗位的离职原因（怎样做会辞退）； 目标岗位的完成目标（怎样做会达到绩效）； ","date":"2019-08-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/:2:0","tags":["日常"],"title":"日常-面试","uri":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/"},{"categories":null,"content":"Python高级工程师 面试了两家。 都会问是否用过爬虫。 都会问是否会AI算法（NLP和计算机视觉）。 退而求其次： 可以使用python对一些测试工具进行二次开发。 可以使用python做一些数据库相关管理工作。 ","date":"2019-08-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/:3:0","tags":["日常"],"title":"日常-面试","uri":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/"},{"categories":null,"content":"20200928 ","date":"2019-08-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/:4:0","tags":["日常"],"title":"日常-面试","uri":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/"},{"categories":null,"content":"职位描述 负责公司产品WEB网站的开发工作 做好开发系统及模块的微服务，参与整体系统的服务化治理 负责提升团队成员的编码水准和系统设计能力 配合产品、设计人员规划产品 ","date":"2019-08-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/:4:1","tags":["日常"],"title":"日常-面试","uri":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/"},{"categories":null,"content":"任职要求 本科及以上学历，具备Nodejs项目的开发经验，对node程序相关的部署有一定的了解 熟练掌握Nodejs，Javascript，HTML，CSS，对闭包、事件和异步有独到的见解， 并知道一些反模式的场景 熟悉并使用过前端Vue框架，对Vue服务器渲染有一定了解，熟悉并使用过Nuxt.js可加分 了解webpack构建相关的内容，以及基本的数据结构跟算法知识 具备一定的linux系统操作能力 熟悉数据库操作，熟悉MySQL数据库，并具备一定的数据库优化能力 具备对产品功能任务分解能力,做过任务拆解分配为优 ","date":"2019-08-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/:4:2","tags":["日常"],"title":"日常-面试","uri":"/post/%E6%97%A5%E5%B8%B8-%E9%9D%A2%E8%AF%95/"},{"categories":null,"content":"参考GuoZhaoran/spikeSystem 通常订票系统要处理生成订单、减扣库存、用户支付这三个基本的阶段。 要做的事情是要保证订单不超卖、不少卖，每张售卖的车票都必须支付才有效，还要保证系统承受极高的并发（抢票和秒杀）。 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:0:0","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"需要解决的问题 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:1:0","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"下单减库存，会造成少卖 在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的。 如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制 IP 和用户的购买订单数量，这也不算是一个好方法。 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:1:1","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"支付减库存，会造成超卖 在极限并发情况下，用户可能会创建很多订单。 当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘 IO。 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:1:2","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"预扣库存 先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多； 现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。 订单的生成是异步的，一般都会放到 MQ、Kafka 这样的即时消费队列中处理，订单量比较少的情况下，生成订单非常快，用户几乎不用排队。 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:1:3","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"扣库存的艺术 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:2:0","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"本地扣库存，异步产生订单 上面我们提到了 Nginx 的加权均衡策略，我们不妨假设将 100W 的用户请求量平均均衡到 100 台服务器上，这样单机所承受的并发量就小了很多。 然后我们每台机器本地库存 100 张火车票，100 台服务器上的总库存还是 1 万，这样保证了库存订单不超卖。 问题接踵而至，在高并发情况下，现在我们还无法保证系统的高可用，假如这 100 台服务器上有两三台机器因为扛不住并发的流量或者其他的原因宕机了。那么这些服务器上的订单就卖不出去了，这就造成了订单的少卖。 要解决这个问题，我们需要对总订单量做统一的管理，这就是接下来的容错方案。服务器不仅要在本地减库存，另外要远程统一减库存。 有了远程统一减库存的操作，我们就可以根据机器负载情况，为每台机器分配一些多余的“Buffer 库存”用来防止机器中有机器宕机的情况。 我们采用 Redis 存储统一库存，因为 Redis 的性能非常高，号称单机 QPS 能抗 10W 的并发。 在本地减库存以后，如果本地有订单，我们再去请求 Redis 远程减库存，本地减库存和远程减库存都成功了，才返回给用户抢票成功的提示，这样也能有效的保证订单不会超卖。 当机器中有机器宕机时，因为每个机器上有预留的 Buffer 余票，所以宕机机器上的余票依然能够在其他机器上得到弥补，保证了不少卖。 Buffer 余票设置多少合适呢，理论上 Buffer 设置的越多，系统容忍宕机的机器数量就越多，但是 Buffer 设置的太大也会对 Redis 造成一定的影响。 虽然 Redis 内存数据库抗并发能力非常高，请求依然会走一次网络 IO，其实抢票过程中对 Redis 的请求次数是本地库存和 Buffer 库存的总量。 因为当本地库存不足时，系统直接返回用户“已售罄”的信息提示，就不会再走统一扣库存的逻辑。 这在一定程度上也避免了巨大的网络请求量把 Redis 压跨，所以 Buffer 值设置多少，需要架构师对系统的负载能力做认真的考量。 ","date":"2019-08-28","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/:2:1","tags":null,"title":"产品-订单系统","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"注意 消息队列的使用，按时间分块，实时计算（少量的批量计算流）。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"声明 参考项目用了消息队列，不知道为啥用，有点尴尬 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:2:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"应用场景 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:3:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"优点 解耦 异步 削峰 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:3:1","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"缺点 系统可用性降低，增加了一层消息队列，就增加了一层风险。 系统复杂性增加。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:3:2","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"消息队列选型 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，比RocketMQ\\Kafka低一个数量级 同ActiveMQ 10万级，支持高吞吐 10万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 topic数量对吞吐量的影响 topic可以达到几百、几千的级别，吞吐量会有较小幅度的下降，这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic topic从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka尽量保证topic数量不要过多，如果支撑大规模的topic，需要增加更多的机器资源 时效性 ms级 微秒级，这是RabbitMQ的一大特点、延迟最低 ms级 延迟在ms级以内 可用性 高，基于主从架构实现高可用 同ActiveMQ 非常高，分布式架构 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 消息可读性 有较低的概率丢失数据 基本不丢 经过参数优化配置，可以做到0丢失 同RocketMQ 功能支持 MQ领域的功能极其完备 基于erlang开发，并发能力很强，性能很好，延时很低 MQ功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用 活跃度 不太活跃 活跃 较活跃 较活跃 Topic是消息中间件里一个重要的概念，每一个Topic代表了一类消息，有了多个Topic，就可以对消息进行归类与隔离。 Kafka和RocketMQ都是磁盘消息队列的模式，对于同一个消费组，一个分区只支持一个消费线程来消费消息。过少的分区，会导致消费速度大大落后于消息的生产速度。所以在实际生产环境中，一个Topic会设置成多分区的模式，来支持多个消费者. ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:4:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"RabbitMQ ***** 中小型软件公司，建议选RabbitMQ， erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。但是定制开发比较难。 RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。 中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。 rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:4:1","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"RocketMQ 大型软件公司，根据具体使用在rocketMq和kafka之间二选一。 针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。 至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:4:2","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"如何保证消息队列是高可用的 要对消息队列的集群模式有深刻了解。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:5:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:5:1","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"rabbitMQ,也有普通集群和镜像集群模式 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:5:2","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"如何保证消息不被重复消费 正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同。 因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:6:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"解决方法 使用第三方介质（redis），做消费记录。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:6:1","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"如何保证消费的可靠性传输 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:7:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"RabbitMQ 生产者丢数据 RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 transaction机制就是说，发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事务就会回滚(channel.txRollback())，如果发送成功则提交事务(channel.txCommit())。 消息队列丢数据 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 消费者丢数据 消费者丢数据一般是因为采用了自动确认消息模式。 这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。 至于解决方案，采用手动确认消息即可。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:7:1","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"如何保证消息队列的顺序性 通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。 ","date":"2019-08-22","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:8:0","tags":null,"title":"微服务架构笔记-中间件-消息队列","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":null,"content":"Neo4j是： 一个开源 无Schema 没有SQL 图形数据库 图形数据库也称为图形数据库管理系统或GDBMS。 ","date":"2019-08-19","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-neo4j/:0:0","tags":null,"title":"运维-数据库-NEO4J","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-neo4j/"},{"categories":null,"content":"CQL ","date":"2019-08-19","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-neo4j/:1:0","tags":null,"title":"运维-数据库-NEO4J","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-neo4j/"},{"categories":null,"content":"摘自Sequelize 中文API文档 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:0:0","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"MODEL定义 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:0","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"时间戳 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:1","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"延时 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:2","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"Getters \u0026 setters - 访问器\u0026设置器 可以在你的模型中将对象属性定义为访问/设置函数 访问器\u0026设置器有以下两种定义方式： 做为一个属性定义 class Employee extends Model {} Employee.init({ name: { type: Sequelize.STRING, allowNull: false, get() { const title = this.getDataValue('title'); // 'this' allows you to access attributes of the instance return this.getDataValue('name') + ' (' + title + ')'; }, }, title: { type: Sequelize.STRING, allowNull: false, set(val) { this.setDataValue('title', val.toUpperCase()); } } }, { sequelize, modelName: 'employee' }); Employee .create({ name: 'John Doe', title: 'senior engineer' }) .then(employee =\u003e { console.log(employee.get('name')); // John Doe (SENIOR ENGINEER) console.log(employee.get('title')); // SENIOR ENGINEER }) 做为模型选项 //在下面的示例中，定义了一个名为fullName的访问器，它是对this.firstname和this.lastname两个属性引用，这个属性的一个假属性它并不是数据库中的一部分。定义假属性可以使用访问器或定义为VIRTUAL类型两种方式，Virtual类型可以验证而访问器则不能。 class Foo extends Model { get fullName() { return this.firstname + ' ' + this.lastname; } set fullName(value) { const names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); } } Foo.init({ firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { sequelize, modelName: 'foo' }); // Or with `sequelize.define` sequelize.define('Foo', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { getterMethods: { fullName() { return this.firstname + ' ' + this.lastname; } }, setterMethods: { fullName(value) { const names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); } } }); ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:3","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"定义字段的配置 var Foo = sequelize.define('foo', { flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true}, // 实例化时在没有显式设置属性值时，会自动设置为 true.设置 allowNull 选项为 false 后，会为列添加 NOT NULL 非空限制, 这意味着当执行查询（插入/更新）时相关字段为空会从数据库层抛出错误 myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW }, // 日期默认值 =\u003e 当前时间 title: { type: Sequelize.STRING, allowNull: false}, someUnique: {type: Sequelize.STRING, unique: true}, // 添加唯一（unique）约束后插入重复值会报错 uniqueOne: { type: Sequelize.STRING, unique: 'compositeIndex'}, // unique属性可以是boolean 或 string类型 uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'} // 如果为多个字段添加了相同的字符串那么将会是一个符合唯一键 someUnique: {type: Sequelize.STRING, unique: true} // unique属性以一个简单的简写方式创建唯一索引 {someUnique: {type: Sequelize.STRING}}, // 同样的，也可以模型的选项中创建索引 {indexes: [{unique: true, fields: ['someUnique']}]} identifier: { type: Sequelize.STRING, primaryKey: true}, // 定义一个主键 incrementMe: { type: Sequelize.INTEGER, autoIncrement: true }, //// autoIncrement 选项用于创建一个自增的整型列 hasComment: { type: Sequelize.INTEGER, comment: \"I'm a comment!\" }, // Comments 可以在MySQL 和 PG中指定定段描述 fieldWithUnderscores: { type: Sequelize.STRING, field: \"field_with_underscores\" }, // 可以通过 \"field\" 属性来指定数据库中的字段名 // 通过references选项可以创建外键: bar_id: { type: Sequelize.INTEGER, references: { // 引用另一个模型 model: Bar, // 连接模型的列表 key: 'id', // 强制使用外键约束，仅适用于 PostgreSQL deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE } } }) ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:4","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"字段类型 Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT('tiny') // TINYTEXT Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 12) // FLOAT(11,12) Sequelize.REAL // REAL PostgreSQL only. Sequelize.REAL(11) // REAL(11) PostgreSQL only. Sequelize.REAL(11, 12) // REAL(11,12) PostgreSQL only. Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 12) // DOUBLE(11,12) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres Sequelize.DATE(6) // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision Sequelize.DATEONLY // DATE without time. Sequelize.BOOLEAN // TINYINT(1) Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2' Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only. Sequelize.JSON // JSON column. PostgreSQL only. Sequelize.JSONB // JSONB column. PostgreSQL only. Sequelize.BLOB // BLOB (bytea for PostgreSQL) Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long) Sequelize.UUID // PostgreSQL 和 SQLite 中为 UUID, MySQL 中为CHAR(36) BINARY (使用 defaultValue: Sequelize.UUIDV1 或 Sequelize.UUIDV4 生成默认值) Sequelize.RANGE(Sequelize.INTEGER) // Defines int4range range. PostgreSQL only. Sequelize.RANGE(Sequelize.BIGINT) // Defined int8range range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATE) // Defines tstzrange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATEONLY) // Defines daterange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DECIMAL) // Defines numrange range. PostgreSQL only. Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only. Sequelize.GEOMETRY // Spatial column. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT') // Spatial column with geomerty type. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT', 4326) // Spatial column with geomerty type and SRID. PostgreSQL (with PostGIS) or MySQL only. DATE直接使用JS的DATE()类型的数据写入。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:5","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"Validations - 验证 var ValidateMe = sequelize.define('foo', { foo: { type: Sequelize.STRING, validate: { is: [\"^[a-z]+$\",'i'], // 只允许字母 is: /^[a-z]+$/i, // 只允许字母 not: [\"[a-z]\",'i'], // 不能使用字母 isEmail: true, // 检测邮箱格式 (foo@bar.com) isUrl: true, // 检查Url格式 (http://foo.com) isIP: true, // 检查 IPv4 或 IPv6 格式 isIPv4: true, // 检查 IPv4 isIPv6: true, // 检查 IPv6 isAlpha: true, // 不能使用字母 isAlphanumeric: true, // 只允许字母数字字符 isNumeric: true, // 只能使用数字 isInt: true, // 只能是整数 isFloat: true, // 只能是浮点数 isDecimal: true, // 检查数字 isLowercase: true, // 检查小写字母 isUppercase: true, // 检查大写字母 notNull: true, // 不允许null isNull: true, // 只能为null notEmpty: true, // 不能空字符串 equals: 'specific value', // 只能使用指定值 contains: 'foo', // 必须包含子字符串 notIn: [['foo', 'bar']], // 不能是数组中的任意一个值 isIn: [['foo', 'bar']], // 只能是数组中的任意一个值 notContains: 'bar', // 不能包含子字符串 len: [2, 10], // 值的长度必在 2 和 10 之间 isUUID: 4, // 只能是UUID isDate: true, // 只能是日期字符串 isAfter: \"2011-11-05\", // 只能使用指定日期之后的时间 isBefore: \"2011-11-05\", // 只能使用指定日期之前的时间 max: 23, // 允许的最大值 min: 23, // 允许的最小值 isArray: true, // 不能使用数组 isCreditCard: true, // 检查是有效的信用卡 // 也可以自定义验证: isEven: function(value) { if(parseInt(value) % 2 != 0) { throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed } } } } }); ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:6","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"model配置 // 不要添加时间戳属性 (updatedAt, createdAt) timestamps: false, // 不从数据库中删除数据，而只是增加一个 deletedAt 标识当前时间 // paranoid 属性只在启用 timestamps 时适用 paranoid: true, // 不使用驼峰式命令规则，这样会在使用下划线分隔 // 这样 updatedAt 的字段名会是 updated_at underscored: true, // 禁止修改表名. 默认情况下 // sequelize会自动使用传入的模型名（define的第一个参数）做为表名 // 如果你不想使用这种方式你需要进行以下设置 freezeTableName: true, // 定义表名 tableName: 'my_very_custom_table_name' // Enable optimistic locking. When enabled, sequelize will add a version count attribute // to the model and throw an OptimisticLockingError error when stale instances are saved. // Set to true or a string with the attribute name you want to use to enable. version: true, // Sequelize instance sequelize, ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:1:7","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"Model的使用 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:2:0","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"基本操作 通过Sequelize获取的模型对象实例列是一个DAO（Data Access Object）对象，这些对象会拥有许多操作数据库表的实例对象方法，这个对象会有create()、find()、update()、destroy()等对象操作方法，这些方法会对应的生成INSERT、SELECT、UPDATE、DELETE等SQL语句。 增：create操作 create操作是指创建数据记录，我们可通过Model.create()方法添加一条数据或通过Model.bulkCreate()方法添加多条数据。 注意 updateOnDuplicate是在插入的时候如果主键冲突就执行更新操作 User.create({ firstName: 'liu', lastName: '小明' }).then(function (created){ // 创建结果 console.log(created); }).catch(function(err){ // 出错了 console.log(err); }) 在这个方法，其实际执行SQL语句类似如下： INSERT INTO `user` (`id`,`first_name`,`lastName`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'liu','小明','2016-05-03 15:22:06','2016-05-03 15:22:06'); 可以看出，除了我们在User对象定义时的两个字段外，其还额外处理了id、createdAt、updatedAt三个字段。id是数据表的主键，如果在定义对象时添加了主键，将使用自定义的主键，而没有添加时将自动添加一个名为id的主键。createdAt、updatedAt两个字段同样是自动添加的，如果不需要使用可以在定义模型时进行设置： sequelize.define('user', { firstName: { type: Sequelize.STRING, field: 'first_name' }, lastName: { type: Sequelize.STRING } }, { freezeTableName: true, 'createdAt': false, 'updatedAt': 'utime' }); 改：update操作 update操作是指修改数据记录，我们可通过Model.update()方法来修改已经存在的数据记录： 可以使用bulkCreate方法，批量更新，当主键冲突时，指定需要更新的字段。 db_erroressence.active_telephone.bulkCreate(valueArr,{updateOnDuplicate:[\"age\",\"sex\"]}); // 主键冲突，更新age和sex User.update({firstName:'liu'}, {where:{id:1}}).then(function (result){ // 修改结果 console.log(result); }).catch(function(err){ // 出错了 console.log(err); }) 在.update()方法中，其实际生成的SQL语句类似如下： UPDATE `user` SET `first_name`='liu',`updatedAt`='2016-05-03 15:43:32' WHERE `id` = 1 查：find操作 find操作是指查询已存在的数据记录，我们可通过Model.findOne()方法查找一条数据，或通过Model.findAll()方法查找所有数据： // 按指定条件查找一条数据 User.findOne({where:{id:1}}).then(function (result){ // 查询结果 console.log(result); }).catch(function(err){ // 出错了 console.log(err); }) // 查找所有数据 User.findAll().then(function (result){ // 查询结果 console.log(result); }).catch(function(err){ // 出错了 console.log(err); }) 在上面的查询操作中，其实际执行SQL语句分别类似如下： // 单条数据查询 SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` WHERE `user`.`id` = 1 // 多条数据查询 SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` 对查询到实例可以执行save方法 删：destroy操作 destroy操作是指删除已存在的数据记录，我们可通过Model.destroy()方法来删除数据： User.destroy({where:{id:1}}).then(function (result){ // 操作结果 console.log(result); }).catch(function(err){ // 出错了 console.log(err); }) 在以上.destroy()方法中，其实际生成的SQL语句类似如下： DELETE FROM `user` WHERE `id` = 1 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:2:1","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"model的API removeAttribute() - 移除属性 sync() - 同步模型到数据库 drop() - 删除数据库中的表 schema() - 指定schema getTableName() - 获取表名 addScope() - 添加限制范围 scope() - 应用限制范围 findAll() - 查询多条数据 findById() - 通过Id查询单条数据 findOne() - 查询单条数据 aggregate() - 聚合查询 count() - 统计查询结果数 统计符合查询条件的结果总数。 如果提供了include，将计算匹配关联的数目 findAndCount() - 分页查询 max() - 查询最大值 min() - 查询最大值 sum() - 求和 build() - 创建新实例 create() - 创建保存新实例 findOrInitialize() - 查找或初始化 findOrCreate() - 查找或创建 findCreateFind() - 查找或创建 upsert() - 创建或更新 bulkCreate() - 创建多条记录 truncate() - 截断模型 destroy() - 删除记录 restore() - 恢复记录 update() - 更新记录 describe() - 查询表信息 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:2:2","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"Data retrieval / Finders - 数据索引/查找 查找方法是为了从数据库中查询数据，这些方法不是返回原始数据对象，而是返回模型实例。因其返回的是模型实例，所以在文档的查询结果中可以任意调用模型实例的成员、方法等。（更多实例介绍请参考：instance） 下面是一些常用的查询方法。 //find - 从数据库中查找一个指定元素 // 按已知id查找 Project.findByPk(123).then(function(project) { // project 是一个 Project 实例，且包含存储在数据中的数据 // 当不存在 id 为123的记录时 project 为 null }) // 按属性查找 Project.findOne({ where: {title: 'aProject'} }).then(function(project) { // project 是匹配到的第一个 title 为 'aProject' 的 Projects 或 null }) Project.findOne({ where: {title: 'aProject'}, attributes: ['id', ['name', 'title']] }).then(function(project) { // project 是匹配到的第一个 title 为 'aProject' 的 Projects 或 null // project 的 project.title 属性中会包含 'name' }) findOrCreate - 从数据库中查找一个指定元素如果不存在则创建记录 findOrCreate可用于检测一个不确定是否存在的元素，如果存在则返回记录，不存在时会使用提供的默认值（默认值可以为常量，也可以为变量）新建记录。 //如，当数据不存在时，其执行效果如下： User .findOrCreate({where: {username: 'sdepold'}, defaults: {job: 'Technical Lead JavaScript'}}) .then(([user, created])=\u003e { console.log(user.get({ plain: true })) console.log(created) /* [{ username: 'itbilu.com', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) }, true] */ }) //当数据存在时，会返回记录： User .create({ username: 'fnord', job: 'omnomnom' }) .then(()=\u003e User.findOrCreate({where: {username: 'fnord'}, defaults: {job: 'something else'}})) .then(([user, created]) =\u003e { console.log(user.get({ plain: true })) console.log(created) /* [{ username: 'fnord', job: 'omnomnom', id: 2, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) }, created: false] */ }) }) findAndCountAll - 从数据库中查找多个元素，返回数据与记录总数 这个方法是findAll和count两个方法的便捷形式，这在你想使用limit和offset进行分页查询时非常有用。 在返回值中，会包含以下两个属性： count - 整数，匹配到的总记录数 rows - 对象数据，通过 limit 和 offset匹配的当前页数据 Project .findAndCountAll({ where: { title: { $like: 'foo%' } }, offset: 10, limit: 2 }) .then(function(result) { console.log(result.count); console.log(result.rows); }); //findAndCountAll同样支持使用include包含，使用包含时只有将required设置为true才会添加到count部分： User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit: 3 }); //使用include时，两个模型之间应该存在主/外键关系，如果不存在就应该在include中手工建立连接。 在上面的示例中，为Profile设置了required，所以在查询时会使用INNER JOIN内连接。 findAll - 从数据库中查找多个元素 findAndCountAll中使用的查询选项同样适用于findAll方法。 Op = Sequelize.Op; options都有哪些 Name Type Attribute Description options Object optional 描述搜索范围的选项散列 options.where Object optional A hash of attributes to describe your search. See above for examples. options.attributes Array / Object optional A list of the attributes that you want to select, or an object with include and exclude keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of 表达式 such as Sequelize.literal, Sequelize.fn and so on), and the second is 重命名 options.attributes.include Array optional 包含所有属性，并加上一些额外属性. Useful for aggregations, e.g. { attributes: { include: [[sequelize.fn(‘COUNT’, sequelize.col(‘id’)), ‘total’]] } options.attributes.exclude Array optional 包含所有属性，除了一些. Useful for security purposes e.g. { attributes: { exclude: [‘password’] } } |options.paranoid boolean optional default: true If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if options.paranoid is true for the model. |options.include Array\u003cObject|Model|string\u003e optional A list of associations to eagerly load using a left join. Supported is either { include: [ Model1, Model2, …]} or { include: [{ model: Model1, as: ‘Alias’ }]} or { include: [‘Alias’]}. If your association are set up with an as (eg. X.hasMany(Y, { as: ‘Z }, you need to specify Z in the as attribute when eager loading Y). |options.include[].model Model optional The model you want to eagerly load |options.include[].as string optional The alias of the relation, in case the model you want to eagerly load is aliased. For hasOne / belongsTo, this should be the singular name, and for hasMan","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:2:3","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"Eager loading - 预加载 从数据库中加载数据时，除数据本身外还想得到与之相关联的数据－这就是所谓的预加载。也就是说，使用find或findAll查询数据时，通过include属性同时加载关联的数据。 假设有以下数据结构： var User = sequelize.define('user', { name: Sequelize.STRING }) , Task = sequelize.define('task', { name: Sequelize.STRING }) , Tool = sequelize.define('tool', { name: Sequelize.STRING }) Task.belongsTo(User) User.hasMany(Task) User.hasMany(Tool, { as: 'Instruments' }) sequelize.sync().then(function() { // this is where we continue ... }) 通过belongsTo与hasMany建立关系后，就可以像下面这样查询： Task.findAll({ include: [ User ] }).then(function(tasks) { console.log(JSON.stringify(tasks)) /* [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\" } }] */ }) 由于Task与User是1对多的关系，所在查询时user会做为一个对象属性被同时加载。 下面我们进行一个多对多的查询： User.findAll({ include: [ Task ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1 }] }] */ }) 在多对多的关系中，相关数据会做为一个数组属性被同时加载。 关联查询时，可以使用as选项为关系数据指定别名： User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }] */ }) 关联查询时，同样可以使用where选项对关联数据进行筛选（所有的where为与的关系）： User.findAll({ include: [{ model: Tool, as: 'Instruments', where: { name: { $like: '%ooth%' } } }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], [{ \"name\": \"John Smith\", \"id\": 2, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], */ }) 注意：使用include.where条件时，include.requied会被隐式的设置为true，即在查询时会使用INNER JOIN内连接可以显性地设为false。 全关联 如果多个模型间存在关联关系，而我们在查询时又要查询所有的数据，就可以设置all: true来关联所有模型： User.findAll({ include: [{ all: true }]}); 包括软删除的数据 如果要在结果中包含软删除的数据，请将include.paranoid设置为true： User.findAll({ include: [{ model: Tool, where: { name: { $like: ‘%ooth%’ } }, paranoid: true // 查询并加载软删除的数据 }] }); 预加载关联数据的排序 在1对多（one-to-many）的关系中： Company.findAll({ include: [ Division ], order: [ [ Division, ‘name’ ] ] }); Company.findAll({ include: [ Division ], order: [ [ Division, ‘name’, ‘DESC’ ] ] }); Company.findAll({ include: [ { model: Division, as: ‘Div’ } ], order: [ [ { model: Division, as: ‘Div’ }, ‘name’ ] ] }); Company.findAll({ include: [ { model: Division, as: ‘Div’ } ], order: [ [ { model: Division, as: ‘Div’ }, ‘name’, ‘DESC’ ] ] }); Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, Department, ‘name’ ] ] }); 在多对多（many-to-many）的关系中同样可以使用排序： Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, DepartmentDivision, ‘name’ ] ] }); 嵌套预加载 可以在关联模型中嵌套预加载关系模型： User.findAll({ include: [ {model: Tool, as: ‘Instruments’, include: [ {model: Teacher, include: [ /* etc */]} ]} ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ “name”: “John Doe”, “id”: 1, “createdAt”: “2013-03-20T20:31:45.000Z”, “updatedAt”: “2013-03-20T20:31:45.000Z”, “Instruments”: [{ // 1:M and N:M association “name”: “Toothpick”, “id”: 1, “createdAt”: null, “updatedAt”: null, “userId”: 1, “Teacher”: { // 1:1 association “name”: “Jimi Hendrix” } }] }] */ }) 这会生成一个外连接，但where子句的关系模型会使用内连接并返回唯一一个子句： User.findAll({ include: [{ model: To","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:2:4","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"API build() - 创建新实例 参数，为一个字典。 build(values, [options]) -\u003e Instance 创建一个新的模型实例，Values参数为新例指定的键值对对象 create() - 创建保存新实例 create(values, [options]) -\u003e Promise.\u003cInstance\u003e 构建一个新的模型实例，并进行保存。与build()方法不同的是，此方法除创建新实例外，还会将其保存到对应数据库表中。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:2:5","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"关联 有四种关联关系： BelongsTo HasOne HasMany BelongsToMany ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:3:0","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"基本概念 源模型和目标模型 User.hasOne(Project); User是源模型，Project是目标模型。 外键 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:3:1","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"一对一 BelongsTo - 属于 BelongsTo关联表示一对一关系的外键存在于源模型。 如，下例中Player是通过外键关联的Team的一部分： var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Player.belongsTo(Team); // 会为Player添加一个teamId 属性以保持与Team 主键的关系 外键 默认情况下，一个属于关系的外键将从目标模型的名称和主键名称生成。 默认命名使用驼峰式命名，而在源模型中添加了underscored: true配置，将使用蛇型命名。 在定义中使用as命名时，会将其做为目标模型的名称. User.belongsTo(UserRole, {as: 'role'}); // 会为 user添加 roleId 属性而不是 userRoleId HasOne - 拥有一个 HasOne关联表示一对一关系的外键存在于目标模型。 HasOne 与BelongsTo 的不同 在1:1 的关系中，可使用HasOne 或BelongsTo来定义。但它们的使用场景有所不同。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:3:2","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"一对多(One-To-Many)关联 One-To-Many关联是指一个源模型连接多个目标模型。反之目标模型都会有一个明确的源。 var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // 定义 hasMany 关联 Project.hasMany(User, {as: 'Workers'}) 会向 User 中添加一个projectId或project_id属性。Project 的实例中会有访问器getWorkers 和 setWorkers。这是一种单向关联方式，如果两个模型间还有其它关联方式请参考下面的多对多关系。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:3:3","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"多对多(Belongs-To-Many)关联 Belongs-To-Many 关联是指一个源模型连接多个目标模型。而且，目标模型也可以有多个相关的源。 User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId'}) User.findAll({ include: [{ model: Project, through: { attributes: ['createdAt', 'startedAt', 'finishedAt'], where: {completed: true} } }] }); ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:3:4","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"踩过的坑 查询出来的model集，如果使用attributes指定了重命名，不能直接使用对象的访问符获取元素，只能使用dataValues，没有重命名就可以使用.。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/:4:0","tags":["后端","ORM"],"title":"ORM-Sequelize","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-js-sequelize/"},{"categories":null,"content":"Socket.IO 是一个基于 Node.js 的实时应用程序框架，在即时通讯、通知与消息推送，实时分析等场景中有较为广泛的应用。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:0:0","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"Server ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:1:0","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"INIT const io = require('socket.io')(server, options); ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:1:1","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"命名空间(Namespaces) 表示在由路径名（例如：/chat）标识的给定范围内连接的socket池。 客户端始终连接到/（主命名空间），然后可能连接到其他命名空间（使用相同的底层连接）。 使用场景 设置一个管理命名空间，只有认证的用户可以访问。 const adminNamespace = io.of('/admin'); 多个租户的话，可以为每个租户动态创建一个命名空间。 const workspaces = io.of(/^\\/\\w+$/); 默认命名空间（/） This namespace is identified by io.sockets or simply io。 // the following two will emit to all the sockets connected to `/` io.sockets.emit('hi', 'everyone'); io.emit('hi', 'everyone'); // short form 属性 namespace.name (字符串) 命名空间标识符 namespace.connected（对象） 连接到此命名空间的Socket对象的哈希，由id索引。 namespace.adapter（适配器） 该Adapter用于命名空间。在使用Adapter基于Redis的时候很有用，因为它暴露了管理集群中的套接字和房间的方法。 注意：可以访问主命名空间的适配器io.of('/').adapter。 方法 namespace.to（room） 为随后的事件发射设置一个修饰符，事件只会广播到已经加入room给定的客户端room。 要发射到多个房间，可以to多次打电话。 返回：Namespace方便链式操作 namespace.in（room） namespace.to（room）的同义词。 namespace.emit（eventName [，… args]） 向所有连接的客户端发出事件。 namespace.clients（callback） 获取连接到此命名空间的客户机ID（跨所有节点（如果适用））。 和to与in配合使用，可以获取指定room的连接socket。 const io = require('socket.io')(); io.of('/chat').clients((error, clients) =\u003e { if (error) throw error; console.log(clients); // =\u003e [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD] }); 获取命名空间中所有客户端的一个示例： io.of('/chat').in('general').clients((error, clients) =\u003e { if (error) throw error; console.log(clients); // =\u003e [Anw2LatarvGVVXEIAAAD] }); 与广播一样，默认是默认命名空间（'/'）的所有客户端： io.clients((error, clients) =\u003e { if (error) throw error; console.log(clients); // =\u003e [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB] }); ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:1:2","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"Rooms Namespace内部, 可以定义任意的频道成为“Rooms”sockets可以join和leave. 在给一小部分socket广播数据时比较有用。 使用场景：将用户ID作为room，将socket加入进去，向用户发送；将设备sn作为room，将socket加入进去，向设备发送。此时，可以建立对应映射关系，省去自己维护。 API 加入Room 一个socket自动加入以socketi#id命名的room. io.on('connection', socket =\u003e { socket.join('some room'); }); 广播数据（to OR in） 一个socket在多个room中也只会广播一条。 向一个room中广播数据，不包括发送者。 io.to('some room').emit('some event'); io.to('room1').to('room2').to('room3').emit('some event'); // 同时向多个room广播 离开Room 断开连接，自动离开。 从外部发送信息(socket.io-redis + socket.io-emitter) ****** 通过redis作为信息通道。 //集成redis adapter const io = require('socket.io')(3000); const redis = require('socket.io-redis'); io.adapter(redis({ host: 'localhost', port: 6379 })); //外部的任何进程 const io = require('socket.io-emitter')({ host: '127.0.0.1', port: 6379 }); setInterval(function(){ io.emit('time', new Date); }, 5000); ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:1:3","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"Socket ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:1:4","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"socket A Socket是与浏览器客户端进行交互的基本类。A Socket属于某个Namespace（默认情况下/），并使用底层Client进行通信。 Socket类继承自EventEmitter。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:2:0","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"属性 socket.id（串） 会话的唯一标识符，来自底层Client。 socket.rooms 在socket.join(‘room’)之后。 socket.client（客户） 对基础Client对象的引用。 socket.conn（engine.Socket） 引用底层Client传输连接（engine.io Socket对象）。这允许访问IO传输层，其仍然（主要）抽象实际的TCP / IP套接字。 socket.request 一个getter代理，返回引用request底层引擎的引用Client。用于访问请求头，如Cookie或User-Agent。 socket.handshake 握手细节： { headers: /* the headers sent as part of the handshake */, time: /* the date of creation (as string) */, address: /* the ip of the client */, xdomain: /* whether the connection is cross-domain */, secure: /* whether the connection is secure */, issued: /* the date of creation (as unix timestamp) */, url: /* the request URL string */, query: /* the query object */ } ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:2:1","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"方法 socket.join（room [，callback]） 将客户端添加到room，并且可选地启动带有err签名的回调（如果有）。 socket.leave（room [，callback]） 从中删除客户端room，并可选地启动带有err签名的回调（如果有）。 断开后房间自动关闭。 ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:2:2","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"CLIENT 使用Websocket协议 ws://[IP]:[PORT]/socket.io 使用socketio库 io('http://IP]:[PORT/命名空间') ","date":"2019-08-02","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/:3:0","tags":["WEB"],"title":"后端-web框架-基础件-socket.io","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E4%BB%B6-socket-io/"},{"categories":null,"content":"Egg 奉行『约定优于配置』 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:0:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"渐进式开发 1. 最初始的状态：直接在框架中写业务代码。 2. 插件的雏形：发现业务代码具有通用性，可以写成插件。 3. 抽成独立插件： 插件稳定之后，做成node module。 4. 沉淀到框架：重复上述的过程，很快我们会积累了好几个插件和配置，并且我们会发现，在团队的大部分项目中，都会用到这些插件，考虑抽象出一个适合团队业务场景的框架。 5. 注意：不管是应用/插件/框架，都必须编写单元测试，并尽量实现 100% 覆盖率。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:1:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"框架内置基础对象 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Application Application 是全局应用对象，在一个应用中，只会实例化一个，它继承自 Koa.Application。 事件 // app.js module.exports = app =\u003e { app.once('server', server =\u003e { //该事件一个 worker 进程只会触发一次，在 HTTP 服务完成启动后，会将 HTTP server 通过这个事件暴露出来给开发者 // websocket }); app.on('error', (err, ctx) =\u003e { //运行时有任何的异常被 onerror 插件捕获后，都会触发 error 事件，将错误对象和关联的上下文（如果有）暴露给开发者，可以进行自定义的日志记录上报等处理 // report error }); app.on('request', ctx =\u003e { //应用收到请求和响应请求时，分别会触发 request 和 response 事件，并将当前请求上下文暴露出来，开发者可以监听这两个事件来进行日志记录 // log receive request }); app.on('response', ctx =\u003e { // ctx.starttime is set by framework const used = Date.now() - ctx.starttime; // log total cost }); }; 获取方式 Application 对象几乎可以在编写应用时的任何一个地方获取到. 和 Koa 一样，在 Context 对象上，可以通过 ctx.app 访问到 Application 对象。 // 使用egg-socket之后，关闭连接 app.io.of('/').adapter.remoteDisconnect(id, true, err =\u003e { logger.error(err); }); ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:1","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Context Context 是一个请求级别的对象，继承自 Koa.Context。在每一次收到用户请求时，框架会实例化一个 Context 对象，这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的 Service 挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面（egg-sequelize 会将所有的 model 挂载在 Context 上）。 Ctx获取方式 最常见的 Context 实例获取方式是在 Middleware, Controller 以及 Service 中. ctx 作为函数参数 .query //请求url中的参数(=) .request .body //获取post请求的body.请求内容类型必须为为`application/json` .header .host // 域名 .connection // upgrade .content-length .x-forwarded-for // IP地址 .user-agent // 用户客户端 .accept // .cache-control .postman-token .accept-encoding //gzip,deflate,br .method // 请求方法 GET .url // 路由 .query //参数 .res .response .status // 404(初始) .msg //Not Found(初始) .header .socket //使用egg-socket插件之后 .emit('res', 'connected!'); // .id //socket连接ID .app //项目有关 .env .name .baseDir .subdomainOffset .config .controller .httpclient .loggers .middlewares .router .serviceClasses .params // URL中的参数，定义router时会定义 .originalUrl .req .res ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:2","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Request \u0026 Response Request 是一个请求级别的对象，继承自 Koa.Request。封装了 Node.js 原生的 HTTP Request 对象，提供了一系列辅助方法获取 HTTP 请求常用参数。 Response 是一个请求级别的对象，继承自 Koa.Response。封装了 Node.js 原生的 HTTP Response 对象，提供了一系列辅助方法设置 HTTP 响应。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:3","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Controller 框架提供了一个 Controller 基类，并推荐所有的 Controller 都继承于该基类实现。这个 Controller 基类有下列属性： ctx - 当前请求的 Context 实例。 app - 应用的 Application 实例。 config - 应用的配置。 service - 应用所有的 service。 logger - 为当前 controller 封装的 logger 对象。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:4","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Service 框架提供了一个 Service 基类，并推荐所有的 Service 都继承于该基类实现。 Service 基类的属性和 Controller 基类属性一致 每一次用户请求，框架都会实例化对应的 Service 实例。 Service 不是单例，是 请求级别 的对象，框架在每次请求中首次访问 ctx.service.xx 时延迟实例化，所以 Service 中可以通过 this.ctx 获取到当前请求的上下文。 作用 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:5","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Helper Helper 用来提供一些实用的 utility 函数。它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，这样可以用 JavaScript 来写复杂的逻辑，避免逻辑分散各处，同时可以更好的编写测试用例。 Helper 自身是一个类，有和 Controller 基类一样的属性，它也会在每次请求时进行实例化，因此 Helper 上的所有函数也能获取到当前请求相关的上下文信息。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:6","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Config 7.1. 获取方式 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:7","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Logger 8.1. App Logger 8.2. App CoreLogger 8.3. Context Logger 8.4. Context CoreLogger 8.5. Controller Logger \u0026 Service Logger ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:8","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Subscription ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:2:9","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"目录结构 文件名不能用下划线，有可能识别不了。 egg-project ├── package.json ├── app.js (可选) //自定义启动时的初始化工作，可选 ├── agent.js (可选) ├── app | ├── router.js //配置 URL 路由规则 │ ├── controller //解析用户的输入，处理后返回相应的结果,注意，支持多级目录，默认文件名为驼峰式 │ | └── home.js │ ├── service (可选) //编写业务逻辑层，可选，建议使用，*注意，支持多级目录，默认文件名为驼峰式，可以修改LoaderAPI改变文件名* │ | └── user.js │ ├── middleware (可选) //编写中间件，可选（例如同意错误处理） │ | └── response_time.js │ ├── schedule (可选) //定时任务，可选 │ | └── my_task.js │ ├── public (可选) //放置静态资源，可选 │ | └── reset.css │ ├── core (可选) //基于内部类可以定义中间类（定义中间类使用constructor(ctx)必须使用ctx作为入口参数） │ ├── utils (可选) //自定义方法 │ ├── lib (可选) //自定义模块 │ ├── view (可选) //放置模板文件，可选，由模板插件约定，具体参见模板渲染 │ | └── home.tpl | ├── model //放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize. 不能存在子目录，而且模型名必须要和模型文件名字符相同（可以不区分大小写） │ └── extend (可选) //框架的扩展，可选 │ ├── helper.js (可选) │ ├── request.js (可选) │ ├── response.js (可选) │ ├── context.js (可选) │ ├── application.js (可选) │ └── agent.js (可选) ├── config //编写配置文件 | ├── plugin.js //配置需要加载的插件 | ├── config.default.js │ ├── config.prod.js | ├── config.test.js (可选) | ├── config.local.js (可选) | └── config.unittest.js (可选) └── test //单元测试 ├── middleware | └── response_time.test.js └── controller └── home.test.js ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:3:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Service\\Controller使用core定义的类 ****** core中的类基于Service或者Controller创建的。如果有了自己的属性，需要用new；如果没有自己的属性，可以使用extends core中的类不是基于Service或者Controller创建的。只能使用new ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:3:1","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"controller class UserController extends Controller { async info() { const { ctx } = this; ctx.body = { name: `hello ${ctx.params.id}`, // params获取url中的参数。 }; } } ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:3:2","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"router Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系， 框架约定了 app/router.js 文件用于统一所有路由规则。 // app/router.js module.exports = app =\u003e { const { router, controller } = app; router.get('/user/:id', controller.user.info); // 定义/user/1 router.get('/home', controller.home); router.get('/user/:id', controller.user.page); router.post('/admin', isAdmin, controller.admin); router.post('/user', isLoginUser, hasAdminPermission, controller.user.create); router.post('/api/v1/comments', controller.v1.comments.create); // app/controller/v1/comments.js router.resources('topics', '/api/v2/topics', app.controller.topics); }; 路由完整定义主要包括5个主要部分: router.verb('router-name', 'path-match', middleware1, ..., middlewareN, app.controller.action); verb - 用户触发动作，支持 get，post 等所有 HTTP 方法 router.head - HEAD router.options - OPTIONS router.get - GET router.put - PUT router.post - POST router.patch - PATCH router.delete - DELETE router.del - 由于 delete 是一个保留字，所以提供了一个 delete 方法的别名。 router.redirect - 可以对 URL 进行重定向处理，比如我们最经常使用的可以把用户访问的根目录路由到某个主页。 router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 pathFor 和 urlFor 来生成 URL。(可选) path-match - 路由 URL 路径。 middleware1 - 在 Router 里面可以配置多个 Middleware。(可选) controller - 指定路由映射到的具体的 controller 上，controller 可以有两种写法： app.controller.user.fetch - 直接指定一个具体的 controller 'user.fetch' - 可以简写为字符串形式 RESTful 风格的 URL 定义 通过 app.resources 方法，我们将 posts 这个资源的增删改查接口映射到了 app/controller/posts.js 文件。 只需要在 posts.js 里面实现对应的函数就可以了。 Method Path RouteName Controller.Action GET /posts posts app.controllers.posts.index GET /posts/new new_post app.controllers.posts.new GET /posts/:id post app.controllers.posts.show GET /posts/:id/edit edit_post app.controllers.posts.edit POST /posts posts app.controllers.posts.create PUT /posts/:id post app.controllers.posts.update DELETE /posts/:id post app.controllers.posts.destroy ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:3:3","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"单元测试 约定 我们约定 test 目录为存放所有测试脚本的目录，测试所使用到的 fixtures 和相关辅助脚本都应该放在此目录下。 测试脚本文件统一按 ${filename}.test.js 命名，必须以 .test.js 作为文件后缀。 一个应用的测试目录示例： test ├── controller │ └── home.test.js ├── hello.test.js └── service └── user.test.js ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:3:4","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"配置 框架提供了强大且可扩展的配置功能，可以自动合并应用、插件、框架的配置，按顺序覆盖，且可以根据环境维护不同的配置。合并后的配置可直接从 app.config 获取。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:3:5","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"启动自定义 我们常常需要在应用启动期间进行一些初始化工作，等初始化完成后应用才可以启动成功，并开始对外提供服务。 框架提供了统一的入口文件（app.js）进行启动过程自定义，这个文件返回一个 Boot 类，我们可以通过定义 Boot 类中的生命周期方法来执行启动应用过程中的初始化工作。 框架提供了这些 生命周期函数供开发人员处理： 配置文件即将加载，这是最后动态修改配置的时机（configWillLoad） 配置文件加载完成（configDidLoad） 文件加载完成（didLoad） 插件启动完毕（willReady） worker 准备就绪（didReady） 应用启动完成（serverDidReady） 应用即将关闭（beforeClose） 我们可以在 app.js 中定义这个 Boot 类，下面我们抽取几个在应用开发中常用的生命周期函数来举例： // app.js class AppBootHook { constructor(app) { this.app = app; } configWillLoad() { // 此时 config 文件已经被读取并合并，但是还并未生效 // 这是应用层修改配置的最后时机 // 注意：此函数只支持同步调用 // 例如：参数中的密码是加密的，在此处进行解密 this.app.config.mysql.password = decrypt(this.app.config.mysql.password); // 例如：插入一个中间件到框架的 coreMiddleware 之间 const statusIdx = this.app.config.coreMiddleware.indexOf('status'); this.app.config.coreMiddleware.splice(statusIdx + 1, 0, 'limit'); } async didLoad() { // 所有的配置已经加载完毕 // 可以用来加载应用自定义的文件，启动自定义的服务 // 例如：创建自定义应用的示例 this.app.queue = new Queue(this.app.config.queue); await this.app.queue.init(); // 例如：加载自定义的目录 this.app.loader.loadToContext(path.join(__dirname, 'app/tasks'), 'tasks', { fieldClass: 'tasksClasses', }); } async willReady() { // 所有的插件都已启动完毕，但是应用整体还未 ready // 可以做一些数据初始化等操作，这些操作成功才会启动应用 // 例如：从数据库加载数据到内存缓存 this.app.cacheData = await this.app.model.query(QUERY_CACHE_SQL); } async didReady() { // 应用已经启动完毕 const ctx = await this.app.createAnonymousContext(); await ctx.service.Biz.request(); } async serverDidReady() { // http / https server 已启动，开始接受外部请求 // 此时可以从 app.server 拿到 server 的实例 this.app.server.on('timeout', socket =\u003e { // handle socket timeout }); } } module.exports = AppBootHook; 注意：在自定义生命周期函数中不建议做太耗时的操作，框架会有启动的超时检测。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:4:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"中间件 Egg 是基于 Koa 实现的，所以 Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。每次我们编写一个中间件，就相当于在洋葱外面包了一层。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:5:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"加载器 Egg 在 Koa 的基础上进行增强最重要的就是基于一定的约定，根据功能差异将代码放到不同的目录下管理，对整体团队的开发成本提升有着明显的效果。Loader 实现了这套约定，并抽象了很多底层 API 可以进一步扩展。 Egg 是一个底层框架，应用可以直接使用，但 Egg 本身的插件比较少，应用需要自己配置插件增加各种特性，比如 MySQL。 当应用达到一定数量，我们会发现大部分应用的配置都是类似的，这时可以基于 Egg 扩展出一个框架，应用的配置就会简化很多。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:6:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"应用和插件、框架之间的关系 在应用中完成业务，需要指定一个框架才能运行起来，当需要某个特性场景的功能时可以配置插件（比如 MySQL）。 插件只完成特定功能，当两个独立的功能有互相依赖时，还是分开两个插件，但需要配置依赖。 框架是一个启动器（默认就是 Egg），必须有它才能运行起来。框架还是一个封装器，将插件的功能聚合起来统一提供，框架也可以配置插件。 在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承。 Egg 将应用、框架和插件都称为加载单元（loadUnit），因为在代码结构上几乎没有什么差异，目录结构类似有一些差异。 文件 应用 框架 插件 package.json ✔︎ ✔︎ ✔︎ config/plugin.{env}.js ✔︎ ✔︎ config/config.{env}.js ✔︎ ✔︎ ✔︎ app/extend/application.js ✔︎ ✔︎ ✔︎ app/extend/request.js ✔︎ ✔︎ ✔︎ app/extend/response.js ✔︎ ✔︎ ✔︎ app/extend/context.js ✔︎ ✔︎ ✔︎ app/extend/helper.js ✔︎ ✔︎ ✔︎ agent.js ✔︎ ✔︎ ✔︎ app.js ✔︎ ✔︎ ✔︎ app/service ✔︎ ✔︎ ✔︎ app/middleware ✔︎ ✔︎ ✔︎ app/controller ✔︎ app/router.js ✔︎ 文件按表格内的顺序自上而下加载. 加载优先级：插件-\u003e框架-\u003e应用。 插件之间的顺序由依赖关系决定，被依赖方先加载，无依赖按 object key 配置顺序加载； 框架按继承顺序加载，越底层越先加载。 加载时如果遇到同名的会覆盖，可以重写，比如想要覆盖 ctx.ip 可以直接在应用的 app/extend/context.js 定义 ip 就可以了。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:6:1","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"加载器扩展 Loader 的扩展只能在框架进行。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:6:2","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"插件 需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:7:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"常用插件 插件合集eggjs/awesome-egg 插件合集github搜索 egg-cors egg.js作为服务端接受post跨域请求 eggjs/egg-prometheus Prometheus plugin for egg framework. jianglin-wu/egg-exporter 基于 egg-prometheus 开发，增加更多性能指标，为 egg 提供 Prometheus 功能支持。 [egg-redis] 基于ioredis。 egg-Sequelize model定义文件在model目录下，不能存在子目录，而且模型名必须要和模型文件名字符相同（可以不区分大小写） 外键需要定义在model中 const Op = app.Sequelize.Op; 不需要多个关联关系并存，比如使用了belongsTo不用再使用hasMany。但是belongsTo只能用源model联查目标model，如果需要反过来的话，还需要hasOne或者hasMany。 一个model定义中只能出现一个Model.associate=function(){},多条关联关系都写在其中。 'use strict'; module.exports = app =\u003e { const { STRING, INTEGER, DATE } = app.Sequelize; const User = app.model.define('user', { id: { type: INTEGER, primaryKey: true, autoIncrement: true, }, name: STRING(30), age: INTEGER, created_at: DATE, updated_at: DATE, }); User.associate = function() { // 不能使用prototype app.model.User.hasMany(app.model.Post, { as: 'posts' }); }; return User; }; 'use strict'; module.exports = app =\u003e { const { STRING, INTEGER, DATE } = app.Sequelize; const Post = app.model.define('post', { // model名称 id: { type: INTEGER, primaryKey: true, autoIncrement: true, }, title: STRING(30), content: STRING(255), user_id: INTEGER, created_at: DATE, updated_at: DATE, }, { // model 配置 }); //关联 Post.associate = function() { app.model.Post.belongsTo(app.model.User, { as: 'user', foreignKey: 'user_id' }); }; //方法 Post.findByIdWithUser = async function(id, userId) { return await this.findOne({ where: { id, user_id: userId }, }); }; return Post; }; eggjs/egg-router-plus this plugin will auto load router define at app/router/**/*.js. egg-jwt brickyang/egg-bull 增加任务队列。 将process方法放进app.js中。 egg-validate 作用：对参数进行检验。 对API接口参数进行校验。 See parameter for more information such as custom rule. 类别 可能的值 type 属性的类型 Required 若为false，此参数可以为null或undefined。默认为true length convertType Make parameter convert the input param to the specific type, support int, number, string and boolean, also support a function to customize your own convert method. default The default value of property, once the property is allowed non-required and missed, parameter will use this as the default value. This may change the original input params. widelyUndefined override options.widelyUndefined type可能的值 type的值 说明 额外的属性 string: Must be of type string. This is the default type. number Must be of type number boolean Must be of type boolean method: Must be of type function. regexp: Must be an instance of RegExp or a string that does not generate an exception when creating a new RegExp. integer(int) Must be of type number and an integer max,min float: Must be of type number and a floating point number. array: Must be an array as determined by Array.isArray. object: Must be of type object and not Array.isArray. enum: Value must exist in the enum. date: Value must be valid as determined by Date url: Must be of type url. hex: Must be of type hex. email: Must be of type email. any: Can be any type. egg-socket 框架提供了 egg-socket.io 插件，增加了以下开发规约： namespace: 通过配置的方式定义 namespace（命名空间） middleware: 对每一次 socket 连接的建立/断开、每一次消息/数据传递进行预处理 controller: 响应 socket.io 的 event 事件 router: 统一了 socket.io 的 event 与 框架路由的处理配置方式 egg-socket.io 内置了 socket.io-redis，在 cluster 模式下，使用 redis 可以较为简单的实现 clients/rooms 等信息共享。 开启 redis 后，程序在启动时会尝试连接到 redis 服务器 此处 redis 仅用于存储连接实例信息，参见 #server.adapter。 chat ├── app │ ├── extend │ │ └── helper.js │ ├── io │ │ ├── controller │ │ │ └── default.js //对连接之后的数据交互调用此，对socket.id独立 │ │ └── middleware │ │ ├── connection.js //处理链接的时候调用，每次新建连接的时候处理（连接或断开）在配置中`connectionMiddleware`设置 │ │ └── packet.js //针对消息的处理 │ └── router.js ├── config └── package.json 对应的文件都在 app/io 目录下 router（加入router） module.exports = app =\u003e { // app.io.of('/') app.io.route('chat', app.io.controller.chat.index); // app.io.of('/chat') app.io.of('/chat').route('chat', app.io.controller.chat.index); }; Namespace (nsp) namespace 通常意味分配到不同的接入点或者路径，如果客户端没有指定 nsp，则默认分配到 “/” 这个默认的命名空间。 在 socket.io 中我们通过 of 来划分命名空间；鉴于 nsp 通常是预定义且相对固定的存在，框架将其进行了封装，采用配置的方式来划分不同的命名空间。 Room room 存在于 nsp 中，通过 join/leave 方法来加入或者离开; 框架中使用方法相同； 注","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:7:1","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"框架开发 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:8:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"egg-init脚手架工具 新版本增加了microservice 继承自egg-cloud框架。 可以快速开始创建项目工程。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:8:1","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"参考egg-cloud ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:8:2","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"使用框架 配置package.json ... \"egg\":{ \"framework\":\"egg-cloud\" } ... \"dependencies\":{ \"egg-cloud\":\"^0.2.0\" // 不用egg } ... ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:8:3","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"Restful API ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:9:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"生产部署 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:10:0","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"构建 只安装 dependencies 的依赖. $ npm install --production 打包 $ tar -zcvf ../release.tgz . ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:10:1","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"部署 框架内置了 egg-cluster 来启动 Master 进程，Master 有足够的稳定性，不再需要使用 pm2 等进程守护模块。 框架也提供了 egg-scripts 来支持线上环境的运行和停止。 $ npm i egg-scripts --save 添加 npm scripts 到 package.json： { \"scripts\": { \"start\": \"egg-scripts start --daemon\", \"stop\": \"egg-scripts stop\" } } 启动应用$ egg-scripts start --port=7001 --daemon --title=egg-server-showcase 参数 功能 –port=7001 端口号，默认会读取环境变量 process.env.PORT，如未传递将使用框架内置端口 7001。 –daemon 是否允许在后台模式，无需 nohup。若使用 Docker 建议直接前台运行。 –env=prod 框架运行环境，默认会读取环境变量 process.env.EGG_SERVER_ENV， 如未传递将使用框架内置环境 prod。 –workers=2 框架 worker 线程数，默认会创建和 CPU 核数相当的 app worker 数，可以充分的利用 CPU 资源。 –title=egg-server-showcase 用于方便 ps 进程时 grep 用，默认为 egg-server-${appname}。 –framework=yadan 如果应用使用了自定义框架，可以配置 package.json 的 egg.framework 或指定该参数。 –ignore-stderr 忽略启动期的报错。 –https.key 指定 HTTPS 所需密钥文件的完整路径。 –https.cert 指定 HTTPS 所需证书文件的完整路径。 所有 egg-cluster 的 Options 都支持透传，如 –port 等。 更多参数可查看 egg-scripts 和 egg-cluster 文档。 启动配置项也可以在config.{env}.js 中配置指定启动配置。 // config/config.default.js exports.cluster = { listen: { port: 7001, hostname: '127.0.0.1', // path: '/var/run/egg.sock', } } path，port，hostname 均为 server.listen 的参数，egg-scripts 和 egg.startCluster 方法传入的 port 优先级高于此配置。 停止命令$ egg-scripts stop [--title=egg-server]，该命令将杀死 master 进程，并通知 worker 和 agent 优雅退出。 支持以下参数： --title=egg-server 用于杀死指定的 egg 应用，未传递则会终止所有的 Egg 应用。 你也可以直接通过 ps -eo \"pid,command\" | grep -- \"--title=egg-server\" 来找到 master 进程，并 kill 掉，无需 kill -9。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:10:2","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"监控 Node.js 性能平台（alinode） Node.js 性能平台全部功能免费提供给用户使用。 AliNode Runtime 可以直接替换掉 Node.js Runtime。 NSolid ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:10:3","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"前置代理模式（一般都需要反向代理） 一般来说我们的服务都不会直接接受外部的请求，而会将服务部署在接入层之后，从而实现多台机器的负载均衡和服务的平滑发布，保证高可用。 在这个场景下，我们无法直接获取到真实用户请求的连接，从而无法确认用户的真实 IP，请求协议，甚至请求的域名。为了解决这个问题，框架默认提供了一系列配置项来让开发者配置，以便基于和接入层的约定（事实标准）来让应用层获取到真实的用户请求信息。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:10:4","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"docker 基于eggjs修改增加alinode和nginx、https的支持。 [直接在node镜像之上安装alinode，运行时一直不能选择alinode]. 考虑基于toomeefed/docker-alinode进行更改：增加eggjs支持和nginx支持。 eggjs/docker 官方Docker。 没有使用alinode。 没有nginx。 aliyun-node/alinode-docker 非egg。 没有nginx。 ","date":"2019-07-31","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/:10:5","tags":["后端","NodeJs","Egg"],"title":"后端-web框架-node-egg","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-node-egg/"},{"categories":null,"content":"概述 UML 是一种为面向对象开发系统的产品进行说明、可视化、和编制文档的标准语言。 UML 中最重要的建模元素是符号。 适当有效地使用符号对于一个完整的，有意义的模型来说是非常重要的。如果一个模型的目的无法正确的描绘，那么该模型是无用的。 在开始学习 UML 的时候就要强调表示法的重要性，不同的符号可用于表示物件和关系。 可扩展性是 UML 的另一个重要的特点，这使得UML更加强大和灵活。 UML 的核心是图表，大致可以将这些图归类为结构图和行为图。 结构图是由静态图，如类图，对象图等静态图； 行为图是由像序列图，协作图等动态图； ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:1:0","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 概念模型 掌握 UML 概念模型可以通过学习以下三大要素达到： UML构建模块 规则连接构建模块 UML公共机制 一个对象中包含了数据和(控制数据)的方法，其中数据表示对象的状态. 对象是现实世界的实体存在我们周围像抽象，封装，继承，多态的基本概念，都可以使用UML表示。 以下是一些面向对象基本概念： 对象: 对象代表一个实体的基本构建块. 类: 类是对象的蓝图. 抽象化: 抽象代表现实世界中实体的行为. 封装: 封装是将数据绑定在一起，并隐藏他们外部世界的机制。 继承: 继承是从现有的机制作出新的类。 多态性: 定义的机制来以不同的形式存在. ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:2:0","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"图表 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:0","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 类图: 展现了一组对象、接口、协作和它们之间的关系。类图描述的是一种静态关系，在系统的整个生命周期都是有效的，是面向对象系统的建模中最常见的图。 能够让我们在正确编写代码以前对系统有一个全面的认识。 在UML类图中，常见的有以下几种关系:泛化（Generalization）, 实现（Realization）,关联（Association）,聚合（Aggregation）,组合(Composition)，依赖(Dependency)： 泛化(generalization)：表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 实现：是一种类与接口的关系，表示类是接口所有特征和行为的实现。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 关联：可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。即我们代码中成员类变量的关系。箭头指向成员类。 聚合：他体现的是整体与部分拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、汽车和轮胎；表现在代码层面上，和单向关联关系是一致的，只能从语义级别来区分， 在类图使用空心的菱形表示，菱形表示整体； 组合：是整体与部分的关系, 但部分不能离开整体而单独存在.他体现的是一种contains-a的关系， 如公司和部门是整体和部分的关系, 没有公司就不存在部门，这种关系比聚合更强，也称为强聚合；整体的生命周期结束也就意味着部分的生命周期结束； 用带实心菱形的实线表示，菱形指向整体. 依赖：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。与关联关系不同的是，依赖关系是以参数变量的形式传入到依赖类中的，依赖是单向的，要避免双向依赖。一般来说，不应该存在双向依赖。依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖。 【代码表现】：局部变量、方法的参数或者对静态方法的调用 一个完整的类图一般包括3个基本组件：类名、属性、方法。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:1","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 对象图： 对象图是类图的一个实例。因此，一类图的基本要素是类似的。对象图是由对象和链接。在一个特定的时刻，它捕获该系统的实例。 对象图用于原型设计，逆向工程和实际场景建模。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:2","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 组件图： 组件图是一种特殊的UML图来描述系统的静态实现视图。组件图包括物理组件，如库，档案，文件夹等。 此图是用来从实施的角度。使用一个以上的元件图来表示整个系统。正向和逆向工程技术的使用，使可执行文件组件图。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:3","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 部署图： 组件图是用来描述一个系统的静态部署视图。这些图主要用于系统工程师。 部署图是由节点和它们之间的关系。一个高效的部署图是应用软件开发的一个组成部分。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:4","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 用例图: 用例图是从用户角度描述系统功能，并指出各功能的操作者，用来捕捉系统的动态性质。 一个高层次的设计用例图是用来捕捉系统的要求，因此它代表系统的功能和流向。虽然用例图的正向和反向工程是不是一个很好的选择，但他们仍然在一个稍微不同的方法来模拟它。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:5","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 交互图： 交互图，用于捕获系统的动态性质。 交互图包括序列图和协作图，其中：序列图显示对象之间的动态合作关系，它强调对象之间消息发送的顺序，同时显示对象之间的交互；协作图描述对象间的协作关系，协作图跟时序图相似，显示对象间的动态合作关系。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:6","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 状态图： 状态图是一个用于模拟系统的动态性质的五个图。这些图用来模拟一个对象的整个生命周期。 一个对象的状态被定义为对象所在的条件下，特定的时间和对象移动对其他状态，在某些事件发生时。状态图还用于正向和反向工程。 状态图着重描述从一个状态到另一个状态的流程，主要有外部事件的参与。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:7","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"UML 活动图： 活动图是 UML 的动态模型的一种图形，一般用来描述相关用例图，活动图是一种特殊的状态图。 准确的活动图定义：活动图描述满足用例要求所要进行的活动以及活动间的约束关系，有利于识别并行活动。活动图是一种特殊的状态图，它对于系统的功能建模特别重要，强调对象间的控制流程。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:3:8","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"作图工具 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:4:0","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"draw.io ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:4:1","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":null,"content":"具体实现 首先画出类图，确定对象（属性、方法、关系）。 在业务逻辑层，创建对象方法，更改对象状态。 数据库设计，创建对象属性，分为两类：状态类、历史类，一一对应。 ","date":"2019-07-30","objectID":"/post/%E7%BC%96%E7%A8%8B-uml/:5:0","tags":null,"title":"编码-UML","uri":"/post/%E7%BC%96%E7%A8%8B-uml/"},{"categories":["PROGRAM"],"content":"1. main ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:1:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"2. argparse 被 CLICK 代替 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:2:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"3. base64 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:3:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"4. COLLECTIONS ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:4:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"5. datetime ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:5:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"5.1. 属性 datetime.MINYEAR（1）和datetime.MAXYEAR（9999）。 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:5:1","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"5.2. 类 5.2.1. date 5.2.1.1. 实例属性 year、month、day。 5.2.2. time 5.2.2.1. 实例属性 hour, minute, second, microsecond。 5.2.3. datetime 5.2.3.1. 类方法 now() # 当前时刻 5.2.3.2. 实例方法 dt.strftime( '%Y-%m-%d%H:%M:%S %f' ) 5.2.4. timedelta 时间间隔 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:5:2","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"6. enum from enum import Enum,IntEnum,unique # 导入枚举类 from enum import Enum # 继承枚举类 class color(Enum): YELLOW = 1 BEOWN = 1 # 注意BROWN的值和YELLOW的值相同，这是允许的，此时的BROWN相当于YELLOW的别名 RED = 2 GREEN = 3 PINK = 4 class color2(Enum): YELLOW = 1 RED = 2 GREEN = 3 PINK = 4 枚举类不能用来实例化对象. 访问枚举类中的某一项，直接使用类名访问加上要访问的项即可，比如 color.YELLOW. 枚举类里面定义的Key = Value，在类外部不能修改Value值，也就是说下面这个做法是错误的. 枚举项可以用来比较，使用==，或者is. 导入Enum之后，一个枚举类中的Key和Value，Key不能相同，Value可以相，但是Value相同的各项Key都会当做别名. 如果要枚举类中的Value只能是整型数字，那么，可以导入IntEnum，然后继承IntEnum即可，注意，此时，如果value为字符串的数字，也不会报错 如果要枚举类中的key也不能相同，那么在导入Enum的同时，需要导入unique函数. ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:6:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"7. file ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:7:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"8. hashlib不同的安全散列和消息摘要算法 \u003e\u003e\u003e import hashlib \u003e\u003e\u003e hashlib.algorithms_available {'whirlpool', 'md5', 'shake_256', 'BLAKE2s256', 'SHA224', 'blake2s256', 'BLAKE2b512', 'md5-sha1', 'md4', 'sha256', 'sha3_224', 'sha3_384', 'shake_128', 'blake2b512', 'SHA512', 'SHA1', 'sha224', 'RIPEMD160', 'sha3_256', 'SHA384', 'MD5-SHA1', 'sha3_512', 'SHA256', 'MD4', 'sha1', 'sha512', 'MD5', 'sha384', 'blake2s', 'ripemd160', 'blake2b'} \u003e\u003e\u003e hashlib.algorithms_guaranteed {'sha224', 'sha3_256', 'sha384', 'md5', 'shake_256', 'sha256', 'blake2s', 'sha3_224', 'blake2b', 'sha3_384', 'shake_128', 'sha3_512', 'sha1', 'sha512'} \u003e\u003e\u003e m=hashlib.sha512() \u003e\u003e\u003e m.update('helloword') \u003e\u003e\u003e m.update(b'helloword') # 不能是unicode编码 \u003e\u003e\u003e m.hexdigest() 'c3710d9949a3ee2b1c89ec9e9dd154a649aeecc43422222ce3d4de51fa32f021e75123a1b5769aae35c939bf87f333d92ec58192ce5f55fa72e344225027c16e' ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:8:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"9. hmac实现了 HMAC 算法 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:9:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"10. html ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:10:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"11. json ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:11:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"12. logging ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:12:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"13. math ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:13:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"14. os ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:14:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"14.1. def 方法 os.walk([path]) # 遍历path def getAllSub(path): Dirlist = [] Filelist = [] for home, dirs, files in os.walk(path): # 获得所有文件夹 for dirname in dirs: Dirlist.append(os.path.join(home, dirname)) # 获得所有文件 for filename in files: Filelist.append(os.path.join(home, filename)) return Dirlist, Filelist 【1】os.path os.path.abspath(path) #返回绝对路径（__file__当前文件） os.path.basename(path) #返回文件名，去除路径 os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。 os.path.dirname(path) #返回文件路径 os.path.exists(path) #路径存在则返回True,路径损坏返回False os.path.lexists #路径存在则返回True,路径损坏也返回True os.path.expanduser(path) #把path中包含的\"~\"和\"~user\"转换成用户目录 os.path.expandvars(path) #根据环境变量的值替换path中包含的”$name”和”${name}” os.path.getatime(path) #返回最后一次进入此path的时间。 os.path.getmtime(path) #返回在此path下最后一次修改的时间。 os.path.getctime(path) #返回path的大小 os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误 os.path.isabs(path) #判断是否为绝对路径 os.path.isfile(path) #判断路径是否为文件 os.path.isdir(path) #判断路径是否为目录 os.path.islink(path) #判断路径是否为链接 os.path.ismount(path) #判断路径是否为挂载点（） os.path.join(path1[, path2[, ...]]) #把目录和文件名合成一个路径 os.path.normcase(path) #转换path的大小写和斜杠 os.path.normpath(path) #规范path字符串形式 os.path.realpath(path) #返回path的真实路径 os.path.relpath(path[, start]) #从start开始计算相对路径 os.path.samefile(path1, path2) #判断目录或文件是否相同 os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件 os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件 os.path.split(path) #把路径分割成dirname和basename，返回一个元组 os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组 os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组 os.path.splitunc(path) #把路径分割为加载点与文件 os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有 3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有 文件名，args则为walk的第三个参数 os.path.supports_unicode_filenames #设置是否支持unicode路径名 【2】 os.mkdir(path)不会创建， os.makedirs(path)则会创建父目录。 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:14:1","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"15. pathlib ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:15:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"16. pywifi ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:16:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"17. queue 线程安全的队列（FIFO）实现,提供了一个适用于多线程编程的先进先出的数据结构，即队列，用来在生产者和消费者线程之间的信息传递. empty()判断是否为空。 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:17:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"17.1. class 类 17.1.1. Queue 先进先出。 17.1.2. LifoQueue(Queue) 先进后出。 17.1.3. PriorityQueue(Queue) 优先级队列 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:17:1","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"18. random ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:18:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"19. re 文本处理 re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$') # 预编译（正则字符串） r表示不转义 A = re_telephone.match('010-12345').groups() # 使用 print(A) # 结果 ('010', '12345') A = re_telephone.match('010-12345').group(1) # 使用group,指定第几个 A = re_telephone.search('010-12345') # search一般是搜索，比match宽松，match必须是完全匹配字符串 B = re_telephone.match('010-8086').groups() # 使用 print(B) # 结果 ('010', '8086') re.findall() # 可以匹配多次 re.sub([正则],[替换为],[元字符串]) #替换，替换为空即删除 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:19:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"19.1. 元字符（常用） . #匹配除换行符 \\n 之外的任何单字符 ^ #以什么开头 $ #以什么结尾 * #匹配前面的子表达式零次或多次 + #匹配前面的子表达式一次或多次 ? #匹配前面的子表达式零次或一次,或指明一个非贪婪限定符 {} #指明前面的子表达式出现的次数 [] #给定一个匹配池[a-z] \\d #匹配数字 \\D #匹配非数字 \\s #匹配任何空白字符 \\S #匹配任何非空白字符 () #分组 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:19:1","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"20. SHUTIL 文件和文件夹操作 代码 功能 备注 shutil.copytree 复制整个目录树（cp -r） 不能覆盖目标文件夹 shutil.copyfile 复制文件 可以覆盖目标文件 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:20:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"21. socket ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:21:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"22. struct 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送; 按照指定格式将字节流转换为Python指定的数据类型; 处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件; 处理c语言中的结构体; ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:22:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"22.1. 格式字符串 格式字符串的第一个字符可用于指示打包数据的字节顺序、大小和对齐方式。 Character Byte order Size Alignment @(默认) 本机 本机 本机,凑够4字节 = 本机 标准 none,按原字节数 \u003c 小端 标准 none,按原字节数 \u003e 大端 标准 none,按原字节数 ! network(大端) 标准 none,按原字节数 格式符 格式符 C语言类型 Python类型 Standard size x pad byte(填充字节) no value c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I(大写的i) unsigned int integer 4 l(小写的L) long integer 4 L unsigned long long 4 q long long long 8 Q unsigned long long long 8 f float float 4 d double float 8 s char[] string p char[] string P void * long ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:22:1","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"22.2. def 方法 22.2.1. unpack 格式的长度必须和data的长度相等。 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:22:2","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"23. sys 操作系统交互 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:23:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"24. tarfile ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:24:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"25. time ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:25:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"26. timeit ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:26:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"27. threading 见并发编程 ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:27:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"28. unitest ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:28:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"29. urllib ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:29:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"30. venv ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:30:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"31. xml ","date":"2019-07-29","objectID":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/:31:0","tags":["PROGRAM","PYTHON"],"title":"python-标准库","uri":"/post/program-python-06-%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["PROGRAM"],"content":"1. Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库 ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:1:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"2. click 参考Python命令行神器 Click 简明笔记 使用 @click.command()装饰一个函数，使之成为命令行接口； 使用 @click.option()等装饰函数，为其添加命令行选项等。 1. 第一个参数指定了命令行选项的名称，如`--count` 2. option 常用的设置参数如下： default: 设置命令行参数的默认值 help: 参数说明 type: 参数类型，可以是 string, int, float 等；也可以通过 click.Choice([ARRAY]) 来限定可选值 prompt: 当在命令行中没有输入相应的参数时，会根据 prompt 提示用户输入 nargs: 指定此参数接收的值的个数 3. option 提供了两个参数来设置密码的输入：hide_input 和 confirmation_promt，其中，hide_input=true 用于隐藏输入， confirmation_promt=true 用于重复输入；由于上面的写法有点繁琐，click 也提供了一种快捷的方式，通过使用@click.password_option(),增加参数password 4. 改变命令行程序的执行 is_eager=True 表明该命令行选项优先级高于其他选项； expose_value=False 表示如果没有输入该命令行选项，会执行既定的命令行流程； callback 指定了输入该命令行选项时，要跳转执行的函数； 代码中使用 click.echo 进行输出是为了获得更好的兼容性，因为 print在 Python2 和 Python3 的用法有些差别。配合 colorama 这个模块，我们可以使用 click.secho 进行彩色输出。 fg 表示前景颜色（即字体颜色），可选值有：BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE 等； bg 表示背景颜色，可选值有：BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE 等； underline 表示下划线，可选的样式还有：dim=True，bold=True等； 除了使用 @click.option 来添加可选参数，还会经常使用@click.argument(“参数名称”) 来添加固定参数。它的使用和 option 类似，但支持的功能比 option 少。 argument 可以接收不定量的参数。nargs=-1 表明参数 src 接收不定量的参数值，参数值会以 tuple 的形式传入函数。如果 nargs 大于等于 1，表示接收nargs个参数值 ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:2:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"3. Matplotlib ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:3:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"4. numpy 数据预处理 用于【高性能】科学计算和数据分析。 NumPy 最重要的一个特点是其 【N 维数组对象 ndarray】，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。 ndarray 中的每个元素在内存中都有相同存储大小的区域。 创建一个 ndarray 只需调用 NumPy 的 array 函数即可。 numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型 ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:4:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"4.1. def 方法 4.1.1. numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0) 4.1.2. numpy.zeros() 4.1.3. numpy.ones() 4.1.4. numpy.empty() 4.1.5. numpy.arange() ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:4:1","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"4.2. ndarray方法 copy() ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:4:2","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"5. [pywifi] ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:5:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"6. psycopg2 操作PostgreSQL 数据库 ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:6:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"7. requests \u003e\u003e\u003e payload = {'key1': 'value1', 'key2': 'value2'} \u003e\u003e\u003e r = requests.get(\"http://httpbin.org/get\", params=payload) 返回的r是一个reponse对象 r.url 目标的url r.json() 使用json解码 r.encoding text的编码。可以设置 r.text 响应的内容 r.content 以字节的方式访问请求响应体 r.status_code 请求代码 r.headers 响应的头 ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:7:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"7.1. def 方法 7.1.1. get def get(url, params=None, **kwargs) ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:7:1","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"7.2. class 类 7.2.1. Session ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:7:2","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":["PROGRAM"],"content":"8. seaborn Seaborn is a Python data visualization library 【based on matplotlib】. ","date":"2019-07-29","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/:8:0","tags":["PROGRAM","PYTHON"],"title":"python-第三方库","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%80%BB/"},{"categories":null,"content":"使用四种框架分别实现百万websocket常连接的服务器 ","date":"2019-07-27","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E9%AB%98%E5%B9%B6%E5%8F%91websocket%E6%9C%8D%E5%8A%A1/:0:0","tags":null,"title":"后端-web框架-高并发websocket服务","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-%E9%AB%98%E5%B9%B6%E5%8F%91websocket%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"参考微服务之分布式文件系统 搭建独立的文件服务是解决文件共享、释放业务系统压力的最优选择。于是便诞生了分布式文件系统简称OSS(Object Storage Service)，提供的海量、安全、低成本、高可靠的云存储服务。它具有与平台无关的RESTful API接口，能够提供数据可靠性和服务可用性。 ","date":"2019-07-27","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/:0:0","tags":["OSS"],"title":"微服务架构-4-OSS对象存储服务(文件服务)","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"意义 降低WEB服务器压力 独立服务易扩展 统一访问格式 安全认证 ","date":"2019-07-27","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/:1:0","tags":["OSS"],"title":"微服务架构-4-OSS对象存储服务(文件服务)","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"服务选择 Self Hosted File Sharing and Synchronization ","date":"2019-07-27","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/:2:0","tags":["OSS"],"title":"微服务架构-4-OSS对象存储服务(文件服务)","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"Minio Minio是Apache License v2.0下发布的对象存储服务器。它与Amazon S3云存储服务兼容。它最适合存储非结构化数据，如照片，视频，日志文件，备份和容器/ VM映像。对象的大小可以从几KB到最大5TB。 Minio服务器足够轻，可以与应用程序堆栈捆绑在一起，类似于NodeJS，Redis和MySQL。 因为与Amazon S3云存储服务兼容，所以可以被很多框架访问。 原理 存储机制 Minio使用纠删码erasure code和校验和checksum来保护数据免受硬件故障和无声数据损坏。 即便丢失一半数量（N/2）的硬盘，仍然可以恢复数据。 纠删码 纠删码是一种恢复丢失和损坏数据的数学算法，目前，纠删码技术在分布式存储系统中的应用主要有三类，阵列纠删码（Array Code: RAID5、RAID6等）、RS(Reed-Solomon)里德-所罗门类纠删码和LDPC(LowDensity Parity Check Code)低密度奇偶校验纠删码。 Erasure Code是一种编码技术，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。 部署 单点模式 docker run -p 9000:9000 --name minio1 \\ -v /mnt/data:/data \\ -v /mnt/config:/root/.minio \\ minio/minio server /data 集群模式 参考Docker Compose创建minio集群; 分布式的Minio服务至少需要4个节点，所以在docker-compose.yml文件中，至少要配置4个服务。每个服务的command配置必须一样，保证集群环境正常运行。最多共16个。 添加一个服务： a. 复制服务定义并适当地更改新服务的名称。 b. 更新每个服务中的命令部分。 c. 更新要为新服务公开的端口号。 另外，请确保分配给新服务的端口尚未使用。 创建集群之后，使用负载均衡。 使用 mc客户端 JS API 构造函数 var Minio = require('minio') var minioClient = new Minio.Client({ endPoint: 'play.min.io', port: 9000, useSSL: true, accessKey: 'Q3AM3UQ867SPQQA43P2F', secretKey: 'zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG' }); 操作存储桶 makeBucket(名称，区域[,回调函数])创建一个新的存储桶。名称不能是路径。 listBuckets列出所有存储桶。 bucketExists验证存储桶是否存在。 removeBucket删除存储桶。 listObjects列出存储桶中所有对象。 listObjectsV2使用S3 listing objects V2版本API列出所有对象。 listIncompleteUploads列出存储桶中未完整上传的对象。 操作对象 getObject下载对象。 getPartialObject下载对象中指定区间的字节数组，并返回流。 fGetObject下载并将对象保存成本地文件。 putObject(bucketName, objectName, stream, size, metaData[, callback])从一个stream/Buffer中上传一个对象。bucketName相当于根目录，objectName可以包含相对根目录的路径，同名的objectName直接覆盖掉 fPutObject上传文件。会覆盖掉以前的同名文件，即更新 copyObject将源对象拷贝到指定存储桶的新对象中。 statObject获取对象的元数据。 removeObject删除一个对象。 removeIncompleteUpload删除一个未完整上传的对象。 Presigned操作 Presigned URLs用于对私有对象提供临时的上传/下载功能。 presignedUrl生成一个给指定HTTP方法（‘httpMethod’）请求用的presigned URL。浏览器/移动端的客户端可以用这个URL进行下载，即使其所在的存储桶是私有的。这个presigned URL可以设置一个失效时间，默认值是7天。 presignedGetObject生成一个给HTTP GET请求用的presigned URL。浏览器/移动端的客户端可以用这个URL进行下载，即使其所在的存储桶是私有的。这个presigned URL可以设置一个失效时间，默认值是7天。 presignedPutObject生成一个给HTTP PUT请求用的presigned URL。浏览器/移动端的客户端可以用这个URL进行上传，即使其所在的存储桶是私有的。这个presigned URL可以设置一个失效时间，默认值是7天。 presignedPostPolicy允许给POST请求的presigned URL设置条件策略。比如接收上传的存储桶名称、名称前缀、过期策略。 存储桶策略/通知 存储桶可以配置在指定事件类型和相应路径上触发通知。 getBucketNotification 获取指定存储桶名称的通知配置。 setBucketNotification 上传一个用户创建的通知配置，并绑定到指定的存储桶上。 removeAllBucketNotification 删除指定存储桶上的通知配置。 getBucketPolicy获取指定存储桶的访问策略，如果objectPrefix不为空，则会取相应对象前缀上的访问策略。 setBucketPolicy设置指定存储桶的策略。如果objectPrefix不为空，则会给符合该前缀的对象（们）设置策略。 listenBucketNotification 监听存储桶上的通知，可通过前缀、后缀、事件类型进行过滤。使用本API并不需要预先设置存储桶通知。这是Minio的一个扩展API，服务端基于过来的请求使用唯一ID自动注册或者取消注册。返回一个EventEmitter对象，它可以广播一个通知事件。停止监听，调用EventEmitter的stop()方法。 ","date":"2019-07-27","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/:2:1","tags":["OSS"],"title":"微服务架构-4-OSS对象存储服务(文件服务)","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-04-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"UCLOUD ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:1:0","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"ALIYUN ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:0","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"公共云架构及解决方案 web服务器，直达用户。 业务支撑（OLTP）：业务服务器。 查询服务:可以缓解业务服务压力。 BI服务:提供运营相关服务，需要收集各种日志、业务服务数据，存进大数据分析系统中。 服务中间件：消息队列，日志服务，开放搜索等。 网络架构 定义云上网络环境 专有网络VPC（私有） 一个VPC是网络容器，相当于是一个无限扩容的私有机房。 飞天洛神系统。 管理公网流量 弹性公网EIP 支持SNAT/DNAT，既可以让VPC ECS访问Internet，也可以让外部用户从Internet访问。 一个EIP智能绑定一个云产品资源。 多线BGP能力。 一个公网IP。 负载均衡SLB 基于端口的负载均衡； 支持TCP/UDP/HTTP/HTTPS； 用户可自定义健康检查。 没有SNAT功能。 原则：需要两台ECS，而且这两个ECS分在两个可用区。 NAT网关 支持SNAT/DNAT，可以让多台VPC ECS同时访问Internet，并让外部用户从Internet访问。 节约公网成本 共享流量包 1.一份公网带宽，一份公网流量，充分共享。 2. 闲时流量包，可用于从公网同步数据到云下。 共享带宽 一个公网IP，一份流量包。 增强95计费。 构建混合云 高速通道 物理专线，较麻烦。 云托付 托管物理主机。 VPN网关 SSL—VPN IPsec-VPN 智能接入网关 提供设备（包含VPN网关）。 或提供SDK。 全网。 连接全球网络 云企业网 星形。 打通私网。 全球加速 数据库架构 各种数据库产品适应不同产品。不要自建数据库。 存储架构 ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:1","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"ECS 重启之后（注意事项） 挂载硬盘； 配置权限； 实际业务测试。 安全组 概念 网卡类型： VPC网络：只需要设置出方向或入方向的规则，不区分内网和公网。专有网络（VPC）实例的公网访问通过私网网卡映射完成，所以，您在实例内部看不到公网网卡，在安全组里也只能设置内网规则。您设置的安全组规则同时对内网和公网生效。 经典网络：需要分别设置公网或内网的出方向或入方向规则。 规则方向： 出方向：是指ECS实例访问内网中其他ECS实例或者公网上的资源。 入方向：是指内网中的其他ECS实例或公网上的资源访问ECS实例。 不通安全组之间的ECS实例是内网不互通的，但是可以设置互通权限。 默认安全组 内网互联 使用IP地址互联 内网互联的实例数量较少。 直接添加一条内网的安全组规则。 加入到同一个安全组 如果您的网络架构比较简单，实例中部署的业务相同，您就可以为所有的实例选择相同的安全组，绑定同一安全组的实例之间不用设置特殊规则、默认是网络互通的。 也可以将不同安全组加入到一个安全组。 缺点：适用于单一的应用架构，网络架构变更时需要做调整。 绑定互通安全组 为需要互通的实例新添加绑定一个专门互通用的安全组，适用于较为复杂的网络架构。 新建一个安全组，命名为“互通安全组”，不用给新建的安全组添加任何规则。将需要互通的实例都添加绑定新建的“互通安全组”，利用同一安全组的实例之间默认互通的特性，达到内网实例互通的效果。 安全组互信授权 添加安全组规则时，使用安全组访问。 ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:2","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"安全 SSL证书 免费型 DV SSL 证书 填写证书绑定的域名，这里的域名是子域名，不能写顶级域名； 域名验证方式，如果域名使用的是阿里云的 DNS ，那么就可以直接用“自动 DNS验证”，只要这个域名是在账号名下，那么就自动添加 DNS 记录用于验证，否则就手动修改域名的 DNS 记录，或者上传验证文件到网站对应目录；CSR 生成方式默认选择系统生成。 ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:3","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"备案 阿里云文档 ICP备案流程（APP端） 管理查看ICP备案信息 备案信息核查 域名核验 变更备案 可变更备案信息 根据管局规则及规定，备案信息中的部分信息无法变更。 根据相关规定，2019年4月22日起，变更网站信息时，只能对网站域名进行删除，不能修改或新增域名（除不能修改网站域名外，其他信息仍可以修改，例如联系方式、电子邮箱等）。 变更备案时，不能变更备案所在省份。如需变更备案省份，需要重新申请一个目标省份的备案。 有些省市管局不允许直接变更，或您的备案信息已经取消了在阿里云的接入导致无法变更。这种情况下，您需先注销备案后重新申请备案。 阿里云备案账号维护 找回备案账号 判断是否需要导入或认领备案信息 您可在阿里云登录名找回页面输入您备案的域名，拖动滑块完成认证后，单击立即找回，通过页面提示判断您是否需要导入或认领备案信息。 原万网ICP备案信息导入阿里云 导入原万网备案信息 找回原万网备案登录账号及密码：准备资料-\u003e初始化邮箱-\u003e重置登录密码。 导入原万网备案信息。 如果目标账户有正在进行的订单，将不能导入 ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:4","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"NAS文件系统 毫秒级读写。 挂载点 挂载之前需要添加挂载点。 一个挂载点可以有多个客户端连接。 只有在挂载点安全组中的IP才能访问NAS。 ECS安装客户端 sudo apt-get install nfs-common 修改同时发起的NFS请求数量：NFS客户端对于同时发起的NFS请求数量进行了控制，默认编译的内核中此参数值为2，严重影响性能，建议修改为128（使用ROOT用户）。 echo \"options sunrpc tcp_slot_table_entries=128\" \u003e\u003e /etc/modprobe.d/sunrpc.conf echo \"options sunrpc tcp_max_slot_table_entries=128\" \u003e\u003e /etc/modprobe.d/sunrpc.conf 重启ECS cat /proc/sys/sunrpc/tcp_slot_table_entries查看。 配置自动挂载 打开 /etc/fstab 配置文件； 配置自动挂载 file-system-id.region.nas.aliyuncs.com:/ /mnt nfs vers=3,nolock,proto=tcp,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,_netdev,noresvport 0 0 reboot. ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:5","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"RDS 数据安全性：设置白名单。 ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:6","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":null,"content":"块存储（系统盘和数据盘） 微秒级读写。 扩容比较麻烦。 ","date":"2019-07-15","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/:2:7","tags":null,"title":"运维-选择公有云产品","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-%E9%80%89%E6%8B%A9%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"},{"categories":["设计模式"],"content":"摘自《极客时间x王争|设计模式之美》 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:0:0","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"1. 解决的问题 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:1:0","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"1.1. 提高代码质量 解决命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等问题。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:1:1","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"1.2. 提高复杂代码的设计和开发能力 如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？等等问题。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:1:2","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"1.3. 提高阅读源码的能力 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:1:3","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"1.4. 提高Leader相关能力 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:1:4","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2. 评价代码质量 代码质量的评价具有很强的主观性。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:0","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.1. 可维护性* 对于一个项目来说，维护代码的时间远远大于编写代码的时间。 在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码(可读性、可扩展性)。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:1","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.2. 可读性* Any fool can write code that a computer can understand. Good programmers write code that humans can understand. 编码规范尤其重要。 代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等. code review是一个很好的测验代码可读性的手段。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:2","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.3. 可扩展性* 在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。 代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。 涉及到后边的设计原则对修改关闭，对扩展开放. ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:3","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.4. 灵活性 易扩展也可以说灵活性好。 原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。易复用。 接口易用。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:4","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.5. 简洁性（简单、复杂） 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。 KISS. ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:5","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.6. 可复用性 当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性； 当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关； 当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。 DRY ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:6","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"2.7. 可测试性 代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:2:7","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"3. 方法论 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:3:0","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"3.1. 面向对象（思想） 面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。 3.1.1. 面向对象的四大特性：封装、抽象、继承、多态 3.1.1.1. 封装 封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。 对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。 【解决问题】提高可读性，防止误操作。 【解决问题】将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。 3.1.1.2. 抽象 如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。 常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。 类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。 【意义】而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。 【解决问题】在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。 3.1.1.3. 继承 is-a. 单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类， 有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。 【意义】代码复用。 【意义】反应真实世界中的关系，非常符合人类的认知。 【但是】过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。 3.1.1.4. 多态 多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。 多态这种特性也需要编程语言提供特殊的语法机制来实现。 第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。 第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。 第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add () 方法。 除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法[两个对象有相同的方法]。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。 【duck-typing】只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。 【意义】多态特性能提高代码的可扩展性和复用性。 3.1.2. 面向对象编程与面向过程编程的区别和联系 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。 OOP 更加能够应对大规模复杂程序的开发. OOP 风格的代码更易复用、易扩展、易维护。 1. 基于多态这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。 2. 除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。 3.1.3. 面向对象分析、面向对象设计、面向对象编程（哪些代码设计看似是面向对象，实际是面向过程的） 围绕着对象或类来做需求分析和设计. 分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。 面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程. 不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。 3.1.3.1. 滥用 getter、setter 方法 提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。 违反了面向对象编程的封装特性（通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据）。 在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。 除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。 3.1.3.2. 滥用全局变量和全局方法 在面向对象编程中，常见的全局变量有单例类对象（单例类对象在全局代码中只有一份它相当于一个全局变量）、静态成员变量（被所有的实例化对象所共享）、常量（一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类）等，常见的全局方法有静态方法（一般用来操作静态变量或者外部数据，各种 Utils 类，里面的方法一般都会定义成静态方法）。 定义一个如此大而全的 Constants 类，并不是一种很好的设计思路. 1. 在开发过程中，可能都要涉及修改这个类,影响代码的可维护性。 2. 增加代码的编译时间(单元测试)。 3. 影响代码的复用性。 【优化】将 Constants 类拆解为功能更加单一的多个类；并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。 只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。 【优化】确实有必要去定义这样一个 Utils 类，那就大胆地去定义它；针对不同的功能，设计不同的 Utils 类。 3.1.3.3. 定义数据和方法分离的类 传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。 这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。 3.1.4. 接口和抽象类的区别以及各自的应用场景 从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。 3.1.4.1. 抽象类 抽象类不允许被实例化，只能被继承。 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。 子类继承抽象类，必须实现抽象类中的所有抽象方法。 抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。（is-A） 3.1.4.1.1. 存在的意义 代码复用。 【如果用普通类】达到多态必须要有方法定义，但是方法有子类实现。如果父类定义一个空的方法，影响可读性；其次子类会忘记重写；可以被实例化，会被误用。所以要有抽象类。 3.1.4.2. 接口 接口不能包含属性（也就是成","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:3:1","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"3.2. 设计原则 对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。 是其他的指导原则。 3.2.1. SOLID 原则 -SRP 单一职责原则 3.2.1.1. 如何理解 一个类或者模块(多个类组成一个模块)只负责完成一个职责（或者功能）。 实际使用中，拆分是模糊的，需要结合具体的应用场景和角度。（用户展示信息，用户认证信息，用户物流信息） 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。 3.2.1.2. 如何判定 类中的代码行数(200)、函数或属性过多(10)，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性； 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰； 类中大量的方法都是集中操作类中的某几个属性. 3.2.1.3. 防止过渡使用 如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。 3.2.2. SOLID 原则 -OCP 开闭原则（对扩展开放，对修改关闭） 这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。 3.2.2.1. 如何理解 软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。 只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。 尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。 以最小的修改代码的代价来完成新功能的开发。 3.2.2.2. 如何做到 偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。 在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候。 在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。 3.2.2.3. 具体方法 利用多态、依赖注入、基于接口而非实现编程以及大部分的设计模式，来实现“对扩展开放、对修改关闭”。 对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。 在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。 3.2.3. SOLID 原则 -LSP 里式替换原则 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。 【验证的窍门】拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。 一般情况下，我们写的代码都不怎么会违背它。 里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。 3.2.3.1. 多态和里氏替换原则的区别 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。 【按照协议来设计】子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。 3.2.3.2. 违反的例子 子类违背父类声明要实现的功能； 子类违背父类对输入、输出、异常的约定； 子类违背父类注释中所罗列的任何特殊说明。 3.2.4. SOLID 原则 -ISP 接口隔离原则 客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。 理解接口隔离原则的关键，就是理解其中的“接口”二字. 3.2.4.1. 把“接口”理解为一组 API 接口集合 在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。 3.2.4.2. 把“接口”理解为单个 API 接口或函数 接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现. 单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。 部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。 3.2.4.3. 把“接口”理解为 OOP 中的接口概念 那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。 3.2.5. SOLID 原则 -DIP 依赖倒置(依赖反转)原则 3.2.5.1. 控制反转（IOC） 自己写main函数和使用框架（在框架预留的扩展点，填充具体的代码就可以了，完全不需要写负责执行流程的 main() 函数），典型的通过框架实现控制反转。 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。 3.2.5.2. 依赖注入（DI） 是一种具体的编码技巧。 用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。“开闭原则”。当然，还有继续优化的空间，依赖的类定义成接口，基于接口而非实现编程。 编写可测试性代码最有效的手段。 3.2.5.3. 依赖注入框架（DI Framework） 而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架(依赖注入框架)来自动完成。 只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。 现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要。 3.2.5.4. 依赖反转原则（DIP） 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。 在调用链上，调用者属于高层，被调用者属于低层。 这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。 Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范. 3.2.6. KISS 原则、YAGNI 原则 3.2.6.1. KISS 尽量保持简单。 一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。 本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。 【方法】不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。 【方法】不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。 【方法】不要过度优化。不要过","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:3:2","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"3.3. 重构技巧 设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。 在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。 重构代码对一个工程师能力的要求，要比单纯写代码高得多。重构需要你能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。 3.3.1. 重构的目的（why）、对象（what）、时机（when）、方法（how） Martin Fowler:重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。 在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。 3.3.1.1. WHY 首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。 其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。重构代码也是不可避免的。 最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。 重构对一个工程师本身技术的成长也有重要的意义。重构非常锻炼一个人的代码能力。 初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码. 3.3.1.2. WHAT 笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）。 高层次重构:对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。 小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用我们能后面要讲到的编码规范。 3.3.1.3. WHEN 一条可持续、可演进的方式持续重构. 时刻具有持续重构意识.(没事儿的时候重构、顺手重构) 3.3.1.4. HOW 在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段(一天)来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。 大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。 小重构，随时。除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。 3.3.2. 保证重构不出错的技术手段：单元测试和代码的可测试性 【如何保证重构不出错】熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）。 3.3.2.1. 什么是单元测试？ 单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。 集成测试的测试对象是整个系统或者某个功能模块。单元测试的测试对象是类或者函数（代码层级）。 更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。 3.3.2.2. 为什么要写单元测试？ 单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。 单元测试能有效地帮你发现代码中的 bug。坚持写单元测试是保证代码质量的一个“杀手锏”，也是帮助拉开与其他人差距的一个“小秘密”。 单元测试能帮你发现代码设计上的问题。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。 单元测试是对集成测试的有力补充:利用mock 的方式，控制 mock 的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。 写单元测试的过程本身就是代码重构的过程. 阅读单元测试能帮助你快速熟悉代码.程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到“不言自明”。 单元测试是 TDD 可落地执行的改进方案:测试用例先于代码编写很难执行；先写代码，紧接着写单元测试，更加容易被执行，又兼顾了TDD的优点。 3.3.2.3. 如何编写单元测试？ 写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。 在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比如，Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。 不耗时；质量可以放低一些； 很多现成的工具专门用来做覆盖率统计，比如，JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖。将覆盖率作为衡量单元测试质量的唯一标准是不合理的。 从过往的经验上来讲，一个项目的单元测试覆盖率在 60～70% 即可上线。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求。 单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。 写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足(不满足肯定代码测试性不好)。在公司内部，起码团队内部需要统一单元测试框架。 3.3.2.4. 如何在团队中推行单元测试？ 首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（ownership），毕竟光靠 leader 督促，很多事情是很难执行到位的。 3.3.3. 代码的可测试性 写出可测试的代码反倒是件非常有挑战的事情。 3.3.3.1. 什么是代码的可测试性？ 代码的可测试性可以从侧面上反应代码设计是否合理。 所谓代码的可测试性，就是针对代码编写单元测试的难易程度。 3.3.3.2. 如何写出可测试的代码？ 【注】如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。 【注】mock 的方式主要有两种，手动 mock 和利用框架 mock。利用框架 mock 仅仅是为了简化代码编写，每个框架的 mock 方式都不大一样。 手动实现mock,非单例类即继承原有类，编写一个子类。通过依赖注入。单例类，可以创建一个中间类隔离一下，来间接调用单例类。 【注】代码中包含跟“时间”有关的“未决行为”逻辑。一般的处理方式是将这种未决行为逻辑重新封装。将未决行为逻辑重新封装为一个方法（然后使用匿名内部类的方式，重写这个方法）。 3.3.3.3. 有哪些常见的不好测试的代码（Anti-Patterns反模式） 代码中包含未决行为。所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。 滥用全局变量。类变量。 滥用静态方法。主要原因是静态方法也很难 mock。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中 mock 这个静态方法。除此之外，如果只是类似 Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 mock。 使用复杂继承。如果我们利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要 mock 类所组合依赖的对象即可。 高耦合代码。 3.3.3.4. 讨论 提供方法的类不要new，也就是我们常说的service类，这个是要依赖注入的。提供属性的类，比如vo，bo，entity这些就可以new。 3.3.4. 通过封装、抽象、模块化、中间层等【解耦】代码（大型重构） 3.3.4.1. “解耦”为何如此重要？ 利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。 提高代码的可读性和可维护性。 “高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。 代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。 3.3.4.2. 如何判定代码是否需要“解耦”？ 把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。 配合间接的衡量标准(修改代码会不会牵一发而动全身)一块来使用。 3.3.4.3. 如何给代码“解耦”？ 3.3.4.3.1. 封装与抽象 3.3.4.3.2. 中间层 引入中间层能简化模块或类之间的依赖关系。 四阶段重构：第一阶段：引入一个中间","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:3:3","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["设计模式"],"content":"3.4. 编程规范 解决可读性的问题。 比较偏向于记忆，你只要照着来做可以。 3.4.1. 命名(主要目的是解释“做什么”)和注释 对于影响范围比较大的命名，比如包名、接口、类名，我们一定要反复斟酌、推敲。实在想不到好名字的时候，可以去 GitHub 上用相关的关键词联想搜索一下，看看类似的代码是怎么命名的。 3.4.1.1. 命名多长（以能准确达意为目标，换位思考） 对于一些默认的、大家都比较熟知的词，用缩写。sec 表示 second、str 表示 string、num 表示 number、doc 表示 document。 对于作用域比较小的变量，我们可以使用相对短的命名。 对于类名这种作用域比较大的，用长的命名方式。 3.4.1.2. 利用上下文简化命名 类的成员变量。 函数的参数。 3.4.1.3. 命名要可读、可搜索 不要用一些特别生僻、难发音的英文单词来命名。 最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦。 3.4.1.4. 命名接口和抽象类 对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService。另一种是不加前缀，比如 UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl。 对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如 AbstractConfiguration；另一种是不带前缀“Abstract”。 只要项目里能够统一就行。 3.4.1.5. 注释写什么 /** * (what) Bean factory to create beans. * * (why) The class likes Spring IOC framework, but is more lightweight. * * (how) Create objects from different sources sequentially: * user specified object \u003e SPI \u003e configuration \u003e default object. */ public class BeansFactory { // ... } 注释起到总结性作用、文档的作用. 对于有些比较复杂的类或者接口，我们可能还需要在注释中写清楚“如何用”，举一些简单的 quick start 的例子，让使用者在不阅读代码的情况下，快速地知道该如何使用。 代码中间插入总结性的注释来让代码结构更清晰、更有条理。 3.4.1.6. 注释的经验 类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。 3.4.2. 代码风格（Code Style） 在团队、项目中保持风格统一，让代码像同一个人写出来的，整齐划一。 3.4.2.1. 类、函数多大才合适？ 间接的判断标准，那就是，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。 3.4.2.2. 一行代码多长最合适？ 一行代码最长不能超过 IDE 显示的宽度。 3.4.2.3. 善用空行分割单元块 在代码之间、类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。 3.4.2.4. 四格缩进还是两格缩进？ 跟业内推荐的风格统一、跟著名开源项目统一。 推荐2格。 3.4.2.5. 大括号是否要另起一行？ 将括号放到跟语句同一行。 3.4.2.6. 类中成员的排列顺序 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类。在 Google 编码规范中，依赖类按照字母序从小到大排列。 在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected 的，最后是 private 的。 3.4.3. 编程技巧 ","date":"2019-07-15","objectID":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/:3:4","tags":["设计模式","PROGRAM"],"title":"设计模式-思想-原则","uri":"/post/program-%E8%B7%A8%E8%AF%AD%E8%A8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%80%9D%E6%83%B3-%E5%8E%9F%E5%88%99/"},{"categories":["项目管理"],"content":"参考GitLab 工作流概览 GitLab 是一个基于 git 的仓库管理程序，也是一个方便软件开发的强大完整应用。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:0:0","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"1. 软件开发阶段 一般情况下，软件开发经过 10 个主要阶段；GitLab 为这 10 个阶段依次提供了解决方案： IDEA： 每一个从点子开始的项目，通常来源于一次闲聊。在这个阶段，GitLab 集成了 Mattermost。（开始一个项目） ISSUE： 最有效的讨论一个点子的方法，就是为这个点子建立一个工单讨论。你的团队和你的合作伙伴可以在 工单追踪器issue tracker 中帮助你去提升这个点子。 PLAN： 一旦讨论得到一致的同意，就是开始编码的时候了。但是等等！首先，我们需要优先考虑组织我们的工作流。对于此，我们可以使用 工单看板Issue Board。（backlog） CODE： 现在，当一切准备就绪，我们可以开始写代码了。 COMMIT： 当我们为我们的初步成果欢呼的时候，我们就可以在版本控制下，提交代码到功能分支了。 TEST： 通过 GitLab CI，我们可以运行脚本来构建和测试我们的应用。 REVIEW： 一旦脚本成功运行，我们测试和构建成功，我们就可以进行 代码复审code review 以及批准。 STAGING：： 现在是时候将我们的代码部署到演示环境来检查一下，看看是否一切就像我们预估的那样顺畅——或者我们可能仍然需要修改。 PRODUCTION： 当一切都如预期，就是部署到生产环境的时候了！ FEEDBACK： 现在是时候返回去看我们项目中需要提升的部分了。我们使用周期分析 Cycle Analytics来对当前项目中关键的部分进行的反馈。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:1:0","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"2. GitLab 工单追踪器 就是一个sprint backlog。每一个sprint就是一个milestone，一个项目的里程碑可以升级到组中，组中具有相同的里程碑会合并。。 包含了一个backlog看板。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:2:0","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"3. 通过 GitLab 进行代码复审 在merge request页面，可以进行评论，也可以Insert suggestion进行代码的建议修改。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:3:0","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"4. 构建、测试以及发布 Auto DevOps ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:4:0","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"4.1. 静态代码测试 4.1.1. SonarQube 由于 SonarQube 使用 Elasticsearch 作为全文模糊搜索引擎，故需要设置如下内核参数。 # 查看 $ sysctl vm.max_map_count # max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量 $ sysctl fs.file-max $ ulimit -n # 查看文件句柄数 $ ulimit -u # 查看最大用户进程数 # 实时修改生效 $ sysctl -w vm.max_map_count=262144 $ sysctl -w fs.file-max=65536 $ ulimit -n 65536 $ ulimit -u 4096 # 永久生效 $ echo \"vm.max_map_count=262144 fs.file-max=65536\" \u003e /etc/sysctl.d/99-sysctl.conf $ /sbin/sysctl -p 安装运行，使用官方文档中的Docker Compose.yml作为参考。 首次使用admin和admin登陆。 安装C++检查工具,在gitlab-runner容器中，安装apt-get install cppcheck，不用和sonarqube在一台机器中. 安装插件‵sonar-cxx-plugin-x.y.z.jar‵【Sonar C++ plugin只是完成了报告的读取，并没有任何代码分析的功能】. 1. 下载jar文件，拷贝到SONARQUBE_HOME/extensions/plugins； 2. 1. 重启sonarqube实例； 3. 【Administration】-\u003e【Marketplace】-\u003e【Plugins】查看插件已经安装成功. 4. 新建一个【Quality Profiles】,选择CXX，并在右上角设置里，设为默认。 5. 【rules】中选择CXX，然后选择【Repository】选择检查工具,如cppcheck，点击【Bulk Change】应用在自定义的Quality Profiles中。 clang-tidy 跨平台。 6. 【重要】需要设置一个选项，【Administration】-\u003e【Configuration】-\u003e 【General Settings】-\u003e 【CXX】-\u003e【File suffixes】 必须设置。 7. 【重要】【Administration】-\u003e【Configuration】-\u003e 【General Settings】-\u003e 【CXX External Analyzers】需要设置文件名称。 接下来，有两个选择：a,安装sonar-scanner，手动扫描；b,安装gitlab-plugin插件，每次提交都会检查一次,但是Only SonarQube \u003c 7.7, because preview mode is removed有限制。 1. 下载[sonar-scanner](https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/); 2. 配置/etc/profile [root@localhost local]# vim /etc/profile export SONAR_HOME=/usr/local/sonarqube-6.7.5 export SONAR_SCANNER_HOME=/usr/local/sonar-scanner PATH=$PATH:$SONAR_HOME/bin:$SONAR_RUNNER_HOME/bin [root@localhost local]# source /etc/profile 增加用户，生成token，编写sonar-project.properties文件。 #sonarqube服务器地址sonar.host.url=[ip+port]sonar.login=[token]#使用token，不用配passwd#项目唯一标识（不能出现重复）sonar.projectKey=key#项目名称sonar.projectName=name#源代码目录sonar.sources=src#版本号sonar.projectVersion=V1.0.0#语言sonar.language=CXX#源代码文件编码sonar.sourceEncoding=UTF-8sonar.cxx.clangtidy.reportPath=cppcheck-report.xml 使用.先执行cppcheckcppcheck --xml --xml-version=2 --enable=all ./ 2\u003ecppcheck-report.xml，然后执行sonar-scanner. ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:4:1","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"4.2. 发布 4.2.1. 文档发布 Gitlab Pages的原理： 1. 首先，当你新建一个Gitlab项目的时候，你同时也建了一个存储库。 2. 只要你的工程目录的根目录下有.gitlab-ci.yml文件，注意必须严格起这个名字。gitlab runner就会执行这个脚本文件。 3. 脚本的最终目的很简单：把静态文件放入名为public目录下的文件夹内。Gitlab pages会一直去这个存储库的public目录找。注意：这个public是指存储库的public，与项目结构无关。换言之，这个public目录不可见。 4. 也就是说：当你在项目的根目录下添加了.gitlab-ci.yml，且在脚本中将静态文件正确地放入了public文件夹，gitlab page就会自动打开并部署，部署的域名将会默认分配。 Gitlab Pages默认是没有使能的，需要在配置文件中打开。 使用CI配置文件，必须使用pages作为job的名称，必须使用public文件夹作为附件。 4.2.1.1. Doxygen生成文档放进public中 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:4:2","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5. 使用gitlab的11条军规 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:0","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.1. 使用功能分支-不直接提交（commit）到 master 分支 使用 Git 时，任何正在进行的操作，都应为之创建一个分支（branch），以便最终在合并（merge）之前进行代码审查（code review）。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:1","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.2. 测试所有的提交-不仅仅只在 master 分支上 有些人将 CI 系统设置为只测试合并到 master 分支的东西。这太迟了！总是拥有绿色的 master 测试（译者注：绿色在 CI 里通常意味着测试通过，而红色意味着测试失败），人们会觉得有信心。例如，在开始开发新功能之前，人们不得不测试 master 分支那是没有意义和荒谬的。CI 并不昂贵，所以这样做是最好的。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:2","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.3. 在所有的提交上-运行所有的测试 如果你的测试时间长于 5 分钟则让它们并行； 如果您正工作在一个功能分支并添加新提交（commit），请随之运行测试。如果测试需要很长时间，请尝试并行运行。合并请求（merge requests）时，在服务器端来执行此操作以运行完整的测试套件。如果你有一个用于开发的测试套件，而另一个测试套件你只为新版本运行；那么设置并行测试并运行全部测试套件是值得的。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:3","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.4. 在合并到 master 之前执行代码审查，而不是事后审查 不要在一周结束时测试一切。当场就搞！这样你更有可能抓住可能导致问题的东西，而其他人也会努力提出解决方案。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:4","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.5. 部署是自动的，并基于分支或标签（tag） 如果您不想每次都部署 master 分支，那么你可以创建一个 production 分支；但你没理由用脚本（script）或登录到某个地方手动操作。自动化一切，或以特定分支来触发生产部署。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:5","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.6. 标签（tag）是由用户设置的，而不是由 CI 创建 应由用户来打标签（tag），并且基于此，CI 将执行一个动作。不应让 CI 去更改代码库。如果你需要非常详细的指标，你应该【有一个服务器报告】来详细说明新版本。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:6","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.7. 发布（release）是基于标签（tag）的 如果你打了 tag，则意味着创建了一个新版本。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:7","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.8. 永远不对已推送的提交（pushed commits）进行变基（rebase） 当你推送（push）到公共分支后，你就不该对其变基，因为这样会很难跟进你正在改进的内容，很难跟进测试结果是什么，而且它打破了 cherry-picking。有时我们在审查流程的后期要求代码贡献者合并及变基（git merge –squash），以使一些东西容易还原时，我们也会违背这一规则。但一般而言，准则是：代码应干净，修改历史应真实。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:8","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.9. 每个人都从 master 分支开始工作，目标也是 master 分支 这意味着没有任何长期分支。你可以检出 master 分支，构建功能，创建合并请求，并再次指向到 master 分支。在合并之前，应该进行完整的代码审查，而不应在代码审查和合并间存在任何中间阶段。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:9","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.10. 在 master 分支中修正错误，其次再到发布分支 如果你发现 bug，最糟的事莫过于你在刚发布的版本里修复了它，而未在 master 分支修复。为避免这种情况，应总是向前修复（fix forward）。在 master 中修复，然后 cherry-pick 到其他补丁发布分支。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:10","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"5.11. 提交信息（commit message）应体现意图 不仅要说明你做了什么，还应说明为什么这么做。如果解释一下为什么这么做，而不是用其他方式，这会更加有用。 ","date":"2019-06-26","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/:5:11","tags":["项目管理","GIT"],"title":"SCRUM+GITLAB-FLOW","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-03-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-gitlab-flow/"},{"categories":["项目管理"],"content":"搜集网路上的关于CRUM的实施","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"参考Scrum实践指南：一个可运行的 Scrum是怎样的 参考如何实施 SCRUM ？ ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:0:0","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"1. 定义 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:1:0","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"1.1. 定义 Scrum 是一个用于开发和维护复杂产品的框架，是一个增量的、迭代的开发过程，【敏捷开发的一种】。 在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个Sprint，每个Sprint的长度是2到4周。 在Scrum中，使用产品Backlog来管理产品的需求。产品backlog按照实现的优先级进行排序，以商业价值作为排序的主要原则。在Sprint中，Scrum团队从产品Backlog中挑选最高优先级的需求进行开发。挑选的需求在Sprint计划会议上经过讨论、分析和估算得到相应的任务列表，称它为Sprint backlog。当Scrum团队完成Sprint backlog列表中的所有任务时，本次Sprint结束，进入下一个Sprint迭代周期。 Scrum能够保证优先开发对客户具有较高价值的需求，更好的满足用户的需求； 与瀑布流程下的开发方式相比较，通过实施Scrum，能够提升团队一倍的开发效率，最大限度的发挥团队的作用； Scrum能够缩短开发周期，提高项目的交付效率。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:1:1","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"1.2. 目的 1.2.1. 适应变化 Scrum 的一个基本假设，就是外部需求模糊而难以理解。Scrum 对此的理念是：让客户直接看到半成品，他们才知道自己要什么。很多 Scrum 的原则都是围绕如何解决这个问题的：比如每个 Sprint 结束时由 Product Owner 为客户进行展示，又比如任务细化一般不超过一个 Sprint。理解了这一点，才会理解为什么 Scrum 似乎总在变化，因为需求总在变化。 1.2.2. 快速迭代 Scrum 的另一个基本假设，是团队生存在一个快速变化且充满竞争的世界。如果自己一年半才能发布一个新版本，而竞争对手半年就能发布，那么几年之内，我们就会被对手甩得远远的。Scrum 对此的理念是：发布即 Milestone（里程碑），宁可每次发布二十个功能发布五次，也不要在内部搞五个 Milestone 然后一口气发布一百个功能。理解了这一点，才会理解为什么 Scrum 会认为发布时砍功能是一种正常情况而非一种失败。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:1:2","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"1.3. 不足 因为发布周期缩短，团队没有能力保证作出的每一个决定都正确，很多开销都必须花在试错上； 快速发布实际上导致 Scrum 团队的抗风险能力弱于瀑布模型团队，因为一个人的离职或病假都可能对单一功能的进度造成影响，不利于短期频繁发布。 Scrum 对此的解答是：不要试图不犯错误，而是保证小的错误能被尽快发现从而不会酿成大错。所以 Scrum 过程中总会有些不确定性，或者功能不合需求而返工，或者突然缺了人手导致一些单个功能必须延期完成。如果非要事先确定发布周期而且还得保证不许功能裁剪，请出门左转找 CMM 认证：它可以把任务精确到每个对话框上该用什么字体。前期计划精确到这个粒度，什么都可以在掌控之中。但问题是，我们必须用更长的发布周期来换。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:1:3","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2. 实施 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:0","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.1. 确定PO PO即Product owner，是一个角色，PO是管理产品待办列表的唯一责任人。当然，在有些公司PO也可能作为一个组织而存在——比如我们公司在实施Scrum中就将PO作为了一个组织。如果将PO作为一个组织运行，在这一个组织中必须选出一个Owner。 作为owner，必须具有大局观；深刻了解行业信息与走向；能够把握产品的方向，担负起产品短期以及中长期的规划与管理；能够根据公司战略要求，进行用户研究和产品功能规划，深度跟踪、分析、挖掘不断变化的需求，不断进行产品创新。 另外，如果将PO作为一个组织，在软件开发项目中，PO小组可能包括的成员有产品经理、业务方、视觉设计师、交互设计师以及架构师等。 在多数情况下，由产品经理或交互设计师担任Owner。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:1","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.2. 组建team team是产品蓝图的真正实施者，负责在每个Sprint结束时交付潜在可发布并且“完成”的产品增量。 team主要包括开发及测试人员，team必须能够落实PO对产品的设想。 team的规模宜小不宜大，一般5~9人较为合适。 在敏捷开发中倡导的是团队人员的“全栈”能力，但目前在大多数互联网公司可能难于落实，比如多数互联网公司前后端开发是分离的，所以在组建team团队时需要特别关注前后端开发人员投入的比例。 以我带的2017年开发的小程序为例，前端和后端人员投入的比例为2:3时，能够最大限度的提升项目的开发效率——当然，这个比例必须基于项目中前后端所承担的具体开发任务情况而定，而不是随性给出。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:2","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.3. 选择Scrum Master Scrum Master为过程负责，服务于PO和开发团队。Scrum Master要有仪式感，能够有效地、高效的组织迭代计划会、每日站立会、功能演示会、迭代回顾会等；Scrum Master必须具有高度的执行力，并保持公信力，能够帮助团队聚焦交付目标和质量目标，确保团队高效交付高质量的产品；推动团队建立高效的流程，指导团队了解敏捷价值观、原则和敏捷实践；负责培训团队其他成员，确保Scrum得到正确运用；促进团队有效的交流协作、问题管理、冲突解决，帮助团队消除一切障碍。 2.3.1. 具体的工作 确保流程执行正确。进入 Scrum 之后，很多团队仍然会以各种方式走老路，比如有意无意地拉长 Sprint 周期，并以此区别计划周、开发周和测试周，实际上是把原来三个月的瀑布开发周期变成了两到四个星期的瀑布周期；又比如以开发时间有限为理由把自动测试开发任务缩减为手工测试。好的 Scrum Master 应该有能力发现并制止这种情况。——顺便说一句，相信我，不要以为两个星期的瀑布周期是个可行的开发计划，我们不可能完成测试任务的。 制止官僚主义流程。典型的例子就是一个又一个的 spec/plan review 和 sign-off 邮件；又比如非要区分所谓 Unit Test、BVT 和 Functional Test：或许对一个图形界面程序来说这两者区别极大，可对于函数库则几乎没有原则差别。合格的 Scrum Master 应该制止这样的倾向。——不过我也得说，这一条我现在做得很差，还需要改进。 构建交叉知识结构。整个团队的知识模型应该是各有专长但互有交叉的，而传统开发的一个很重要的问题是知识结构不平衡，比如测试的只管测试，开发的只管开发。这种模式对于发布时间长的大团队来说也许能接受，但对人手短缺又要求快速发布的小团队则是致命的。好的 Scrum Master 应当能够对团队的决策具备影响力，确保不会让某个任务陷入「只有一个人知道细节」的情况。——这一条在习惯了传统瀑布开发模型的团队中往往是最大的阻碍，需要时间改善。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:3","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.4. 维护产品需求池 产品需求池是所有用户故事的集合(Product backlog 每一条就是一个用户故事)，由PO依据公司的战略和产品愿景进行的思考。PO按照产品实现的优先级顺序对产品需求池的所有用户故事进行排序，并形成产品待办事项列表（ Product Backlog workbook），产品待办事项列表相当于产品研发的“路线图”，要想了解产品的脉络，产品待办事项是最好的参考依据。 我们每一天都面对着新的竞争者和用户新的诉求，这意味着PO必须不断地优化自己的产品设计，并对产品待办事项列表实现的优先顺序进行调整。 在这一过程中，PO应该与所有利益相关者和团队进行协商，以确保产品待办事项能够反映用户的真实诉求。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:4","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.5. 故事点（story point）评估 相对精确的评估工作一般都是在冲刺计划会上进行，并由负责实际开发及测试工作的团队对产品待办事项做出评估。 在实践过程中为了让冲刺计划会更高效，在冲刺计划会之前PO与Scrum Master会作出一个粗略的评估。看看冲刺计划是否切实可行？要完成这些事项，现有的信息是否足够？用户故事拆分是否合理？在开发团队进行评估时，建议摒弃传统的“人天”评估法，采用故事点的方式，用斐波那契数列的数字（1，2，3，5，8，13，21……）的形式去评估。 评估时team需要首先确定一个用户故事为作为评估的参照。另外，特别注意的是当评估的单个故事点大于21的时候，用户故事需要进行再次拆分，单个用户故事点数不超过8是最理性的状态。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:5","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.6. 冲刺（SPrint）计划会 这是第一场真正意义上的Scrum会议。Team、Scrum Master、PO坐到一起，规划冲刺的内容（Sprint backlog）。作为软件开发项目，进入规划冲刺的用户故事，用户故事应该已拆分完成，并且完成了视觉设计。 冲刺周期一般是固定的，大部分是2至4周。团队要从产品待办事项列表优先级最高的用户故事着手，看看一个冲刺迭代中能完成多少。 如果团队已经开展过多个冲刺迭代，通过参考前几次迭代中完成的“故事点数”，团队可能预估到本次迭代完成的大概故事点数。“故事点数”相当于团队的速度。Scrum Master与Team应努力在每一个冲刺迭代中提高这个数字。 对于冲刺目标，即在一个冲刺迭代需要完成的事项，team所有成员都应该形成共识。在冲刺计划会上，PO需要告诉team用户故事实现的优先级顺序。team承诺在下一次冲刺迭代中他们能够完成多少用户故事。在冲刺的过程中，任何人不能单方面擅自变更冲刺内容。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:6","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.7. 每日站立会 这是Scrum的活力源泉。站立会参加人员一般包括PO、Scrum Master、team。团队每天在固定地点、固定时间进行内部沟通，时间一般为早晨，时长不超过15分钟，且站立进行，Scrum Master向team成员提出下列问题： 你昨天完成了哪些工作？ 你今天计划做哪些工作？ 目前的困难及障碍？ 这样做的意义在于：让整个团队清楚地知道在这一个冲刺周期内各项任务的进展，所有任务是否能够按时完成。 Team的任务都不是自上而下分派的，而是自主决定、自愿申领的。如果前一个任务没有完成时，不能申领下一个任务，不能同时申领2个在当天不能完成的任务。 Scrum Master负责消除团队面临的障碍。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:7","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.8. 项目看板及燃尽图 在Scrum中，必须做到工作透明化，最常见的做法是实施项目看板制度。 有的团队善于借助第三方工具使用电子看板，比如Redmine看板，Leangoo看板；有的团队乐于使用线下物理看板。 无论使用电子看板，还是物理看板，看板的栏目大致包括待办事项、进行中事项以及已完成事项三个部分。随着迭代进度的推进，由Team每天及时将事项转移到对应看板栏目下。 让工作透明化的另一个工具是燃尽图。在这张图中，一个轴代表工作量，另一个轴代表时间。每天Scrum Master都会记录待完成的剩余点数，而后画在燃尽图上。理想情况下，该图是一条向下的曲线，随着剩余工作的完成，“燃尽”至零。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:8","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.9. 功能演示（Sprint评审会议） 在《Scrum指南》中将此环节称为Sprint评审会议，书中认为Sprint评审会议应该包括开发团队演示完成的工作并解答关于所交付增量的问题、评审市场或者潜在的产品使用方式所带来的接下来要做的最有价值的东西的改变、为下个产品版本功能或能力的发布评审时间表、预算、潜在功能和市场等多个会议主题。 会议一般在在本次迭代冲刺发布前召开。不过，从实践来看，我更倾向于此次会议最重要的工作是功能和成果演示，验证用户故事的实现场景，并接受评价。 这是一场公开的会议，任何人都可以是参与者，不仅仅包括PO、Scrum Master及team，还包括利益相关者、业务方与管理者，乃至客户。 团队应该只展示那些符合“完成定义”的事项，也就是全部完成，不需要再做工作就能交付的成果。这个成果或许不是完整的产品，但至少是一项完整的、可以使用的功能。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:9","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"2.10. 冲刺回顾会 冲刺回顾会一般在本次迭代发布之后的第二天召开，会议时间最好不做具体的限制。 冲刺回顾会要认真分析以下几个问题： 发生了哪些有待改进的事； 为什么会发生那件事； 为什么我们当时忽略了； 怎样才能加快工作进度。 作为一个团队，要让这个冲刺回顾过程有效，团队需要相互信任。必须记住基于项目和技术问题的讨论和争论；对事不对人，不当和事佬，鼓励技术碰撞；不能把技术和业务讨论牵扯到人身攻击上去；抵制带着有色眼睛看人，引导大家理性讨论；勇敢接受别人的挑战，接受自己的不完美 大家要对自己的流程和结果负责，要集思广益，共同寻求问题解决之道。这一点是至关重要的。 最后，团队确定一个最值得改善的地方，将其设定为下一个冲刺迭代的首要任务，当然，改善的结果必须通过“验收测试”。你如何证明自己成功地完成了改善？你需要用具体的、可操作的方式界定什么是“成功”，这样，在下一个冲刺回顾会议中才能很快判断出是否已完成改善。 上一个冲刺迭代结束之后，开始进入新的冲刺迭代。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:2:10","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"3. 实施Scrum带来的变化 通过在Scrum项目中的实践，给我们的团队和项目组带来的变化主要有： 组织 在瀑布流程下，通常会设置包括业务方、产品经理、项目经理、开发人员、测试人员、交互设计师、视觉设计师等多个角色，由于强化了不同角色的定位，而且不同角色又隶属于不同的职能部门，无形中增加了项目协同的难度。 在Scrum项目实施中，仅设置了PO小组、master和team团队这样的角色和组织，而且大家在一起集中办公，很大程度上淡化了角色隶属关系，形成了团队合力和向心力。 内聚 团队合作的要旨是提高团队的内聚性，内聚也体现在个人工作焦点上，避免了一个人同一时段身兼多责。每个人都需要长时间的深度思考和环境浸染，如果天天在会上赶会，必定是失败的。 节奏 用用户故事和站立会、冲刺会的形式，重构项目过程，细致而又绵密，灵活而又紧凑，减少时间死角，让需求等人而非人等需求。 尽早与客户互动 实施Scrum，极大的缩短了发布周期，让我们的用户及早的感知产品，这对保持正确的产品航道有极大的帮助，也能更好的帮助公司做好战略上的决策。 透明 作为敏捷实践，项目看板制度是必不可少的，通过项目看板制度，项目成员每天完成的任务情况一目了然，团队目标感明确，显著增强了工作的主动性和能动性。 心态 深刻剖析和本地化执行scrum敏捷方法论，持续自省，自我革命，破除僵化流程，解除自我保护，项目团队能够“就事论事”的讨论问题，解决了管理“人”的难题。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:3:0","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4. 可以使用的工具 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:0","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4.1. TEAMBITION **** 10人以下免费使用 4.1.1. 项目管理 4.1.2. 团队知识库 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:1","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4.2. ONES ***** 10人以下限制使用。 优势：集成了PIPELINE和测试用例管理。 4.2.1. ONES PROJECT 单项目 ONES Project 无缝支持 Scrum 与 DevOps 的完整流程，摒弃分散系统带来的成员和数据的割裂， 使协作更紧密，数据反馈更及时，团队表现更优异。 4.2.2. ONES PLAN ONES Plan 以管理者视角进行全局项目进度管控和高效项目集管理，有效评估及安排项目资源，为中高层项目管理人员提供决策支持。 多项目总览，管理者可掌控项目全局。 4.2.3. ONES PIPELINE ONES Pipeline 帮助团队快速搭建完整工具链，实践业界领先的 DevOps 流程。 4.2.4. ONES TESTCASE 用例管理与缺陷追踪方案 随着软件开发规模增大、复杂程度增加，测试工作的组织、管理显得尤为重要。ONES TestCase 提供全流程的解决方案，帮助团队提高测试效率，保证交付质量。 4.2.5. ONES WIKI ONES Wiki 是立体的知识管理方案，支持文档协作、知识沉淀和团队知识学习， 帮助团队向知识型组织迈进。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:2","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4.3. GITLAB FLOW ***** ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:3","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4.4. Sprints *** 完美支持敏捷开发团队，进行项目管理与协作，快速交付伟大的产品！ 没有免费版本。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:4","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4.5. Leangoo **** 个人版永久免费。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:5","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"4.6. Worktile *** Worktile 是新一代企业协作办公平台，专注于解决企业员工的工作效率，从而提升企业竞争力。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/:4:6","tags":["项目管理","SCRUM"],"title":"组织管理-SCRUM","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-02-scrum%E6%95%8F%E6%8D%B7/"},{"categories":["项目管理"],"content":"敏捷开发最佳实践","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"参考ones的敏捷研发管理解决方案 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:0:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"1. 需求规划 产品经理需要将客户、用户的反馈，以及经过市场调研的结果整理出来，通过用户故事的方式描述，形成需求池。 需求是以用户的角度做一个简单的功能阐述。基础格式如下： 作为某个角色，我可以做某些事情，以便于（得到）某些好处/价值。 在项目中创建需求这一任务类型进行需求池管理。产品经理在需求池中录入需求单，需求单中应包含完整的描述、以及相关的产品文档、高保真原型等后续研发过程中需要参考的资料，方便进行评审以及后续研发过程的流转。功能比较复杂的需求会被拆分为几个颗粒度较小的需求，以子任务的方式存在。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:1:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"2. 规划产品版本 产品经理需要根据产品的开发路线图制定一个或多个发布计划来进行版本规划。包括规划版本需求、设定版本负责人和发布时间，并估算共需要几轮迭代。通常一次发布计划的周期为 2-6 月的周期不等，包括 4-5 轮迭代。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:2:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"3. 规划迭代 确定好发布计划后，由项目经理来明确每轮迭代当中应该完成哪些需求。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:3:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"3.1. 创建迭代并进行规划 包括设定好迭代的开始和完成时间、迭代阶段、排列需求优先级等。 什么是迭代 迭代是指把一个复杂且开发周期很长的开发计划，分解为很多小周期可完成的任务，这样一个周期就是一次迭代的过程。同时每一次迭代都可以生产或开发出一个或多个可以交付的功能。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:3:1","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"3.2. 拆分需求 将需求规划进迭代之后，即可进行需求拆分。此时项目经理组织产品经理、开发工程师、测试工程师参加本次迭代的需求说明会。每个需求由产品经理对价值点作出评估、并由研发工程师对拆分后的研发任务进行工时评估，最终由项目经理根据迭代的整体统计情况进行工作量的调整或需求的删减。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:3:2","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"3.3. 撰写测试用例 确认当前迭代包含的需求后，测试工程师即可根据需求，新建测试模块，撰写测试用例。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:3:3","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"4. 开发阶段 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:4:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"4.1. 关联代码仓和 Jenkins（gitlab完成相似功能issues,pipeline） 研发经理可以通过持续集成平台，将代码构建过程与项目和迭代整合到一起，实现可视化交付管理。 ones的设计 代码仓库集成：配置关联之后，团队项目成员可以在代码提交时通过输入包含 #任务 ID 的方式，和任务进行关联。 持续集成关联：配置关联之后，Jenkins 中的构建和部署结果将可以同步至 ONES Project 的迭代中。 关联之后，Project 的任务可跳转至代码仓，迭代中可查看产品构建和部署结果。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:4:1","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"4.2. 更新任务状态 进入研发阶段后，每个成员在完成当前任务后及时更新任务状态，任务将根据提前设置好的后置动作自动流转，提醒相关成员。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:4:2","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"4.3. 跟踪迭代进度 4.3.1. 燃尽图 在迭代过程中，团队可以通过燃尽图更直观地了解当前迭代进度的健康程度。 什么是燃尽图 燃尽图是在迭代完成之前，对剩余工作量的一种可视化表示。由横轴（X）和纵轴（Y）组成，横轴表示时间，纵轴表示剩余工作量。蓝色实线表示截止到当天还剩余的未完成的任务数量；蓝色虚线是基线，表示期望的工作进度。 当剩余工作量高于基线时，则表示进度偏紧急，可能无法准时完成目标。当剩余工作量低于基线时，则表示进度较为乐观，甚至可能于周期内提前完成工作量。 4.3.2. 迭代看板 在迭代过程中，团队可以通过看板视图，以卡片的形式浏览和跟踪项目进度。 在敏捷开发过程中，通常还会通过每日例会的方式对迭代进行跟踪。这个时候可以通过仪表盘清晰地了解每个成员的工作状况和迭代所处阶段。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:4:3","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"4.4. 持续集成可视化 敏捷开发提倡持续交付。ONES 支持在迭代中查看持续集成、构建和部署结果，只需配置 ONES Pipeline 产品，将任务和迭代与代码仓、持续集成工具进行关联即可。 （1）查看代码构建结果： （2）查看代码质量统计分析： （3）查看自动化测试结果： （4）查看部署结果： ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:4:4","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"5. 测试阶段 测试工程师需要在提交开发任务后进行测试，提缺陷并跟踪缺陷单修复进展。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:5:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"5.1. 安排测试 测试工程师可以根据当前迭代需求对应的用例，创建测试计划，将用例规划进去。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:5:1","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"5.2. 提缺陷 测试工程师可以直接在用例执行后提交相应的 bug，生成 Project 项目中的缺陷类任务。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:5:2","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"5.3. 缺陷追踪 缺陷类任务生成后，可指派给不同的研发人员进行修复。缺陷单详情包括了关联的用例和执行结果，还可添加关联需求、优先级等信息。 测试工程师可以通过工作流来紧密跟踪缺陷单状态。发现 bug 后移交给研发工程师修复，研发工程师确认后更新任务状态同时进行修复，修复后再次移交给测试工程师进行验收。若验收不通过，则再次移交给研发工程师，直至该 bug 被修复或者挂起为止。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:5:3","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"5.4. 自动化测试结果可视化 在 ONE Pipeline 当中配置好自动化测试之后，即可在迭代中查看自动化测试结果。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:5:4","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"5.5. 缺陷分析报表 ONES 可以根据研发场景需要，生成相应的质量报告，例如缺陷分布统计、缺陷状态滞留时间统计。测试工程师可以使用报表对迭代范围内、或者项目范围内的缺陷进行统计，评估研发质量，跟踪缺陷修复情况。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:5:5","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"6. 回顾与沉淀 当一个迭代完成并发布之后，项目经理会组织全体成员对整个迭代的研发过程进行回顾，检查发生的事情，分析自己的工作方式，找出改进办法，制定改进计划，并将相应的经验以文档的方式沉淀下来。 ONES Wiki 支持这一过程，每个成员都可以整理自己的经验和知识，沉淀到团队知识库。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:6:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["项目管理"],"content":"7. 收集用户反馈 产品发布后，运营人员需要通过多种渠道关注并收集用户反馈，并将处理后的反馈整理成相应的优化点和问题，反馈给产品经理，为下一轮的产品规划做准备。 ONES Project 可以通过开启插件的方式，收集应用评论，生成任务。 ONES 软件研发项目管理结合敏捷开发和 DevOps 最佳实践，适合各个行业和各种规模的研发团队开展项目管理。帮助团队把控产品节奏，跟踪研发进度和质量，高效高质量地交付产品。 ","date":"2019-06-25","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/:7:0","tags":["项目管理","GIT"],"title":"ONES敏捷研发","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-scrum-one-%E6%95%8F%E6%8D%B7%E7%A0%94%E5%8F%91/"},{"categories":["PROGRAM"],"content":"包含相关的内建函数","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":" 4种基本数据类型：整数，浮点数，字符串，布尔值 type() ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1. 字符串 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"1.1. 字符串驻留 由于Cpython在编译优化时, 某些情况下会尝试使用已经存在的不可变对象而不是每次都创建一个新对象。这种行为被称作字符串的驻留[string interning]。 发生驻留之后, 许多变量可能指向内存中的相同字符串对象，从而节省内存。 在上面的代码中, 字符串是隐式驻留的. 何时发生隐式驻留则取决于具体的实现.。 所有长度为 0 和长度为 1 的字符串都被驻留。 字符串在编译时被实现 (‘wtf’ 将被驻留, 但是 ‘'.join([‘w’, ‘t’, ‘f’]) 将不会被驻留)不会被驻留。 字符串中只包含字母、数字或下划线时将会驻留. 所以 ‘wtf!’ 由于包含 ! 而未被驻留. 当在同一行将 a 和 b 的值设置为 “wtf!” 的时候, Python 解释器会创建一个新对象, 然后同时引用第二个变量(注: 仅适用于3.7以下，3.7是不一样的). 如果你在不同的行上进行赋值操作, 它就不会“知道”已经有一个 wtf！ 对象 (因为 “wtf!” 不是按照上面提到的方式被隐式驻留的). 它是一种编译器优化, 特别适用于交互式环境. 常量折叠(constant folding) 是 Python 中的一种 窥孔优化(peephole optimization) 技术. 这意味着在编译时表达式 ‘a’*20会被替换为’aaaaaaaaaaaaaaaaaaaa’ 以减少运行时的时钟周期. 只有长度小于 20 的字符串才会发生常量折叠. 在 3.7 版本中, 常量折叠已经从窥孔优化器迁移至新的 AST 优化器, 后者可以以更高的一致性来执行优化可支持长度大于20的常量折叠. ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2. 序列（有序，下标访问） 字符串、列表、元组都属于序列。 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.1. 序列的基本操作 in(not in) []切片 +连接 *重复 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:1","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.2. 序列unpack 比如a,b=\"12\" ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:2","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.3. 序列内建函数 filter()过滤。 len()长度。 list()转换为序列。 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:3","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.4. 序列比较大小 相对应的元素进行大小比较（从左至右依次，判断出大小即停止）。 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:4","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"2.5. 列表 2.5.1. 有数组a，要求去掉a所有为0的元素 a = [2,4,0,8,9,10,100,0,9,7] # 方法1：Filter a= filter(None, a) # 方法2：Lambada a = filter(lambda x: x != 0, a) # 方法3：for for b in a: if b == 0: a.remove(b) ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:5","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"3. 字典 key经过hash运算。可以是字符串、数字、float、tuple。不可以重复。 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"4. 集合 \"集合主要对字符串或列表(可以是数字列表)，不能是数字\" \"创建集合\" set() .add() \"把要传入的元素做为一个整个添加到集合中\" .update() \"是把要传入的元素拆分，做为个体传入到集合中\" .remove() \"删除操作\" \u0026 \"交集\" | \"并集\" - \"差集\" a.issubset(b) \"判断a是否是b的子集\" a.issuperset(b) \"判断a是否是b的父集\" 一文带你了解 Python 集合与基本的集合运算 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"5. bytes bytes() 可将整数内容的序列变位bytes字符串。 ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"6. 枚举(enum) 使用标准库中的enum模块. ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:6:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["PROGRAM"],"content":"7. 类型转换 int() float() str() bool() ","date":"2019-06-21","objectID":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:7:0","tags":["PROGRAM","PYTHON"],"title":"python数据类型","uri":"/post/program-python-02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"mathpix 将图片变为LATEX公式。 ","date":"2019-06-20","objectID":"/post/%E7%BC%96%E8%BE%91-latex/:1:0","tags":null,"title":"编辑-LATEX","uri":"/post/%E7%BC%96%E8%BE%91-latex/"},{"categories":null,"content":"在线公式识别 ","date":"2019-06-20","objectID":"/post/%E7%BC%96%E8%BE%91-latex/:2:0","tags":null,"title":"编辑-LATEX","uri":"/post/%E7%BC%96%E8%BE%91-latex/"},{"categories":null,"content":"截屏 ","date":"2019-06-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/:0:0","tags":null,"title":"图片分享","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/"},{"categories":null,"content":"浏览器端 最直接的方案是Canvas。 1将浏览器中当前DOM的内容渲染到Canvas中，（niklasvh/html2canvas），再将Canvas对应的imageData传到服务器解析。 2将DOM对应的HTML转化为SVG不建议使用。 使用canvas也有一些限制. 纯前端的解决方案对一些简单项目还行，复杂的还是依赖服务端更靠谱些. ","date":"2019-06-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/:1:0","tags":null,"title":"图片分享","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/"},{"categories":null,"content":"服务端 主流的互联网编程语言都有个实现的库，java有selenium，php有imagegrabscreen，python有PIL，nodejs的phantomjs和puppeteer，实现上也都比纯前端方案成熟稳定，效率也高。 当然也有问题，比如不好处理异步请求渲染的内容等等。 所以如果想要达到比较好的效果，前后端结合的方案靠谱，前端上传截屏位置大小信息和页面内容等信息，服务端截图，截图后再发回前端预览。 ","date":"2019-06-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/:2:0","tags":null,"title":"图片分享","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/"},{"categories":null,"content":"phantomjs fzaninotto/screenshot-as-a-serviceA simple screenshot web service powered by Express and PhantomJS. Forked from screenshot-app. 参考phantomjs实现服务端屏幕截图. ","date":"2019-06-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/:2:1","tags":null,"title":"图片分享","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/"},{"categories":null,"content":"puppeteer 和phantomjs对比，摘自phantomjs与puppeteer简单对比(截图功能). 优于phantomjs 基于notadd/docker-puppeteer-chinese debain版本 或者基于截图的诱惑：Docker部署Puppeteer项目 alpine版本 注意：puppeteer会出现截全图不全的情况。screenshot fullpage will not fully has full page content . 所以要使用Puppeteer Full Page Screenshot,It takes multiple screenshots internally then merges them.他会截取多张图片然后合并。 const puppeteer = require(\"puppeteer\");\rconst fullPageScreenshot = require(\"puppeteer-full-page-screenshot\");\rconst browser = await puppeteer.launch();\rconst page = await browser.newPage();\rawait page.setViewport({ width: 1920, height: 1080 });\rawait page.goto(url);\rctx.logger.debug(typeof(fullPageScreenshot.default));\rawait fullPageScreenshot.default(page, { path: \"./page.png\" });\rawait browser.close();\rreturn;\r 注意:不可能每响应一次请求，就创建一次Browser。参考使用 generic-pool 优化 puppeteer 并发问题. generic-pool 不可能每一次都启动和关闭一个 puppeteer 实例，generic-pool 就要出场了。 使用手册 page [class] 等待 page.waitForNavigation(options) page.waitFor(selectorOrFunctionOrTimeout[, options[, …args]]) page.waitForSelector(selector[, options]) page.waitForXPath(xpath[, options]) page.waitForFunction(pageFunction[, options[, …args]]) DOCKER FROM buildkite/puppeteer ","date":"2019-06-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/:2:2","tags":null,"title":"图片分享","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/"},{"categories":null,"content":"文件访问 注：直接用nginx托管的静态文件，总存在favicon.ico请求，干扰微信小程序的下载。 所以，需要使用原生框架渲染接口，参考原生koa2实现静态资源服务器. ","date":"2019-06-20","objectID":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/:3:0","tags":null,"title":"图片分享","uri":"/post/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB/"},{"categories":null,"content":"INSTALL ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:1:0","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"download ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:1:1","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"./configure configure: error: a Fortran compiler is required to build Octave:sudo apt-get install gfortran configure: error: BLAS and LAPACK libraries are required:sudo apt-get install libblas-dev libatlas-base-dev liblapack-dev ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:1:2","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"sudo make install ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:1:3","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"语法 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:0","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"基本操作 %为注释。 PS1('\u003e\u003e')更改提示符。 在语句后加;可以阻止打印输出。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:1","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"基本计算 支持基本数学运算。 支持判断运算符：==（等于）、~=（不相等）、\u0026\u0026（与）、||（或）。 pwd返回octave的安装路径。 cd ''改变路径。 ls列出文件。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:2","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"内建函数 函数 功能 xor 异或 sqrt 求根 cos 余弦函数（弧度制） sin 正弦函数（弧度制） tan 正切函数（弧度制） exp 指数函数（$e^{x}$） 对矩阵每个元素求解 log 以e为底的指数函数 log10 sinh tanh cosh acos acosh asin asinh atan atan2 atanh abs 对矩阵中所有元素取绝对值 sign round floor ceil fix rem -V 对矩阵中所有元素取反 1/V 对矩阵中所有元素取导数 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:3","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"变量 a=3定义一个变量，并赋值3. b='hello'定义一个字符串变量。 c=(3\u003e=1)定义一个bool类型的变量。 disp(a)显示变量a的值或直接a回车。 disp(sprintf('2 decimals: %0.2f', a))格式化输出。 format long显示默认的位数。 format short显示少量的位数。 who显示octave在内存中存储的所有变量。 whos显示octave在内存中存储的所有变量的更详细的信息。 clear删除所有变量。 clear 变量名删除指定变量。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:4","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"向量和矩阵 A=[1 2;3 4;5 6]产生一个3行2列的矩阵A。 v=[1 2 2]定义一个行向量。 v=1:0.1:2定义一组数，从1开始，步长为0.1一直增加到2.1x11的矩阵。 v=1:6定义[1 2 3 4 5 6]. ones(2,3)生成2X3的矩阵，元素都为1. zeros(1,3)生成1X3的矩阵，元素都为0； rand(3,3)生成3X3的矩阵，元素为随机数（0~1之间）。 randn(1,3)服从高斯分布，均值为0.标准差或者方差为1. hist(w,50)绘制一个矩阵的直方图，并指定柱的数目。 eye(n)生成n维的单位矩阵。 size(A)返回矩阵的大小（维数）即一个1X2的矩阵。 size(A,1)返回矩阵A第一维度的大小。 length(A)返回矩阵A较大的那个维数，通常对变量使用。 v=priceY(1:10)将priceY的前10个元素赋给v. A(3,2)获得第3行第二列的元素。 A(3,:)获得第三行的全部元素。 A([1,3],:)获得第1行和第3行的全部元素。 A(:,2)=[10;11;12]将A的第2列元素替换。 A=[A,[100;101;102]]在A的右边追加一列元素。 A(:)将A中的所有元素放进一个列向量。 c=[A B]将A和B放进一个矩阵中。 C=[A;B]将B放在A的下方。 A*CA和C矩阵相乘。 A.*B将矩阵A和矩阵B的对应元素进行相乘。点号用来表示元素的运算。 A'求A的转置。 max(A)获得A中最大元素。 [val, ind]=max(A)val为A中最大的元素，ind为此值的索引。 find(a\u003c3\u003e)找到小于3的元素，返回他们的索引。 magic(3)返回幻方的方阵，他的任一行、列、对角线的和相同。 [r,c]=find(A\u003e=7)r为大于等于7的行号，c为大于等于7的列号。 sum(A)求矩阵所有元素的和。sum(A,1)取每一列的和。sum(A,2)取每一行的和。 prod(A)求所有元素的积。 floor(A)所有元素向下取整。 ceil(A所有元素向上取整。 max(rand(3),rand(3))取两个随机矩阵中的大值组成新的矩阵。 max(A,[],1)取每一列的最大值 。 max(A,[],2)取每一行的最大值。 flipud(A)使矩阵A竖直反转。 pinv(A)求逆。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:5","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"文件 load xxxx.dat和load('xxxx.dat')加载数据，并生成以文件名命名的变量。 save hello.mat v将变量v保存为hello.mat的文件（二进制）。 save hello.txt v -ascii将变量保存为用ascii编码的文档。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:6","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"图形绘制 plot(x, y1)绘制图形,会清除原有图形。plot(x, y, x, h, '.-')绘制多条线。 hold on不清楚原有图形，叠加绘图。 xlabel('x')添加 x 轴标签。 ylabel('Sin(x)')添加 y 轴标签。 title('Sin(x) Graph')添加标题。 grid on显示网格线。 axis equal使横轴和纵轴的间隔相等。 legend('Sin(x)', 'Cos(x)')在图形中添加图例。 axis([xmin xmax ymin ymax])设置xy轴的刻度。 subplot(m, n, p)创建子图。 输入多条命令用逗号隔开。 figure给图形标号 print -dpng ‘myPlot.png’保存图形，保存图形到 ‘myPlot.png’ 文件中，保存目录为当前工作路径。 close关闭图形 clf清除图形. bar()绘制条形图。 meshgrid 命令是用于产生一个矩阵的元素，赋予 x xx 和 y yy 的范围内进行了在每一种情况下的增量同规格一起。 [x, y] = meshgrid(-5: 0.1: 5, -3: 0.1: 3); % g = x.^2 + y.^2; % 函数 g [C, h] = contour(x, y, g); % 绘制等高线图 set(h, 'ShowText', 'on', 'TextStep', get(h, 'LevelStep')*2); surf(x, y, g)绘制三维图. imagesc(A)将矩阵A中的元素数值按大小转化为不同颜色，并在坐标轴对应位置处以这种颜色染色imagesc(x,y,A) x,y决定坐标范围，x,y应是两个二维向量. colorbar在上图中加入颜色指示条。colormap gray将颜色变为灰度。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:7","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"控制语句 % FORfor i=1:10, V(i) = 2^i;end;\u003e\u003e indices = 1:10;\u003e\u003e for i=indices, disp(i); end;\u003e\u003e while i \u003c= 5, disp(V(i)); i = i+1; end;\u003e\u003e while true, disp(V(i)); if i \u003e 5, break; end; i = i + 1; end; ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:8","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"定义函数 在Octave中，定义一个函数需要使用function 关键字，然后紧跟在 function 后面的是函数的声明，包括返回值，函数名称和参数，之后换行来实现具体的函数功能。 Octave的函数不需要显式的返回语句，Octave会将函数第一行声明的返回值返回给调用方，因此，我们在函数体中只需将最终的计算结果赋给定义的返回值。 \u003e\u003e function [y1, y2] = calVal(x) y1 = x^2; y2 = x^3; end; 在该目录下新建一个文件名为“squareThisNumber.m”后缀是.m这样octave可以自动识别。（注意：文件名要和函数名保持一致）。在octave中直接调用就可以。 addpath(\"\")添加函数搜索路径。 代价函数。 \u003e\u003e X=[1 1;1 2;1 3;1 4] \u003e\u003e Y=[1;2;3;4] ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:2:9","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"内置函数 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:3:0","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"fminunc 自动的从众多高级优化算法中挑选一个来使用(你也可以把它当做一个可以自动选择合适的学习速率aa的梯度下降算法)。 ","date":"2019-06-20","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/:3:1","tags":null,"title":"数据科学-OCTAVE","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-octave/"},{"categories":null,"content":"LA5016 ","date":"2019-06-19","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA/:1:0","tags":["嵌入式"],"title":"嵌入式-逻辑分析仪","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA/"},{"categories":null,"content":"使用 选择通道（chanel）； 设置出发条件。 选择解析器。 ","date":"2019-06-19","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA/:1:1","tags":["嵌入式"],"title":"嵌入式-逻辑分析仪","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA/"},{"categories":null,"content":"配置 默认情况下，uWSGI会在第一个启动的进程中加载整个应用，并在加载完毕之后，会将自己多次fork()。这是常见的Unix模式，这能够显著降低应用的内存使用量，允许使用一些有趣的技巧，同时对于某些语言来说，这也会给你带来一些令人头疼的问题。 --lazy-apps ","date":"2019-06-11","objectID":"/post/%E5%90%8E%E7%AB%AF-uwsgi/:1:0","tags":["后端"],"title":"后端-uWSGI","uri":"/post/%E5%90%8E%E7%AB%AF-uwsgi/"},{"categories":null,"content":"超时 ","date":"2019-06-11","objectID":"/post/%E5%90%8E%E7%AB%AF-uwsgi/:1:1","tags":["后端"],"title":"后端-uWSGI","uri":"/post/%E5%90%8E%E7%AB%AF-uwsgi/"},{"categories":null,"content":"注意事项 uWSGI不使用–lazy-apps的过程中，使用SQLachemy很容易出现Mysql serve has gone的问题，会与多次fork主进程，依赖主进程资源有关。使用–lazy-apps之后，问题大大改善，但是在【一段访问】前期（根据访问创建多进程）还是会出现，访问稳定之后，问题消失。 ","date":"2019-06-11","objectID":"/post/%E5%90%8E%E7%AB%AF-uwsgi/:2:0","tags":["后端"],"title":"后端-uWSGI","uri":"/post/%E5%90%8E%E7%AB%AF-uwsgi/"},{"categories":null,"content":"问题 ","date":"2019-06-11","objectID":"/post/%E5%90%8E%E7%AB%AF-uwsgi/:3:0","tags":["后端"],"title":"后端-uWSGI","uri":"/post/%E5%90%8E%E7%AB%AF-uwsgi/"},{"categories":null,"content":"uwsgi_response_writev_headers_and_body_do(): Broken pipe [core/writer.c 306] OSError: write error IO报错； This can happen when NGINX started a request to uWSGI but uWSGI took too long to respond, then NGINX closes the connection to uWSGI. When uWSGI finally finishes, it tries to give it’s response back to NGINX, but NGINX closed the connection earlier, so then uWSGI throws an I/O error. ","date":"2019-06-11","objectID":"/post/%E5%90%8E%E7%AB%AF-uwsgi/:3:1","tags":["后端"],"title":"后端-uWSGI","uri":"/post/%E5%90%8E%E7%AB%AF-uwsgi/"},{"categories":null,"content":"消息队列 FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址。 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:1:0","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"xQueueCreate 函数 xQueueCreate 用于创建消息队列。 第 1 个参数是消息队列支持的消息个数。 第 2 个参数是每个消息的大小，单位字节。 返回值， 如果创建成功会返回消息队列的句柄(xQueueHandle)，如果由于 FreeRTOSConfig.h 文件中 heap 大小不足，无法为此消息队列提供所需的空间会返回 NULL。 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:1:1","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"xQueueSend 函数 xQueueSend 用于任务中消息发送 第 1 个参数是消息队列句柄。 第 2 个参数要传递数据地址， 每次发送都是将消息队列创建函数 xQueueCreate 所指定的单个消息大小复制到消息队列空间中。 第 3 个参数是当消息队列已经满时，等待消息队列有空间时的最大等待时间，单位系统时钟节拍。 返回值，如果消息成功发送返回 pdTRUE，否则返回 errQUEUE_FULL。 此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是xQueueSendFromISR. 消息队列还有两个函数 xQueueSendToBack 和 xQueueSendToFront，函数 xQueueSendToBack实现的是 FIFO 方式的存取，函数 xQueueSendToFront 实现的是 LIFO 方式的读写。我们这里说的函数 xQueueSend 等效于 xQueueSendToBack，即实现的是 FIFO 方式的存取. 消息队列还有两个函数 xQueueSendToBackFromISR 和 xQueueSendToFrontFromISR，函数xQueueSendToBackFromISR 实现的是 FIFO 方式的存取，函数 xQueueSendToFrontFromISR 实现的是 LIFO 方式的读写。我们这里说的函数 xQueueSendFromISR 等效于xQueueSendToBackFromISR，即实现的是 FIFO 方式的存取. ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:1:2","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"xQueueReceive 函数 xQueueReceive 用于接收消息队列中的数据。 第 1 个参数是消息队列句柄。 第 2 个参数是从消息队列中复制出数据后所储存的缓冲地址，缓冲区空间要大于等于消息队列创建函数 xQueueCreate 所指定的单个消息大小，否则取出的数据无法全部存储到缓冲区，从而造成内存溢出。 第 3 个参数是消息队列为空时，等待消息队列有数据的最大等待时间，单位系统时钟节拍。 返回值，如果接到到消息返回 pdTRUE，否则返回 pdFALSE。 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:1:3","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"信号量 参考FreeRTOS 信号量 FreeRTOS 信号量和互斥锁是基于队列实现的； FreeRTOS 信号量包括二进制信号量、计数信号量、互斥锁和递归互斥锁。 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:2:0","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"二进制信号量 可以用于互斥和同步， 多用于同步。 xSemaphoreCreateBinary() // 创建二进制信号量 xSemaphoreTake( xSemaphore, xBlockTime ) // 获取信号量 信号量变为0 xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken ) // 在中断中获取信号量 信号量变为0 xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken ) // 在中断中释放信号量 信号量变为1 xSemaphoreGive( xSemaphore ) // 任务中释放信号量 信号量变为1 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:2:1","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"计数信号量 二进制信号量是长度为1的队列， 计数信号量则是长度可以大于1的信号量， 当设置长度为1， 其行为和二进制型号量一样。 xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) // 计数信号量创建时需要设置两个参数，一个是最大的计数值， 另一个初始化计数值 其他同二进制信号量 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:2:2","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"互斥锁 当一个任务访问一个资源时， 需要获取令牌， 在其使用期间，其他任务不能使用该资源， 使用完后， 释放令牌， 其他任务可以访问， 保证资源在一段时间只能由一个任务读取修改。 与二进制信号量最大的不同在于， 互斥信号量带有优先级继承的机制，这个机制用于减低优先级反转的影响。 互斥锁不能在中断使用， 因为中断函数没有优先级继承，同时， 中断函数不能阻塞。 xSemaphoreCreateMutex() // 创建互斥锁 xSemaphoreTake( xSemaphore, xBlockTime ) // 拿锁 xSemaphoreGive( xSemaphore ) // 放锁 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:2:3","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"递归互斥锁 获取递归互斥量的任务可以重复获取该递归互斥量。 使用xSemaphoreTakeRecursive() 函数成功获取几次递归互斥量，对应的就要使用xSemaphoreGiveRecursive()函数返还几次，在此之前递归互斥量都处于无效状态， 其他任务无法获取， 必须等待获取的任务释放完毕。 xSemaphoreCreateRecursiveMutex() // 创建 xSemaphoreTakeRecursive( xMutex, xBlockTime ) // 获取递归互斥量 xSemaphoreGiveRecursive( xMutex ) // 释放互斥锁 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:2:4","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"事件标志祖 信号量能同步1对1，事件标志组可以同步多对1，并且可以选择是否请掉标志。 ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:3:0","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"API函数 EventGroupHandle_t xEventGroupCreate( void ); // 创建消息标志组，如果创建成功，此函数返回事件标志组的句柄 xEventGroupCreateStatic() vEventGroupDelete() EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup, /* 事件标志组句柄 */ const EventBits_t uxBitsToWaitFor, /* 等待被设置的事件标志位 */ const BaseType_t xClearOnExit, /* 选择是否清零被置位的事件标志位 */ const BaseType_t xWaitForAllBits, /* 选择是否等待所有标志位都被设置 */ TickType_t xTicksToWait ); /* 设置等待时间 */ // 返回值，由于设置的时间超时或者指定的事件标志位被置1，导致函数退出时返回的事件标志组数值。 EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, /* 事件标志组句柄 */ const EventBits_t uxBitsToSet ); /* 事件标志位设置 */ // 返回当前的事件标志组数值。用户通过参数uxBitsToSet设置的标志位并不一定会保留到此函数的返回值中 BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, /* 事件标志组句柄 */ const EventBits_t uxBitsToSet, /* 事件标志位设置 */ BaseType_t *pxHigherPriorityTaskWoken ); /* 高优先级任务是否被唤醒的状态保存 */ // xEventGroupClearBits() xEventGroupClearBitsFromISR() xEventGroupGetBits() xEventGroupGetBitsFromISR() xEventGroupSync() ","date":"2019-06-10","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/:3:1","tags":null,"title":"嵌入式-FREERTOS","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-freertos/"},{"categories":null,"content":"概念 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:1:0","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"股票分类 A股：国内公司上市发行，以人民币交易结算，供我国居民、法人交易的社会公众股。 A股分为深A股（以0为开头和创业板股票（以3开头））和沪A股（以6开头）。 B股：境内上市，供港澳台海外华人交易的外资股。现在国内投资者也可以申请开通。 B股分为深B股（以港币结算，2开头）和沪B股（美元结算，9开头）。 H股：国企股，注册地在内地，上市地在香港的外资股。H股为实物股票，T+0，无涨跌幅。 H股只是中国地区机构投资者可以投资，个人投资者不可以直接投资。 缀 描述 *ST 公司经营连续三年亏损，退市预警 ST 公司经营连续二年亏损，特别处理 S*ST 公司经营连续三年亏损，退市预警+还没有完成股改 SST 公司经营连续二年亏损，特别处理+还没有完成股改 S 还没有完成股改 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:1:1","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"交易规则 ST类股票涨跌幅限制为5%； 新股上市第一天不限涨跌幅； T+1（当天买入，第二天才可以卖出）。 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:1:2","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"交易时间 上午9:15-9:25集合竞价时间，可以委托报价，由计算机撮合产生第一笔成交价，也就是开盘价。 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:1:3","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"分析方法 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:2:0","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"基本面分析 研究公司的财务报表、经营状况和产品、公司管理团队、行业优势、发展潜力等各方面的基本情况，然后对企业的价值精选评估进而决定投资决策。 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:2:1","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"技术面分析 对市场交易行为的分析，通过对市场过去和现在的数据，运用一些数学和逻辑的方法，根据行情的变化趋势表现来决定投资决策。 ","date":"2019-05-28","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/:2:2","tags":null,"title":"日常-股票","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%82%A1%E7%A5%A8/"},{"categories":null,"content":"经验 跑celery的容器和跑APP的容器最好分开，以分开数据库session，防止session混合。 ","date":"2019-05-28","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-celery/:1:0","tags":["celery"],"title":"微服务架构笔记-中间件-CELERY","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-celery/"},{"categories":null,"content":"用户管理 ","date":"2019-05-25","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-centos/:1:0","tags":null,"title":"运维-CENTOS","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-centos/"},{"categories":null,"content":"docker How To Install and Use Docker Compose on CentOS 7 ","date":"2019-05-25","objectID":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-centos/:2:0","tags":null,"title":"运维-CENTOS","uri":"/post/%E8%BF%90%E7%BB%B4-03-%E7%B3%BB%E7%BB%9F-centos/"},{"categories":null,"content":"参考什么是Mesh网络 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:0:0","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"1. 简介 无线Mesh技术是一种与传统无线网络完全不同的新型无线网络技术。在传统的WLAN中，每个客户端均通过一条与接入点（AP）相连的无线链路访问网络，用户若要进行相互通信，必须首先访问一个固定的AP，这种网络结构称为单跳网络。而在无线Mesh网络中，任何无线设备节点都可同时作为路由器，网络中的每个节点都能发送和接收信号，每个节点都能与一个或多个对等节点进行直接通信。 这种结构的最大好处在于：如果最近的AP由于流量过大而导致拥塞的话，数据可以自动重新路由到一个通信流量较小的邻近节点进行传输。依此类推，数据包还可以根据网络的情况，继续路由到与之最近的下一个节点进行传输，直到到达最终目的地为止。这样的访问方式就是多跳访问。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:1:0","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"2. 特点 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:2:0","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"2.1. 自组织 网络节点和授权最终用户可即时加入网络，扩展网络覆盖范围，并可连接至所有其他节点。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:2:1","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"2.2. 自愈 如果网络中的某台设备发生故障或从其拓扑位置上拆卸，网络会自动适应这种改变。既使发端与对端之间的连接涉及多台中继设备，网络也会找到从发端到对端的新的路由。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:2:2","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"2.3. 多跳式 每个网络节点和用户端设备（无线通信单元）均能转发和路由发送至另一个对端的数据包，能选择并确定一个从发端到对端的最佳路由。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:2:3","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"2.4. 点对点网络 自组织网络通常由平等的网元构成，只要发端和对端的距离足够近，就能直接连接发端和对端。而不必通过中央管理节点。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:2:4","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"2.5. 多信道协商 提高带宽的利用率 无线Mesh网络进行多信道接入时一种协调机制，保证通信的两个节点都工作在相同的信道上。将时间轴被划分为信标间隔，在每一个信标间隔的开始，建立一个叫做ATIM的时间窗口，在相同的ATIM窗口内，有数据需要发送的节点使用控制消息和接收端使用相同的信道。这种多信道协商方法的目的是要选择业务负载小的信道，尽可能地平衡信道负载，减小竞争和退避所浪费的带宽。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:2:5","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"3. 工作原理 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:3:0","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"3.1. Mesh邻居发现 Mesh发现是Mesh网络建立过程中的第一步，类似于接入服务中STA扫描网络。 3.1.1. Mesh网络扫描 Mesh节点(MP)通过主动发送Probe Request探测帧，或侦听Beacon帧，来收集邻居信息。Beacon或Probe帧中包含Mesh ID、Mesh Configuration以及安全能力等相关信息。 3.1.2. 邻居关系维护 MP从接收到的Beacon或Probe Response帧中解析发端MP的Mesh profile信息，与本端Mesh profile信息进行匹配。只有当扫描双方的Mesh profile匹配时，双方才可以建立邻居关系。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:3:1","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"3.2. Mesh连接管理 Mesh连接管理包括Mesh连接建立和Mesh连接拆除两个过程，采用Peer Link Open/Confirm/Close三种Mesh连接管理Action帧交互实现。 3.2.1. Mesh连接建立 MP在选出候选Peer后，可以与之发起Mesh连接建立过程。协商Mesh连接的双方需要确保使用相同的Mesh profile。 每个MP根据需要可以建立一条或多条Mesh连接，Mesh连接建立后，需要继续进行后续的认证和安全协商，之后Mesh连接才可以参与Mesh数据转发。 3.2.2. Mesh连接拆除 Mesh连接双方中任一方，均可以主动向对方发送Peer Link Close消息，以关闭双方间的Mesh连接，收到Peer Link Close消息的MP，需要向对方MP回应一个Peer Link Close消息。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:3:2","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"3.3. Mesh安全机制 由于传输媒质的开放性，无线网络很容易遭受非法攻击，802.11i标准的推出解决了传统WLAN网络的安全问题，但Mesh网络的多跳性带来了新的安全挑战。在认证方式上，Mesh安全同样支持802.1x认证和PSK认证方式，802.1x认证通过Supplicant MP与AAA server交互产生后续密钥协商用的种子密钥MSK，PSK认证方式则直接使用PSK作为密钥协商的种子密钥。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:3:3","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"3.4. Mesh选路 Mesh网络是全连接的WLAN网络，任何一个源和目的地之间会存在多条可用的Mesh链路，并且这些Mesh链路的传输质量会随着周边环境实时变化。因此，非常有必要在Mesh网络支持选路协议，以确保数据帧能始终通过最优的链路传输。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:3:4","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"3.5. Mesh转发 对于目的MAC为单播地址的数据帧，首先查找转发表项。若查到匹配表项，则将数据帧由该表项对应的Mesh链路发送出去；若未匹配任何表项，则将该数据帧从所有处于活跃状态的Mesh链路发送出去。 对于目的MAC为组播或广播地址的数据帧，MP将数据帧从所有处于活跃状态的Mesh链路发送出去。 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:3:5","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"4. 实现 ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:4:0","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"4.1. ESP MESH ","date":"2019-05-25","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/:4:1","tags":null,"title":"嵌入式-MESH","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-mesh/"},{"categories":null,"content":"窗口操作 ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:1:0","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"TotalSpaces 首先关闭SIP； ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:1:1","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"快捷键 键 描述 CapsLock 切换中英文输入 ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:2:0","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"文件系统 ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:3:0","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"终端操作 ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:4:0","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"终端窗口 Mac 上的“终端”键盘快捷键 命令 功能 Ctrl + - 字体变小 Ctrl + + 字体变大 ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:4:1","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"命令 brew 命令 功能 brew update brew install ","date":"2019-05-23","objectID":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:4:2","tags":null,"title":"操作系统-MAC-基本使用","uri":"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mac-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"MicroPython中的文件结构、启动过程、最佳实践以及特有模块介绍","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"文件结构 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:1:0","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"官方固件 / boot.py _boot.py在文件系统中不可见（在MicorPython中称为internal frozen modules，也就是编译好的内部模块）。这个模块主要完成的功能包括创建/加载文件系统，在首次启动时初始化网卡配置等。不建议对这个模块进行任何变动。 MicroPython启动之后首先执行boot.py文件，此文件是由MicroPython系统自己创建的，除非很了解micropython，否则不要修改此文件； 紧接着会执行main.py文件，由用户自己创建。没有此文件，启动会报错OSError: [Errno 2] ENOENT; 不要将大量代码写入main.py文件，将要完成的功能分模块写于多个文件中。 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:1:1","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"EMP / boot.py # 启动代码 lib/ config/ ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:1:2","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"最佳实践 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:2:0","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"写中断处理程序 尽可能短和简单； 避免内存分配:没有添加到列表或插入字典，没有浮点数。 使用 micropython.schedule 解决上述约束. 如果一个ISR返回多字节，使用预先分配的bytearray. 如果ISR和主程序共享多字节整数，请使用array (array.array). The simplest means of doing this is via one or more shared data objects, either declared as global or shared via a class。 import pyb, micropython micropython.alloc_emergency_exception_buf(100) class Foo(object): def __init__(self, timer, led): self.led = led timer.callback(self.cb) def cb(self, tim): self.led.toggle() red = Foo(pyb.Timer(4, freq=1), pyb.LED(1)) green = Foo(pyb.Timer(2, freq=0.8), pyb.LED(2)) The use of instance methods confers two benefits. Firstly a single class enables code to be shared between multiple hardware instances. Secondly, as a bound method the callback function’s first argument is self. This enables the callback to access instance data and to save state between successive calls. The MicroPython library I/O methods usually provide an option to use a pre-allocated buffer. 5. 进入中断程序之后，先disable中断，处理完之后，再enable中断。 6. Allocate an emergency exception buffer。在中断处理程序中加入以下代码，调试会变简单。 import micropython micropython.alloc_emergency_exception_buf(100) ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:2:1","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"最大化microPython速度 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:2:2","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"上传下载文件 使用webrepl上传和获取文件。 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:2:3","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"特有模块 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:3:0","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"EMP-1ZLAB EasyMicroPython(EMP) IDE 是由1Z实验室引导的一个开源项目，旨在为MicroPython社区提供更高效便捷的开发体验。EMP IDE受到了MicroPython/webrepl 项目的启发，采用了其现有的通信协议，并对webrepl模块进行了改造，设计并实现了一些功能模块，以此来通过WebSocket实现和MicroPython设备的更丰富，更高效的信息交互。 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:3:1","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"MACHINE 允许你直接和无限制地使用硬件模块。 所有的回调方法都应该在中断上下文中 CLASS ADC class machine.ADC(id=0, *, bits=12) 使用指定的GPIO口创建ADC实例或不指定 # ADC.channel(id, *, pin) ESP32的ADC没有这个方法 # ADC.init() ESP32的ADC没有这个方法 # ADC.deinit() ESP32的ADC没有这个方法 ADC.read() 读取一次采样值 # 设置D34号引脚作为ADC采样引脚 pin_read = Pin(34,Pin.IN) # 声明ADC对象 adc = ADC(pin_read) # 设置衰减比 满量程3.3v adc.atten(ADC.ATTN_11DB) # 设置数据宽度为10bit adc.width(ADC.WIDTH_10BIT) PIN SIGNAL Timer PROPERTY 名称 类型 描述 Timer.PERIODIC 周期执行 Timer.ONE_SHOT 只执行一个，执行完了定时器就结束 UART class machine.UART(id, ...) id 给定的id(即串口号) UART.init(baudrate=9600, bits=8, parity=None, stop=1, *, ...) baudrate 波特率 bits 位数 parity 极性 stop 停止位 tx 指定发送的引脚（即GPIO号） rx 制定接收的引脚（即GPIO号） txbuf 指定发送的缓冲区大小 rxbuf 指定接收的缓冲区大小 UART.deinit() 关闭串口 UART.any() 非阻塞地返回可以读的字符数目，有可能返回1，但是有多于1的字符 UART.read([nbytes]) 读取指定数目的字符，不指定则尽可能多读 UART.readline() 读取一行 UART.write(buf) 写数 UART.sendbreak() UART.irq(trigger, priority=1, handler=None, wake=machine.IDLE) 创建一个回调当有数接收时 trigger 只能是UART.RX_ANY priority 优先级（1-7） handler 回调函数（1-8个字节） wake 只能是machine.IDLE ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:3:2","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"NETWORK CLASS WLAN WIFI驱动 METHODS 名称 示例 描述 activate([is_active]) connect(ssid=None, password=None, *, bssid=None) connect(‘ssid’,‘password’) 只有客户端模式才允许连接 PROPERTY 名称 类型 描述 STA_IF WLAN参数 连接到上游的wifi热点 AP_IF WLAN参数 wifi热点，允许设备连接 METHODS ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:3:3","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"UPIP microPython的包管理 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:3:4","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"REPL Ctrl + A 进入RAW REPL Ctrl + B 进入NORMAL REPL Ctrl + C 中断程序 如果没有出现\"»\u003e\"可以使用 Ctrl + D 软复位板子 Ctrl + E 进入paste模式 使用AMPY pip install adafruit-ampy --upgrade 上传文件 ampy --port /dev/ttyUSB0 put main.py 删除文件 ampy --port /dev/ttyUSB0 rm main.py ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/:3:5","tags":null,"title":"MicroPython","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-micropython/"},{"categories":null,"content":"ESP32开发","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"《ESP32技术参考手册》 双CPU，两个CPU的名称分别是“PRO_CPU”和“APP_CPU”； 存储 片上存储器 –448 KB Internal ROM –520 KB Internal SRAM –8 KB RTC FAST Memory –8 KB RTC SLOW Memory 片外存储器 片外SPI存储器可作为片外存储器被映射到可用的地址空间。部分片上存储器可用作片外存储器的Cache。 –最大支持16 MB片外SPI Flash –最大支持8 MB片外SPI SRAM ESP32 芯片包含两个硬件定时器组。每组有两个通用硬件定时器。它们都是基于 16 位预分频器和 64 位自动重载功能的向上/向下计数器的 64 位通用定时器。 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:1:0","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"启动过程 在esp32 上电运行后，芯片运行的第一个程序。这段程序是芯片设计与生产的时候，固化在硬件电路中的。所以它是不可修改的(Read Only Memory)。 esp32 的 ROM 负责检测芯片的strapping配置，来决定芯片应该处于什么状态。比如，esp32 上电后，ROM 程序会检查 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5]的状态。 如果 GPIO0 / GPIO2 同时为低电平，则会进入下载模式，等待串口通信信息。 如果GPIO0为高电平，则会进入Flash 运行模式，启动SPI 驱动，并加载Flash中的程序段。 关于启动模式 BOOT_MODE[5:0]: pull-up, pull-down, pull-down, pull-up, pull-up, SW4 /5/4/3/2/1/ ) [GPIO0, GPIO2, GPIO4, MTDO, GPIO5] 1 x x x x --\u003e SPI Boot 0 0 x x x --\u003e Download Boot (Jonit-Detection of UART0+UART1+SDIO_Slave) 下载模式的串口输出如下(115200), ROM默认会输出当前所处的模式。 rst:0x1 (POWERON_RESET),boot:0x3 (DOWNLOAD_BOOT(UART0/UART1/SDIO_REI_REO_V2)) waiting for download 其中，boot:0x3 表示的是芯片strapping pin脚的状态， 0x03对应 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5] 的值为 [ 0, 0, 0, 1, 1] 所以处于 Download Boot 模式。 关于下载模式 可以使用esptool脚本，可以进行寄存器的读写，固件下载，程序运行等操作。 关于STUB 在ROM模式，由于芯片处于低频工作的状态，通信速率受限。在esptool中，会将一段小程序加载到esp32的RAM中，并跳转执行RAM中的小程序。这段小程序包含了ROM中相同的串口通信协议，并对其进行了扩充。 关于 Flash Boot 模式 如果芯片启动时，GPIO0为高电平，芯片会进入Flash 运行模式。 此时，启动SPI 驱动，并加载Flash中的程序段。ROM 会读取外置 Flash 的0x1000地址，加载并运行二级bootloader。 关于二级Bootloader 二级bootloader可以认为是一个独立的小程序，二级bootloader会对芯片频率进行初始化，并且读取系统SPI的配置信息，对Flash 运行模式以及频率进行配置，然后根据分区表的定义，从对应的地址加载应用程序，并且运行应用程序固件。 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:1:1","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"硬件家族 硬件代码 类型 描述 ESP32 DEVKITV1 开发板 PINOUT-DOIT ESP32 Devkit V1，原理图 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:2:0","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"开始编程 ESP-IDF 编程指南 构建toolchain； 配置ESP-IDF； 设置环境变量 开始一个工程，工程目录下： idf.py menuconfig # 配置 idf.py build # build idf.py -p PORT flash # flash idf.py -p PORT monitor # 监控 Ctrl+]退出 升级ESP-IDF，使用git命令，直接pull即可，注意子模块的更新。 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:3:0","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"了解编译系统Cmake Read this document if you want to know how to organise and build a new ESP-IDF project or component using the CMake-based build system.\\ 一个工程是各种组件的融合。 project 是一个包含文件和配置的目录； 工程配置放在工程根目录下的sdkconfig文件中，通过idf.py menuconfig来进行修改。一个工程只能有这一个文件。 一个工程通常构建两个APP，一个是project app，一个是bootloader app。 组件是独立的代码库，通称是以静态库(.a)提供。 工程目录 - myProject/ - CMakeLists.txt # cmake规则文件 - sdkconfig # idf.py menuconfig 自动生成 - components/ - component1/ - CMakeLists.txt - Kconfig - src1.c - component2/ - CMakeLists.txt - Kconfig - src1.c - include/ - component2.h - main/ - Kconfig.projbuild - CMakeLists.txt # 组件规则 - src/ - app_main.c - module1/ - module2/ - inc/ - module1/ - module2/ - build/ # idf.py menuconfig 自动生成 main的Kconfig.projbuild文件 # 开始一个菜单 menu \"菜单名称\" # 开始一个配置 config 配置名（全大写） # 对应CONFIG_配置名 bool \"配置描述\" # bool类型，选中即定义，不选中即没有定义（可使用#ifdef） default \"n\"（\"y\"） int \"配置描述\" # 整数类型， range 0 10 # 整数范围 default 5 # 默认整数 string \"配置描述\" # 字符串类型 default \"\" help xxxxxxxxx # 帮助信息 depends on 配置名 # 依赖配置名 if 配置名 menu endmenu elif menu endmenu endif choice 配置名 prompt \"描述\" endchoice endmenu 项目CMakeLists 文件 必要 cmake_minimum_required(VERSION 3.5) //必须放在 CMakeLists.txt 文件的第一行，它会告诉 CMake 构建该项目所需要的最小版本号 include($ENV{IDF_PATH}/tools/cmake/project.cmake) //会导入 CMake 的其余功能来完成配置项目、检索组件等任务。 project(myProject) //会创建项目本身，并指定项目名称 选用 COMPONENT_DIRS //组件的搜索目录，默认为 ${IDF_PATH}/components、${PROJECT_PATH}/components 和 EXTRA_COMPONENT_DIRS。如果您不想在这些位置搜索组件，请覆盖此变量。 EXTRA_COMPONENT_DIRS //用于搜索组件的其它可选目录列表。路径可以是相对于项目目录的相对路径，也可以是绝对路径。 COMPONENTS //要构建进项目中的组件名称列表，默认为 COMPONENT_DIRS 目录下检索到的所有组件。使用此变量可以“精简”项目以缩短构建时间。请注意，如果一个组件通过 COMPONENT_REQUIRES 指定了它依赖的另一个组件，则会自动将其添加到 COMPONENTS 中，所以 COMPONENTS 列表可能会非常短。 COMPONENT_REQUIRES_COMMON //每个组件都需要的通用组件列表，这些通用组件会自动添加到每个组件的 COMPONENT_PRIV_REQUIRES 列表中以及项目的 COMPONENTS 列表中。默认情况下，此变量设置为 ESP-IDF 项目所需的最小核心“系统”组件集。通常您无需在项目中更改此变量。 组件CMakeLists 文件 最小的 set(COMPONENT_SRCS \"foo.c\") # 用空格分隔的源文件列表（*.c，*.cpp，*.cc，*.S），里面所有的源文件都将会编译进组件库中 set(COMPONENT_ADD_INCLUDEDIRS \"include\") # 用空格分隔的目录列表，里面的路径会被添加到所有需要该组件的组件（包括 main 组件）全局 include 搜索路径中 register_component() 组件中使用第三方 CMake 项目 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:3:1","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"研究API参考 Event Loop Library peripherals I2C esp_err_ti2c_set_timeout(i2c_port_ti2c_num, int timeout) //设置I2C的超时时间 第一个参数为 I2C的port number 第二个参数的单位为APB 80Mhz的时钟周期 esp_err_ti2c_get_timeout(i2c_port_ti2c_num, int *timeout) //读取I2C的超时间 第一个参数为 I2C的port number 第二个参数为存储结果的指针 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:3:2","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"研究头文件 头文件 描述 bt.h configures the BT controller and VHCI from the host side. esp_bt_main.h initializes and enables the Bluedroid stack. esp_gap_ble_api.h implements the GAP configuration, such as advertising and connection parameters. esp_gattc_api.h implements the GATT Client configuration, such as connecting to peripherals and searching for services. ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:3:3","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"研究Example bluetooth gatt_client get-started blink peripherals ADC I2C i2c_self_test i2c_tools 是开发I2C设备的有用的工具。 默认 i2c 0，SDA（18） SCL（19） 提供命令行： ============================================================== | Steps to Use i2c-tools on ESP32 | | | | 1. Try 'help', check all supported commands | | 2. Try 'i2cconfig' to configure your I2C bus | | 3. Try 'i2cdetect' to scan devices on the bus | | 4. Try 'i2cget' to get the content of specific register | | 5. Try 'i2cset' to set the value of specific register | | 6. Try 'i2cdump' to dump all the register (Experiment) | | | ============================================================== spi_slave sender timer_group(硬件定时器) 使用队列； timer_group。 参考ESP32 学习笔记（十）Timer. uart uart_async_rxtxtasks 创建freertos任务 #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" xTaskCreate(rx_task, \"uart_rx_task\", 1024*2, NULL, configMAX_PRIORITIES, NULL); xTaskCreate(tx_task, \"uart_tx_task\", 1024*2, NULL, configMAX_PRIORITIES-1, NULL); system esp-timer 虽然FreeRTOS提供了软件定时器，但是这些定时器有一些限制：最大分辨率等于系统滴答周期；回调函数是从低优先级分派的。 硬件定时器不受上述限制，但是又很难用，所以出现了esp-timer。 esp_timer_get_time() // 休眠模式 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:3:4","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"扩展 AT命令 参考上述工程，可将AT命令集加入到自定义工程中。 at Cmakefiles set(COMPONENT_ADD_INCLUDEDIRS include) set(COMPONENT_REQUIRES main) register_component() main Cmakefiles 链接静态库（.a） register_component() target_link_libraries(main \"-L../components/at/lib\") target_link_libraries(main at_core) 使用PN532模块 参考redchenjs/nfc_attendance_system_esp32 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:3:5","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":null,"content":"MicroPython 参考Quick reference for the ESP32 MicroPython-ESP32基础教程 ","date":"2019-05-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/:4:0","tags":null,"title":"嵌入式-ESP32","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-esp32/"},{"categories":["算法","数据科学"],"content":"开始机器学习","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"吴恩达的课程 网易云课堂 fengdu78/Coursera-ML-AndrewNg-Notes Machine Learning Yearning 中文版 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"初识 什么是机器学习 机器学习最主要的两类是监督学习和无监督学习，也是常用到的。 监督学习就是我们会教计算机做某件事情；无监督学习中，我们让计算机自己学习。 其他：强化学习；推荐系统。 监督学习 是指我们给算法一个数据集，其中包含了正确答案。算法的目的是给出更多的正确答案。 也被称为回归问题，回归是指我们设法预测连续值的属性（房价）。 分类问题（1或者0或更多离散值）（肿瘤），是指我们设法预测一个离散值的属性。 一个算法可以支持无穷多个特征。 无监督学习 给算法的数据集没有任何标签或有着相同的标签，让其在其中找到某种结构。 聚类算法等（将数据集分成几簇）：谷歌新闻（抓取新闻分成新闻专题）、分局基因分组、管理大型数据中心、社交网络的分析（圈子和人脉）、市场细分、天文数据分析。 鸡尾酒会问题 （多人语音分离，语音和背景音乐分离）； 推荐使用Octave验证算法，然后再编写其他语言版。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:1","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"单变量线性回归 模型描述 m 表示训练样本的数量；x 表示输入变量或者特征；y 标识输出变量或目标变量。 （x,y）表示一个训练样本；（xi,yi）表示第i个训练样本。 算法输出一个假设函数h（hypothesis）。 代价函数 模型参数。 求线性函数的参数值，尽量使（预测的值和真实值的差的平方）的和最小。 代价函数最常用的是平方误差代价函数. 代价函数（一） 代价函数可视化。令一个参数为0. 代价函数（二） 代价函数可视化。使用两个参数，使用等高线图。 梯度下降 环顾四周，向下降最快的方向迈出一步。 可能得到多个局部最优。 梯度下降算法的定义。 参数需要同步更新。 深入浅出–梯度下降法及其实现. 梯度下降知识点总结 合适的阿尔法值，太大有可能会导致发散。 越接近最低点时，梯度下降法会自动选择更小的梯度。 本视频使用一维变量。 线性回归的梯度下降 线性回归的代价函数总是一个弓状函数（凸convex函数），这个函数没有局部最优解。 通常会从参数都是0点开始梯度下降。 batch梯度下降，每一步都遍历了整个训练集的样本。 还有其他梯度下降算法，不用每次都遍历整个训练集，而是只关注一个小子集。 求代价函数最小值的其他方法，正规方程组方法。梯度下降，适合比较大的数据集。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:2","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"线性代数回顾 矩阵和向量 矩阵是由数字组成的矩形阵列，并卸载方括号中。 矩阵的维数：行数X列数。 Aij（i行 j列）。 向量是只有1列的矩阵。4维的向量即是含有四个元素的向量。 yi， 下标从1开始（表述），下标从0开始。 加法和标量乘法 只有相同维数的矩阵可以求和。将对应的每一个元素逐个求和。 标量乘以一个矩阵，将这个标量和每一个元素相乘。 矩阵向量乘法 矩阵（mxn）乘向量（n）（矩阵的列数等于向量的行数）得到一个m维的向量：将矩阵的每一行和向量的列对应元素相乘求和，得到m维向量的对应行的元素。 矩阵和向量相乘，可以求解线性代数。h(x)=-40+0.25x 根据一个假设求房子（不同面积）的价格。 矩阵乘法 矩阵（mXn）乘矩阵（nXj）得到一个（mXj）维度的矩阵。将第二个矩阵的每一列与第一个矩阵的每一行对应元素相乘并求和，放在对应行与对应列的交叉点上。 第一个矩阵的列数必须等于第二个矩阵的行数。 根据多个假设，求房子（不同面积）的价格。 矩阵乘法特征 NO交换律。 YES结合律。 单位矩阵（I）是对角线为1，其他值为0的方阵。 mXn的矩阵A：IxA=AxI=A。前后I为不同的单位矩阵，前者为mXm的单位矩阵，后者为nXn的单位矩阵。 逆和转置 可逆矩阵一定是方阵。AA-1=A-1A=I 如果矩阵A是可逆的，其逆矩阵是唯一的。 A的逆矩阵的逆矩阵还是A。记作（A-1）-1=A。 可逆矩阵A的转置矩阵AT也可逆，并且（AT）-1=（A-1）T (转置的逆等于逆的转置） 若矩阵A可逆，则矩阵A满足消去律。AB=AC（或BA=CA），则B=C。 两个可逆矩阵的乘积依然可逆。 矩阵可逆当且仅当它是满秩矩阵。 不可逆的矩阵为奇异矩阵或退化矩阵。 将矩阵的行列互换得到的新矩阵称为转置矩阵，转置矩阵的行列式不变。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:3","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"多变量线性回归 多功能 比如预测房价有多个变量。n表示特征值的数量。假设函数为多变量线性函数。 训练数据集可以为一个mX（n+1）维的矩阵，第一列为1.假设函数中的参数为一个（n+1）维的向量，训练数据集乘以向量得到预测的房价。 多元梯度下降法 多元线性回归的代价函数。J 梯度下降 多元梯度下降法演练1-特征缩放 特征缩放确保所有特征都处在一个相近的范围，这样梯度下降就可以更快的收敛。否则代价函数的等值线可能是狭长的，这样梯度下降会花费更长的时间并且会来回摆动(比较曲折)。 特征缩放就是将每个特征的取值进行缩放，缩放到-1和1的范围附近，比如除以样本值的最大值。 均值归一化mean normalization。 Standardization 又称为 Z-score normalization，量化后的特征将服从标准正态分布.μ ， δ 分别为对应特征 xi 的均值和标准差。量化后的特征将分布在 [−1,1] 区间。 Min-Max Scaling 又称为 normalization，量化后的特征将分布在 [0,1] 区间。 大多数机器学习算法中，会选择 Standardization 来进行特征缩放，但是，Min-Max Scaling 也并非会被弃置一地。在数字图像处理中，像素强度通常就会被量化到 [0,1] 区间，在一般的神经网络算法中，也会要求特征被量化到 [0,1] 区间。 进行了特征缩放以后，代价函数的轮廓会是“偏圆”的，梯度下降过程更加笔直，性能因此也得到提升. 多元梯度下降法II-学习率 绘出代价函数的值与迭代次数的曲线。可以告诉你大致在多少次之后收敛到最小值，并且判断梯度下降是否正常工作。 通常以3倍的间隔选择合适的学习率，即步长。 参考特征缩放 特征和多项式回归 根据已有特征创造新的特征，可能会找到更好的算法模型。 对于一个非线性的假设函数(二次或 三次 或平方根函数)，可以通过创建新的特征值转换为多元线性回归来解决问题。 我们可以选择多种多样的特征值，到底该如何选择，后边会有 算法把我们选择合适的特征值。 正规方程（区别于迭代方法的直接解法） 正规方程提供了一次性求解代价函数参数最优解的解析解法。求解导数为零时的参数值。 对于参数为一个向量，（X的转置乘以X）的逆乘以X的转置再乘以y得到参数的向量值。 pinv(X'*X)*X'*y伪逆 优点：不需要学习率，不需要迭代。缺点：对于特征值很多（一般多于1万）的情况，还是选用梯度下降。 正规方程不适用一些复杂的算法，比如逻辑回归 算法。此时需要梯度下降的算法。 正规方程在矩阵不可逆的情况下的解决方法 （X的转置乘以X）不可逆的情况，其实很少发生。 有两个原因：特征中包含了多余特征（比如有两个特征存在线性关系）。解决方法，删除一些特征。 第二个原因，特征值的数目n大于样本的数目m。解决方法:删除一些特征或使用正则化的方法。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:4","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"Octave教程 见数据科学-OCTAVE 向量化 重点是梯度下降的向量化，参考关于梯度下降算法的矢量化过程. 理解要点在梯度。梯度矩阵的元素分别求值，利用分号创建矩阵。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:5","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"Logistic回归 分类 不能用线性回归处理分类问题，因为线性算法的输出值要么很大或很小，显然对于0和1不是很合适。 逻辑回归的算法的值一直介于0和1之间，并不会大于1或 小于0. 假设陈述 当有一个分类问题的时候，我们要用哪个方程来表示我们的假设。 （对y进行归一化）logistics函数：$g(z)=\\frac{1}{1+e^{-z}}$。 逻辑回归本质上是线性回归，只是在特征到结果的映射中加入了一层函数映射，即先把特征线性求和，然后使用函数g(z)将最为假设函数来预测。g(z)可以将连续值映射到0到1之间。线性回归模型的表达式带入g(z)，就得到逻辑回归的表达式:$h_{\\theta}(x)=g\\left(\\theta^{T} x\\right)=\\frac{1}{1+e^{-\\theta^{T} x}}$。 假设函数输出的y是x对应的分类问题的概率估计：$P(y=1 | x ; \\theta)=h_{\\theta}(x)$和$P(y=0 | x ; \\theta)=1-h_{\\theta}(x)$。 决策界限 决策边界是假设函数的属性。只要假设函数及其参数确定，此边界也确定。（首先会预测在什么范围下分类） 我们可以用非常复杂的模型来适应非常复杂形状的判定边界。 代价函数 如果还是用线性回归时的代价函数，会发现此函数是非凸函数，有很多个局部最小值。我们需要其他形式的代价函数来保证逻辑回归的代价函数是凸函数。 这里我们先对线性回归模型中的代价函数J(θ)进行简单的改写：$J(\\theta)=\\frac{1}{m} \\sum_{i=1}^{m} \\frac{1}{2}\\left(h_{\\theta}\\left(x^{(i)}\\right)-y^{(i)}\\right)^{2}$； 用Cost(h(x), y) = 1/2(h(x) - y)^2 代替：$J(\\theta)=\\frac{1}{m} \\sum_{i=1}^{m} \\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$； 在这里我们选择对数似然损失函数做为逻辑回归模型的代价函数，Cost函数可以表示如下：$$ \\operatorname{cost}\\left(h_{\\theta}(x), y\\right)=\\left{\\begin{aligned}-\\log \\left(h_{\\theta}(x)\\right) \u0026 \\text { if } y=1 \\-\\log \\left(1-h_{\\theta}(x)\\right) \u0026 \\text { if } y=0 \\end{aligned}\\right. $$； 为了统一表示，可以把Cost(h(x), y)表达成统一的式子，根据前面J(θ)的定义，J(θ)等于： $J(\\theta)=-\\frac{1}{m}\\left[\\sum_{i=1}^{m} y^{(i)} \\operatorname{logh}_{\\theta}\\left(x^{(i)}\\right)+\\left(1-y^{(i)}\\right) \\log \\left(1-h_{\\theta}\\left(x^{(i)}\\right)\\right)\\right]$ 特别说明: 1. 当y=1的时候，第二项(1-y)log(1-h(x))等于0 ；2. 当y=0的时候，ylog(h(x))等于0。 根据线性回归求代价函数的方法，可以用梯度下降算法求解参数θ。 简化代价函数与梯度下降 高级优化 梯度下降（Gradient descent）并不是我们可以使用的唯一算法。 下面三种高级算法，通常不用手动选择学习率。他们有一个智能内循环，称为线搜索算法，自动尝试不同的学习率并选择一个好的学习率，甚至为每次迭代选择不同的学习率。还有其他优化，使代价函数收敛的速度远远大于梯度下降。 Conjugate Gradient BFGS L-BFGS 上述三种算法的缺点是特别复杂，不要尝试自己实现。但是不同的语言实现他们是有差别的。 function [jVal,gradient] = costFunction(theta) jVal = (theta(1)-5)^2+(theta(2)-5)^2; gradient = zeros(2,1); gradient(1) = 2*(theta(1)-5); gradient(2) = 2*(theta(2)-5); end options = optimset('GradObj','on','MaxIter',100); 第一个参数为GradObj:on意为设置目标参数为打开，意为要给该算法设置一个梯度。 第二个参数为MaxLter:100意为最大迭代次数为100。 initialTheta = zeros(2,1); [optTheta,functionVal,exitFlag] = fminunc(@costFunction,initialTheta,options); Fminunc是一个高级算法，第一个参数为代价函数，无需设置学习效率，该算法会自动计算出相应的学习效率 多元分类：一对多（one vs all）(one vs rest) 多类别分类问题。 对于每一类都有一个逻辑回归二分类预测函数。有多少类就会有多少个。 然后对于新的值，套用所有的预测函数，那个函数得到的概率越高，就属于哪一类。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:6","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"正则化 过拟合问题 欠拟合：高偏差；过拟合：高方差。 过拟合：拟合训练集很好，无法泛化到新样本。 怎么解决过拟合：(1)尽量减少选取变量的数量：可以人工检查变量清单，以确定那些特征变量需要保留，也可以使用模型选择算法，缺点是舍弃了一些有用的特征变量。（2）正则化：保留所有的特征变量，但是减少量级。 代价函数 给代价函数加入惩罚项，也就是正则项。这样可以弱化指定的参数对式子的影响。 但是如果特征很多的情况下，我们无法确定应该惩罚哪些参数，这时就要惩罚所有参数，来缩小每一个参数。 正则化参数，作用是平衡两个目标之间的取舍（更好地拟合训练集，将参数控制地更小保持模型的相对简单。） 正则化参数设置过大，就会欠拟合；过小，可能过拟合。 线性回归的正则化 梯度下降加入正则化。 正规方程加入正则化。 逻辑回归的正则化 梯度下降加入正则化。 高级优化加入正则化。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:7","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"神经网络学习 非线性假设 如果特征值非常大的情况下，使用逻辑回归，就不是很好的选择，需要考虑神经网络。 神经元与大脑 不同的传感器接到大脑上，大脑都会自动的处理传输过来的数据，即便使用的是同一块皮层。 模型展示I 输入层（x0偏置单元，为1，在输入层的神经元称为输入神经元）、隐藏层（允许有多层）、输出层（在输出层的神经元称为输出神经元）。 激活函数（作用是将权值结果转化为分类结果）。 sigmoid函数 softmax函数 tanh函数：双曲正切 参数（权重） 计算步骤 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:8","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"《机器学习实战》 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"《机器学习》周志华 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"《统计学习方法》李航 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:0","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["算法","数据科学"],"content":"实际工作 大部分的工作只是洗数据、调参数。 算法的原理。 ","date":"2019-05-16","objectID":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:0","tags":["算法","机器学习"],"title":"数据科学-机器学习","uri":"/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ai%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":null,"content":"列举一些第三方的saas","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"不蒜子 两行代码 搞定计数 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:1:0","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"LeanCloud 提供包括数据存储、文件存储与 CDN、消息推送和实时通信在内的后端云服务，同时提供支撑后端代码的云引擎和云函数等开发工具，全面涵盖移动开发的需求；我们同时也提供了易于集成的全平台 SDK，支持 iOS、Android 应用和游戏开发，以及包括微信小程序在内的 web 开发。 Hexo的NexT主题个性化：添加文章阅读量,next主题中已经包含支持，只需要使能并填入相应配置即可。 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:2:0","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"Valine 一款基于Leancloud的快速、简洁且高效的无后端评论系统。 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:3:0","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"CDN加速 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:4:0","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"又拍云联盟 为开发者提供专业、免费、稳定的 CDN 及云存储服务，加速个人网站及 APP 等项目。 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:4:1","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"百度云加速 百度云加速对个人站免费。 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:4:2","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"七牛云融合 CDN 每月0-10G免费。 ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:4:3","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"加速乐（CDN内容分发） 免费3600GB/月， ","date":"2019-05-15","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/:4:4","tags":["微服务","SAAS"],"title":"微服务架构笔记-中间件-SaaS","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-saas/"},{"categories":null,"content":"Django’s cache framework ","date":"2019-05-08","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E7%BC%93%E5%AD%98/:1:0","tags":null,"title":"Django缓存","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"niwinz/django-redis ","date":"2019-05-08","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E7%BC%93%E5%AD%98/:2:0","tags":null,"title":"Django缓存","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"参考Redis的最常被问到知识点总结 参考Redis性能问题排查解决手册(七) 参考Redis 命令参考 解决的问题：数据库受磁盘IO的影响。把比较热的数据放在内存中。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:0:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"1. 概述 Redis 是一个基于内存的高性能key-value数据库。SQL约束比较强。 整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis业务处理为单线程模式，采用队列模式将并发访问变为串行访问。但是，其他功能也会fork或clone出一个线程执行。 CS模式。 a.IO能不能读取:使用多路复用器（epoll）解决更有效率地获取哪个client可以读取。b.有了，worker自己得去读取。c.计算。 单worker线程，串行执行读客户端-计算-写客户端。原子执行【这样多个服务访问一个redis，不用加锁】。串行之后，就会变的快。 redis 6.0增加了IO thread.IO变成多线程，计算是单线程。 memcache的key和value都为字符串。redis的value有类型，不同类型调用不同的方法。 redis hbase kafka都是二进制安全（只存字符数组，没有类型）。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:1:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"1.1. 涉及到的网络IO /proc/[进程ID]/fd目录存的是进程涉及到的文件描述符。1-输入 2-输出 3-错误输出 6-监听 监听到一个客户端会创建一个socket通道与其通信。 BIO：多线程去读取，没有数据会阻塞。 NIO：非阻塞。就可以单线程轮询。用户态、内核态切换无数次。 select: 内核系统调用。可监控多个文件描述符，直到有1个或多个有内容返回结果集（可以读的文件描述符）。多路复用只告诉你谁可以读，需要程序自己去读文件描述符。缺点：内核自主去轮询，参数传的大。 select、poll、epoll之间的区别总结[整理]. ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:1:1","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"1.2. 数据类型 Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 不同的数据类型使用命令不同。 单个value的最大限制是1GB。 1.2.1. string 真的是字符串。 数值计算。 bitmap。 1.2.1.1. 常用命令 SET 将字符串值 value 关联到 key 。 SETNX 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。 SETEX 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟。 PSETEX 这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 key 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。 GET 返回与键 key 相关联的字符串值。 GETSET 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值。 STRLEN 返回键 key 储存的字符串值的长度。 APPEND 如果键 key 已经存在并且它的值是一个字符串， APPEND 命令将把 value 追加到键 key 现有值的末尾。 SETRANGE 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。 GETRANGE 返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。 INCR 为键 key 储存的数字值加上1。 INCRBY 为键 key 储存的数字值加上增量 increment 。 INCRBYFLOAT 为键 key 储存的值加上浮点数增量 increment 。 DECR 为键 key 储存的数字值减去1。 DECRBY 将键 key 储存的整数值减去减量 decrement 。 MSET 同时为多个键设置值。 MSETNX 当且仅当所有给定键都不存在时， 为所有给定键设置值。 MGET 返回给定的一个或多个字符串键的值。 位图(bitmap): SETBIT key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。 GETBIT 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 BITCOUNT 计算给定字符串中，被设置为 1 的比特位的数量,从开始（字符索引）到结束。 BITPOS 返回位图中第一个值为 bit 的二进制位的位置。 BITOP 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITFIELD 1.2.1.2. 应用场景 String是最常用的一种数据类型，普通的key/value存储都可以归为此类； 可以做点赞（数值类型）。但是hash更适合点赞。 可以做统计（数值）。 可以做限流 (数值)。 防止超卖. 统计任意用户任意时间窗的登录天数（bitmap）365bit。 基于7实现活跃用户.时间作为key，用户Id为位，位或（bitmap）。 1.2.1.3. 实现方式 1.2.2. hash 1.2.2.1. 常用命令 HSET 将哈希表 key 中域 field 的值设置为 value,会覆盖 。 HSETNX 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。 HGET 返回哈希表中给定域的值。 HEXISTS 检查给定域 field 是否存在于哈希表 hash 当中。 HDEL 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。 HLEN 返回哈希表 key 中域的数量。 HSTRLEN 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。 HINCRBY 为哈希表 key 中的域 field 的值加上增量 increment 。 HINCRBYFLOAT 为哈希表 key 中的域 field 加上浮点数增量 increment 。 HMSET 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HMGET 返回哈希表 key 中，一个或多个给定域的值。 HKEYS 返回哈希表 key 中的所有域。 HVALS 返回哈希表 key 中所有域的值。 HGETALL 返回哈希表 key 中，所有的域和值。 HSCAN 1.2.2.2. 应用场景 HASH MAP。 商品详情页。 用户统计值（好友数、点赞数）。 1.2.2.3. 实现方式 1.2.3. list 双向链表。Redis 列表是简单的字符串列表，按照插入顺序排序。 1.2.3.1. 常用命令 LPUSH 将一个或多个值 value 插入到列表 key 的表头。 LPUSHX 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。 RPUSH 将一个或多个值 value 插入到列表 key 的表尾(最右边)。 RPUSHX 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。 LPOP 移除并返回列表 key 的头元素。 RPOP 移除并返回列表 key 的尾元素。 RPOPLPUSH 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。 LREM 根据参数 count 的值，移除列表中与参数 value 相等的元素。 LLEN 返回列表 key 的长度。 LINDEX 返回列表 key 中，下标为 index 的元素。 LINSERT 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。 LSET 将列表 key 下标为 index 的元素的值设置为 value 。 LRANGE 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。 LTRIM 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 BLPOP BLPOP 是列表的阻塞式(blocking)弹出原语。 BRPOP BRPOP 是列表的阻塞式(blocking)弹出原语。 BRPOPLPUSH BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。 1.2.3.2. 应用场景 栈 队列 评论列表。 服务无状态。 1.2.3.3. 实现方式 1.2.4. set 无序。 去重. 1.2.4.1. 常用命令 SADD 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。 SISMEMBER 判断 member 元素是否集合 key 的成员。 SPOP 移除并返回集合中的一个随机元素。 SRANDMEMBER SREM 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。 SMOVE 将 member 元素从 source 集合移动到 destination 集合。 SCARD 返回集合 key 的基数(集合中元素的数量)。 SMEMBERS 返回集合 key 中的所有成员。 SSCAN SINTER 返回一个集合的全部成员，该集合是所有给定集合的交集。 SINTERSTORE 这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。 SUNION 返回一个集合的全部成员，该集合是所有给定集合的并集。 SUNIONSTORE 这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。 SDIFF 返回一个集合的全部成员，该集合是所有给定集合之间的差集。 SDIFFSTORE 这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。 1.2.4.2. 应用场景 抽奖; 随机场景； 推荐系统：好友推荐,商品推荐； 交并差集，数量不大，可以用。可以redis多实例。 1.2.4.3. 实现方式 1.2.5. sorted set 动态维护排序。 如何实现排序:ziplist(压缩表)和skiplist（跳跃表，value大了（大于64bytes）或元素个数大了(128)）。 skiplist:有一个层的概念，是一种随机化的数据。跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。 跳跃表造层是一个随机的过程。 1.2.5.1. 常用命令 ZADD 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 ZSCORE 返回有序集 key 中，成员 member 的 score 值。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:1:2","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"1.3. db redis默认有16个db. ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:1:3","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"1.4. 全局命令 详见Redis 命令参考 FLUSHALL TYPE 查询key类型 1.4.1. 事务 MULTI 标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。 EXEC 执行所有事务块内的命令。假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。 DISCARD 取消事务，放弃执行事务块内的所有命令。如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。 WATCH 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 UNWATCH 取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。 1.4.2. 调试 PING ECHO OBJECT OBJECT 命令允许从内部察看给定 key 的 Redis 对象. SLOWLOG MONITOR DEBUG_OBJECT DEBUG_SEGFAULT 1.4.3. 持久化 SAVE BGSAVE BGREWRITEAOF LASTSAVE ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:1:4","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"1.5. 持久化 快照具有时间窗口，全量，加载快，rdb，缺点:容易丢失大部分数据； 日志是实时的，记录比较完整，每一个操作都会追加到日志文件中，aof,缺点:加载慢和有冗余-（重写），拉低redis性能。 4.x之后可以混合使用,aof文件包含rdb二进制和aof明文. 并发很大，单实例有两个弊端:单点故障（主备，一变多）和性能瓶颈（分片集群）. ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:1:5","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"2. 配置 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:2:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"2.1. 配置文件 redis.conf 优先设置maxmemory及maxmemory_policy回收策略。 注意：所有配置写进配置文件中，redis-server后边紧跟配置文件，不再缀参数。 protected_mode no // 只能本地访问（127.0.0.1）不能通过（192.168**）访问 bind x.x.x.x // 绑定访问的地址，如果不指定需要注释掉，配合上个参数使用 daemonize no // docker中运行，守护模式为no save \"\" // 关闭rdb快照 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:2:1","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"2.2. 使用config命令 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:2:2","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"3. 单机版 docker exec -it 43f7a65ec7f8 redis-cli使用redis-cli连接到redis容器。 生成带密码和持久化的容器： redis:restart:alwaysimage:redis:5.0.5-alpinecommand:redis-server--requirepasszeHnzQ2uUOUAsKMk--appendonlyyesvolumes:- $PWD/data:/data ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:3:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"4. 集群(高可用、高并发) 参考docker-compose组建带密码redis集群 完整版. Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:4:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"4.1. 扩展 AKF扩展立方体（Scalability Cube)：这个立方体有三个轴线，每个轴线描述扩展性的一个维度，他们分别是产品、流程和团队：X轴 —— 代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上；Y轴 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分；Z轴 —— 关注服务和数据的优先级划分，如分地域划分。 CAP概念:可用性、一致性和分区容错。 大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。 一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。 一致性: 强一致性、弱一致性、最终一致性(黑盒订阅)。 可用性。 世界上只有一种一致性算法，就是 Paxos。出自一位 Google 大神之口。Paxos 也是出名的晦涩难懂，推理过程极其复杂。 分布式理论(五) - 一致性算法Paxos。 过半通过一致性。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:4:1","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"5. 客户端 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:5:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"5.1. redis-cli 参考redis cli命令 连接时参数 功能 -h 指定主机 -p 指定端口 -a 指定Auth password -r 代表将命令重复执行多次 -i 每隔几秒,需要和-r一起使用 –latency 可以看到延迟时间 命令 功能 info 获得状态信息 select 切换到指定数据库 keys 返回满足pattern的所有key，可以使用正则表达式 5.1.1. info命令 获取的数据分为10个类别。 5.1.1.1. server 5.1.1.2. clients 查看到当前实例的所有客户端连接信息 5.1.1.3. memory比较重要 5个关键指标 5.1.1.3.1. 内存使用率used_memory和used_memory_human used_memory是Redis使用的内存总量，它包含了实际缓存占用的内存和Redis自身运行所占用的内存(如元数据、lua)。它是由Redis使用内存分配器分配的内存，所以这个数据并没有把内存碎片浪费掉的内存给统计进去。 如果used_memory\u003e可用最大内存，那就说明Redis实例正在进行内存交换或者已经内存交换完毕。 5.1.1.3.2. used_memory_rss从操作系统上显示已经分配的内存总量 5.1.1.3.3. mem_fragmentation_ratio内存碎片率 used_memory_rss的rss是Resident Set Size的缩写，表示该进程所占物理内存的大小，是操作系统分配给Redis实例的内存大小。除了用户定义的数据和内部开销以外，used_memory_rss指标还包含了内存碎片的开销，内存碎片是由操作系统低效的分配/回收物理内存导致的。 内存碎片率稍大于1是合理的，这个值表示内存碎片率比较低，也说明redis没有发生内存交换。但如果内存碎片率超过1.5，那就说明Redis消耗了实际需要物理内存的150%，其中50%是内存碎片率。若是内存碎片率低于1的话，说明Redis内存分配超出了物理内存，操作系统正在进行内存交换。内存交换会引起非常明显的响应延迟. 5.1.1.3.4. used_memory_lua Lua脚本引擎所使用的内存大小。 mem_allocator： 在编译时指定的Redis使用的内存分配器，可以是libc、jemalloc、tcmalloc。 5.1.1.4. persistence 5.1.1.5. stats比较重要 5.1.1.5.1. 命令处理总数total_commands_processed 通过记录的total_commands_processed历史数据值来判断命理处理总数是上升趋势还是下降趋势，以便排查问题。 5.1.1.6. replication 5.1.1.7. cpu 5.1.1.8. commandstats 5.1.1.9. cluster 5.1.1.10. keyspace 5.1.2. config命令 config rewrite命令会把内存中的新配置刷新到配置文件(redis-server 必须指定配置文件启动)中。 5.1.3. 清除数据 flushall flushdb 5.1.4. 命令方式 redis-cli ping测试连接能否成功。 5.1.5. 交互式方式 redis-cli连接成功之后进入交互式方式。 5.1.6. 批量操作 批量删除key（使用xargs命令） ./redis-cli -h redis所在服务器ip -p 端口 keys \"course-*\" | xargs ./redis-cli -h redis所在服务器ip -p 端口 del ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:5:1","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"5.2. Redis Desktop Manager 桌面工具 sudo snap install redis-desktop-manager ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:5:2","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"5.3. erikdubbelboer/phpRedisAdmin 网页端工具 Simple web interface to manage Redis databases. ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:5:3","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"6. 使用见后端框架文档。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:6:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"7. 使用原则及警告(使用规范) 每个DB中可以有多个文件夹（可递归，使用’:‘隔开）。 警告多线程访问同一个redis资源时，会出先共享资源冲突的问题，由其修改其中的值。 解决2的问题，有几种思路:(1)通过watch（监控）+mutil（事务）实现应用于在分布式高并发处理等相关场景解决读取和修改的原子操作。同时修改(set等)会中断。(2)使用锁(3)不修改。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:7:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"7.1. 键值设计 7.1.1. key名设计 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id； 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视； 不要包含特殊字符。 7.1.2. value设计 【拒绝bigkey】防止网卡流量、慢查询，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000; 非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查)). 【选择适合的数据类型】 【控制key的生命周期】redis不是垃圾桶，建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:7:1","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"7.2. 命令使用 【O(N)命令关注N的数量】例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。 【禁用命令】禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。 【合理使用select】redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。 【使用批量操作提高效率】1.原生命令：例如mget、mset。2.非原生命令：可以使用pipeline提高效率。但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。注意两者不同：原生是原子操作，pipeline是非原子操作，pipeline可以打包不同的命令，原生做不到，pipeline需要客户端和服务端同时支持。 【不建议过多使用Redis事务功能】Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)。 【Redis集群版本在使用Lua上有特殊要求】 【monitor命令】必要情况下使用monitor命令时，要注意不要长时间使用。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:7:2","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"7.3. 客户端使用 避免多个应用使用一个Redis实例：不相干的业务拆分，公共数据做服务化。 使用连接池：可以有效控制连接，同时提高效率，标准使用方式。 Jedis jedis = null; try { jedis = jedisPool.getResource(); //具体的命令 jedis.executeCommand() } catch (Exception e) { logger.error(\"op key {} error: \" + e.getMessage(), key, e); } finally { //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。 if (jedis != null) jedis.close(); } 【熔断功能】高并发下建议客户端添加熔断功能(例如netflix hystrix)。 【合理的加密】设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）。 【淘汰策略】根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:7:3","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8. 性能指标及优化 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:0","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8.1. redis-benchmark压测 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:1","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8.2. 通过减少Redis的内存占用率，来避免这样的问题，或者使用下面的技巧来避免内存交换发生 8.2.1. 可以选择使用32位 假如缓存数据小于4GB，就使用32位的Redis实例。因为32位实例上的指针大小只有64位的一半，它的内存空间占用空间会更少些。 这有一个坏处就是，假设物理内存超过4GB，那么32位实例能使用的内存仍然会被限制在4GB以下。 要是实例同时也共享给其他一些应用使用的话，那可能需要更高效的64位Redis实例，这种情况下切换到32位是不可取的。 不管使用哪种方式，Redis的dump文件在32位和64位之间是互相兼容的， 因此倘若有减少占用内存空间的需求，可以尝试先使用32位，后面再切换到64位上。 8.2.2. 使用Hash数据结构 尽可能的使用Hash数据结构。因为Redis在储存小于100个字段的Hash结构上，其存储效率是非常高的。所以在不需要集合(set)操作或list的push/pop操作的时候，尽可能的使用Hash结构。比如，在一个web应用程序中，需要存储一个对象表示用户信息，使用单个key表示一个用户，其每个属性存储在Hash的字段里，这样要比给每个属性单独设置一个key-value要高效的多。 通常情况下倘若有数据使用string结构，用多个key存储时，那么应该转换成单key多字段的Hash结构。 如上述例子中介绍的Hash结构应包含，单个对象的属性或者单个用户各种各样的资料。Hash结构的操作命令是HSET(key, fields, value)和HGET(key, field)，使用它可以存储或从Hash中取出指定的字段。 8.2.3. 设置过期时间 设置key的过期时间。一个减少内存使用率的简单方法就是，每当存储对象时确保设置key的过期时间。倘若key在明确的时间周期内使用或者旧key不大可能被使用时，就可以用Redis过期时间命令(expire,expireat, pexpire, pexpireat)去设置过期时间，这样Redis会在key过期时自动删除key。 假如你知道每秒钟有多少个新key-value被创建，那可以调整key的存活时间，并指定阀值去限制Redis使用的最大内存。 8.2.4. 回收KEY 回收key。在Redis配置文件中(一般叫Redis.conf)，通过设置“maxmemory”属性的值可以限制Redis最大使用的内存，修改后重启实例生效。 也可以使用客户端命令config set maxmemory 去修改值，这个命令是立即生效的，但会在重启后会失效，需要使用config rewrite命令去刷新配置文件。 若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销。 如果没开启快照功能，maxmemory最高能设置为系统可用内存的95%。 选择一种key的回收策略，可在Redis.conf配置文件中修改maxmemory-policy属性值。 若是Redis数据集中的key都设置了过期时间，那么“volatile-ttl”策略是比较好的选择。但如果key在达到最大内存限制时没能够迅速过期，或者根本没有设置过期时间。那么设置为“allkeys-lru”值比较合适，它允许Redis从整个数据集中挑选最近最少使用的key进行删除(LRU淘汰算法)。Redis还提供了一些其他淘汰策略，如下： a. volatile-lru：使用LRU算法从已设置过期时间的数据集合中淘汰数据。 b. volatile-ttl：从已设置过期时间的数据集合中挑选即将过期的数据淘汰。 c. volatile-random：从已设置过期时间的数据集合中随机挑选数据淘汰。 d. allkeys-lru：使用LRU算法从所有数据集合中淘汰数据。 e. allkeys-random：从数据集合中任意选择数据淘汰 f. no-enviction：禁止淘汰数据。 通过设置maxmemory为系统可用内存的45%或95%(取决于持久化策略)和设置“maxmemory-policy”为“volatile-ttl”或“allkeys-lru”(取决于过期设置)，可以比较准确的限制Redis最大内存使用率，在绝大多数场景下使用这2种方式可确保Redis不会进行内存交换。倘若你担心由于限制了内存使用率导致丢失数据的话，可以设置noneviction值禁止淘汰数据。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:2","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8.3. 使用命令处理总数解决延迟时间增加 通过与记录的历史数据比较得知，命令处理总数确实是处于上升或下降状态，那么可能是有2个原因引起的: a. 命令队列里的命令数量过多，后面命令一直在等待中。 b. 几个慢命令阻塞Redis。 有三个办法可以解决 8.3.1. 使用多参数命令 单命令多参数的形式取代多命令单参数的形式。 举例来说，循环使用LSET命令去添加1000个元素到list结构中，是性能比较差的一种方式，更好的做法是在客户端创建一个1000元素的列表，用单个命令LPUSH或RPUSH，通过多参数构造形式一次性把1000个元素发送的Redis服务上。 8.3.2. 管道命令 另一个减少多命令的方法是使用管道(pipeline)，把几个命令合并一起执行，从而减少因网络开销引起的延迟问题。 8.3.3. 避免操作大集合的慢命令 如果命令处理频率过低导致延迟时间增加，这可能是因为使用了高时间复杂度的命令操作导致。 减少使用高时间复杂的命令，能显著的提高的Redis的性能。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:3","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8.4. 跟踪延迟时间提高性能 拿1G带宽来说，若是延迟时间远高于200μs，那明显是出现了性能问题。 8.4.1. 使用slowlog命令查出引发延迟的慢命令 8.4.2. 监控客户端的连接 8.4.3. 限制客户端连接数 在配置文件(Redis.conf)maxclients属性上修改客户端连接的最大数。 在Redis-cli工具上输入config set maxclients 去设置最大连接数。 根据连接数负载的情况，这个数字应该设置为预期连接数峰值的110%到150之间，若是连接数超出这个数字后，Redis会拒绝并立刻关闭新来的连接。 8.4.4. 加强内存管理 8.4.5. 性能数据指标 对于这种性能指标相关联的分析，需要从历史数据上来观察到数据指标的重要变化，此外还可以观察到单个性能指标相关联的所有其他性能指标信息。这些数据可以在Redis上收集，周期性的调用内容为Redis info的脚本，然后分析输出的信息，记录到日志文件中。当延迟发生变化时，用日志文件配合其他数据指标，把数据串联起来排查定位问题。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:4","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8.5. 用内存碎片率预测性能问题 8.5.1. 重启Redis服务器 如果内存碎片率超过1.5，重启Redis服务器可以让额外产生的内存碎片失效并重新作为新内存来使用，使操作系统恢复高效的内存管理。 通过比较used_memory_peak, used_memory_rss和used_memory_metrics的数据指标值可以检查额外内存碎片的占用。从名字上可以看出，used_memory_peak是过去Redis内存使用的峰值，而不是当前使用内存的值。如果used_memory_peak和used_memory_rss的值大致上相等，而且二者明显超过了used_memory值，这说明额外的内存碎片正在产生。 在重启服务器之前，需要在Redis-cli工具上输入shutdown save命令，意思是强制让Redis数据库执行保存操作并关闭Redis服务，这样做能保证在执行Redis关闭时不丢失任何数据。 在重启后，Redis会从硬盘上加载持久化的文件，以确保数据集持续可用。 8.5.2. 限制内存交换 如果内存碎片率低于1，Redis实例可能会把部分数据交换到硬盘上。内存交换会严重影响Redis的性能，所以应该增加可用物理内存或减少实Redis内存占用。 8.5.3. 修改内存分配器 Redis支持glibc’s malloc、jemalloc11、tcmalloc几种不同的内存分配器，每个分配器在内存分配和碎片上都有不同的实现。不建议普通管理员修改Redis默认内存分配器，因为这需要完全理解这几种内存分配器的差异，也要重新编译Redis。 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:5","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"8.6. 减少回收key以提升性能 跟踪key回收是非常重要的，因为通过回收key，可以保证合理分配Redis有限的内存资源。如果evicted_keys值经常超过0，那应该会看到客户端命令响应延迟时间增加，因为Redis不但要处理客户端过来的命令请求，还要频繁的回收满足条件的key。 回收key对性能的影响远没有内存交换严重，若是在强制内存交换和设置回收策略做一个选择的话，选择设置回收策略是比较合理的，因为把内存数据交换到硬盘上对性能影响非常大. 8.6.1. 增加内存限制 8.6.2. 对实例进行分片 下面是Redis实现分片的几种常见方式： a. Hash分片：一个比较简单的方法实现，通过Hash函数计算出key的Hash值，然后值所在范围对应特定的Redis实例。 b. 代理分片：客户端把请求发送到代理上，代理通过分片配置表选择对应的Redis实例。 如Twitter的Twemproxy，豌豆荚的codis。 c. 一致性Hash分片 d. 虚拟桶分片 ","date":"2019-05-07","objectID":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/:8:6","tags":["PLAT","数据库","内存数据库","REDIS"],"title":"redis","uri":"/post/plat-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"},{"categories":null,"content":"基本信息 celery/django-celery老的celery对django的集成，已经不再更新，最新版本为3.2.0（2016年11月23日），不再使用。 Celery 4.0支持Django 1.8和更新版本，所以直接使用celery即可pip install celery。 使用celery/django-celery-results将任务结果保存进Django ORM或者Django Cache中，最新版本为1.0.4（2018年11月14日）。 参考celery文档关于django的描述。 celery-with-redis不再使用，已不再更新。 celery任务放在每个APP下的tasks.py模块中。 参考Django初步使用Celery; 参考Django Celery定时任务和时间设置。 ","date":"2019-05-07","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:1:0","tags":null,"title":"后端-web框架-Django-任务队列","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["嵌入式调试"],"content":"使用CMSIS-DAP调试ARM设备","date":"2019-04-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm-cmsis-dap/","tags":["CMSIS-DAP"],"title":"CMSIS-DAP","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm-cmsis-dap/"},{"categories":["嵌入式调试"],"content":"openocd -f 指定配置文件（一般一个接口配置一个target配置）\r-c 命令\r-c cmsis-dap-serial 指定cmsis-dap烧写器序列号\r Programming nRF52 with OpenOCD ","date":"2019-04-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm-cmsis-dap/:1:0","tags":["CMSIS-DAP"],"title":"CMSIS-DAP","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm-cmsis-dap/"},{"categories":["嵌入式调试"],"content":"pyocd PyOCD debug tools for Arm Cortex devices\roptional arguments:\r-h, --help show this help message and exit\r-V, --version show program's version number and exit\r--help-options Display available session options.\rsubcommands:\rcommander Interactive command console.\rcmd Alias for 'commander'.\rerase Erase entire device flash or specified sectors.\rflash Program an image to device flash.\rgdbserver Run the gdb remote server(s).\rgdb Alias for 'gdbserver'.\rjson Output information as JSON.\rlist List information about probes, targets, or boards.\rpack Manage CMSIS-Packs for target support.\r ","date":"2019-04-23","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm-cmsis-dap/:2:0","tags":["CMSIS-DAP"],"title":"CMSIS-DAP","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm-cmsis-dap/"},{"categories":["PROGRAM"],"content":"开始一个python应用","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"1. 版本切换 pyenv 命令 功能 pyenv versions 列出已安装python版本 pyenv local 设置当前shell的python版本 pyenv global 设置全局的python版本 pyenv install -l 列出可以使用的python版本 ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:1:0","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"1.1. 安装 安装依赖; curl https://pyenv.run | bash. ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:1:1","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"1.2. 插件 1.2.1. pyenv/pyenv-virtualenv pyenv-virtualenvpyenv插件provides features to manage virtualenvs and conda environments for Python on UNIX-like systems. pyenv virtualenv 2.7.10 my-virtual-env-2.7.10 # 指定python版本和安装目录，如果不指定python版本，则使用当前的python版本\rpyenv activate \u003cname\u003e\rpyenv deactivate\rpyenv uninstall my-virtual-env\rpyenv virtualenv-delete my-virtual-env\r ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:1:2","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"2. 虚拟环境 ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:2:0","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"2.1. venv模块(python3.3以后的自带模块，是virtualenv的一个子集) 只能创建python同版本的虚拟环境 ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:2:1","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"2.2. virtualenv 将一个目录建立为一个虚拟的python环境，可以建立多个虚拟环境，每个环境里面的python版本可以是不同的，也可以是相同的，而且环境之间相互独立。 virtualenv [创建虚拟环境的目录] # 新建一个虚拟环境的目录\r ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:2:2","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"3. 开发必备 ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:3:0","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"3.1. ipython ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:3:1","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"3.2. jupyter ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:3:2","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"3.3. pip ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:3:3","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"4. 编码规范 ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:4:0","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PROGRAM"],"content":"5. 开始一个项目 ","date":"2019-04-23","objectID":"/post/program-python-01-%E5%BC%80%E5%A7%8B/:5:0","tags":["PROGRAM","PYTHON"],"title":"开始一个python应用","uri":"/post/program-python-01-%E5%BC%80%E5%A7%8B/"},{"categories":["PYTHON","桌面应用"],"content":"python桌面应用使用cx-freeze打包","date":"2019-04-23","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/","tags":["PYTHON","CX-FREEZE"],"title":"桌面应用打包和开源协议","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/"},{"categories":["PYTHON","桌面应用"],"content":"打包 ","date":"2019-04-23","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/:1:0","tags":["PYTHON","CX-FREEZE"],"title":"桌面应用打包和开源协议","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/"},{"categories":["PYTHON","桌面应用"],"content":"cx-freeze PSF协议，想怎么用就怎么用。 cx-freeze与python3.7 ","date":"2019-04-23","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/:1:1","tags":["PYTHON","CX-FREEZE"],"title":"桌面应用打包和开源协议","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/"},{"categories":["PYTHON","桌面应用"],"content":"fbs不建议 分为免费版（GPL）和收费版。 ","date":"2019-04-23","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/:1:2","tags":["PYTHON","CX-FREEZE"],"title":"桌面应用打包和开源协议","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/"},{"categories":["PYTHON","桌面应用"],"content":"pyinstaller PyInstaller 是在 GPL 许可证下发布的(参见源代码中的文件 COPYING.txt) ，但有一个特殊的例外，允许使用 PyInstaller 构建和发布非自由程序(包括商业程序)。换句话说，您在使用 PyInstaller 时没有任何限制，但是对它的任何修改都必须遵守 GPL 许可。 ","date":"2019-04-23","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/:1:3","tags":["PYTHON","CX-FREEZE"],"title":"桌面应用打包和开源协议","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/"},{"categories":["PYTHON","桌面应用"],"content":"开源协议 拥抱pyside6. ","date":"2019-04-23","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/:2:0","tags":["PYTHON","CX-FREEZE"],"title":"桌面应用打包和开源协议","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8-%E6%89%93%E5%8C%85/"},{"categories":["财会金融"],"content":"考虑","date":"2019-04-23","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/","tags":["财会"],"title":"财会金融","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/"},{"categories":["财会金融"],"content":"注册会计师 ","date":"2019-04-23","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/:1:0","tags":["财会"],"title":"财会金融","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/"},{"categories":["财会金融"],"content":"TMT行业分析员 TMT，是电信、媒体和科技（Telecommunication，Media，Technology）三个英文单词的首字母，整合在一起，实际是未来电信、媒体\\科技（互联网）、信息技术的融合趋势所产生的。 ","date":"2019-04-23","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/:2:0","tags":["财会"],"title":"财会金融","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/"},{"categories":["财会金融"],"content":"证券从业资格证 ","date":"2019-04-23","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/:3:0","tags":["财会"],"title":"财会金融","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/"},{"categories":["财会金融"],"content":"CFA ","date":"2019-04-23","objectID":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/:4:0","tags":["财会"],"title":"财会金融","uri":"/post/%E6%97%A5%E5%B8%B8-%E8%B4%A2%E4%BC%9A%E9%87%91%E8%9E%8D/"},{"categories":null,"content":"摘自面试一定会问到的-js事件循环 线程 执行中的线程。 主线程：也就是 js 引擎执行的线程，这个线程只有一个，页面渲染、函数处理都在这个主线程上执行。 工作线程：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取、网络请求等异步事件(主要调用浏览器或node提供的API)。 js主线程它是有一个执行栈的，所有的js代码都会在执行栈里运行,栈去队列中取任务（方法（函数）），一开始就去macrotask去任务。 在执行代码过程中，如果遇到一些异步代码(比如setTimeout,ajax,promise.then以及用户点击等操作),那么浏览器就会将这些代码放到另一个线程(在这里我们叫做幕后线程)中去执行，在前端由浏览器底层执行，在 node 端由 libuv 执行，这个线程的执行不阻塞主线程的执行，主线程继续执行栈中剩余的代码。 当幕后线程（background thread）里的代码执行完成后(比如setTimeout时间到了，ajax请求得到响应),该线程就会将它的回调函数放到任务队列（又称作事件队列、消息队列）中等待执行。而当主线程执行完栈中的所有代码后，它就会检查任务队列是否有任务要执行，如果有任务要执行的话，那么就将该任务放到执行栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。因此，这叫做事件循环。 任务队列 js是有两个任务队列的，一个叫做 Macrotask Queue(Task Queue) 大任务, 一个叫做 Microtask Queue 小任务. Macrotask 常见的任务： setTimeout setInterval setImmediate I/O 用户交互操作，UI渲染 Microtask 常见的任务： Promise(重点) process.nextTick(nodejs) Object.observe(不推荐使用) 4. 一次事件循环只执行处于 Macrotask 队首的任务，执行完成后，立即执行 Microtask 队列中的所有任务。 事件循环 async/await 如何处理 async function async1() { console.log('async1 start'); await async2(); console.log('async1 end'); } // 其实就是 async function async1() { console.log('async1 start'); Promise.resolve(async2()).then(()=\u003econsole.log('async1 end')) } setTimeout(task,100) 后，其实只是确保这个任务，会在100毫秒后进入macrotask队列，但并不意味着他能立刻运行，可能当前主线程正在进行一个耗时的操作，也可能目前microtask队列有很多个任务，所以用 setTimeout 作为倒计时其实并不会保证准确。 js 核心还是同步阻塞的。 对于 js 的异步事件，因为有事件循环机制，异步事件就是由事件驱动异步非阻塞的。所以 nodejs 适合处理大并发，因为有事件循环和任务队列机制，异步操作都由工作进程处理（libuv），js 主线程可以继续处理新的请求。缺点也很明显，因为是单线程，所以对计算密集型的就会比较吃力，不过可以通过集群的模式解决这个问题。 垃圾回收 ","date":"2019-04-17","objectID":"/post/js-%E5%8E%9F%E7%90%86%E5%8E%9F%E5%9E%8B%E9%93%BE-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E5%86%85%E5%AD%98-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/:0:0","tags":["JS"],"title":"JS-原理(原型链-事件循环-内存-作用域链-垃圾回收)","uri":"/post/js-%E5%8E%9F%E7%90%86%E5%8E%9F%E5%9E%8B%E9%93%BE-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E5%86%85%E5%AD%98-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"categories":null,"content":"使用JS现在文件 ","date":"2019-04-15","objectID":"/post/js-snippets/:1:0","tags":["JS"],"title":"JS-snippets","uri":"/post/js-snippets/"},{"categories":null,"content":"cunzaizhuyi/maskPlugin 为一个视频添加一个覆盖物，从而挡住视频某区域，在视频的某一时间段，比如第10到第20分钟不显示划定的这块区域。应用场景包括遮挡卫视图标、遮挡视频右下角广告、充当马赛克等。 有基于div和基于canvas两种技术方案，本文是使用canvas完成的。 主要原理是在HTML的video标签上贴上一个透明的canvas图层，然后响应mousedown、mousemove、mouseup事件。 由于canvas事件只是基于canvas元素，所以canvas内部每个元素（一个矩形，一个圆等）的事件响应要利用坐标来自己代码完成。 ","date":"2019-04-15","objectID":"/post/js-snippets/:2:0","tags":["JS"],"title":"JS-snippets","uri":"/post/js-snippets/"},{"categories":null,"content":"h5中利用canvas绘制video 忽略浏览器自带视频播放控件 使用canvas绘制视频。 可以在视频中绘制其他按钮。 ","date":"2019-04-15","objectID":"/post/js-snippets/:3:0","tags":["JS"],"title":"JS-snippets","uri":"/post/js-snippets/"},{"categories":null,"content":"编程思想 ","date":"2019-04-10","objectID":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/:1:0","tags":null,"title":"编程-规范(NODE为主)","uri":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/"},{"categories":null,"content":"面向过程 ","date":"2019-04-10","objectID":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/:1:1","tags":null,"title":"编程-规范(NODE为主)","uri":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/"},{"categories":null,"content":"面向对象 《重构:改善既有代码的设计》9.0 《Effective Java 中文版》8.9 《深入浅出面向对象分析与设计（中文版）》8.8 《UML和模式应用》8.1 继承 封装 多态 ","date":"2019-04-10","objectID":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/:1:2","tags":null,"title":"编程-规范(NODE为主)","uri":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/"},{"categories":null,"content":"函数式编程 函数式编程入门教程. Ramda 一款实用的 JavaScript 函数式编程库 ","date":"2019-04-10","objectID":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/:1:3","tags":null,"title":"编程-规范(NODE为主)","uri":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/"},{"categories":null,"content":"变量 不要定义没有用到的变量； 不要使用只有自己知道的缩写，最好使用完整的单词（有具体含义）； 变量名中不要指定类型； 常量使用全大写声明在显眼位置； 对于求值变量，要进行兜底，万一有取不到的情况，就会报错。 ","date":"2019-04-10","objectID":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/:2:0","tags":null,"title":"编程-规范(NODE为主)","uri":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/"},{"categories":null,"content":"函数 对于返回true或者false的函数，最好以should/is/can/has开头； 功能函数使用纯函数； 调用函数时，传参有说明； 动作函数要以动词开头； 一个函数只能完成一个功能； 优先使用函数式编程，例如使用map、filter、find、some、any、forEach替代for循环； 尽量使用switch或者数组替代if else： let handler = { 1: () =\u003e {}, 2: () =\u003e {}, 3: () =\u003e {}, default: () =\u003e {} } handler[a]() || handler['default']() [JS]尽量使用ES6，可以的话使用ES7 (1)使用箭头函数 let foo = () =\u003e { // code } 不要使用 function foo() { //code } (2)连接字符串使用模板字符，不要使用加号 `${varname}` (3)使用结构赋值，不要使用传统赋值 {，} = var； (4)尽量使用类class class Human extends Mammal { cinstructor(){ } } ","date":"2019-04-10","objectID":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/:3:0","tags":null,"title":"编程-规范(NODE为主)","uri":"/post/%E7%BC%96%E7%A8%8B-%E8%A7%84%E8%8C%83/"},{"categories":null,"content":"基于NRF芯片进行BLE开发的相关笔记","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"NRF开源的库从底层到顶层。 ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:0:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"NordicSemiconductor/pc-ble-driver C\\C++ 最新版本V4.1.1 提供C/C++库for Bluetooth Low Energy nRF5 SoftDevice serialization.可以直接调用，也可以使用其上层封装（js和python版）。 pc-ble-driver是Nordic提供的一套开源的上位机BLE开发软件库，配合nrf52832开发板，可以在上位机实现BLE中央设备和外设的功能。上位机与硬件板之间通过UART通信，通信协议类似于蓝牙的HCI。在硬件设备中，运行基于softdevice的connectivity程序，与上位机的UART进行交互。 pc-ble-driver提供C/C++、Python和Node.js三种源码库， ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:1:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"NordicSemiconductor/pc-ble-driver-js NODEJS Node.js interface to the C/C++ pc-ble-driver library. 被nrfconnect使用通过nrf52840 dongle扫描和连接和DFU。 ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:2:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"pc-nrf-dfu-js NODEJS pc-nrf-dfu-js is a Javascript module which provides DFU (Device Firmware Upgrade) via USB CDC ACM transport for Nordic devices.通过ACM口来更新Nordic设备的固件。 import bleDriver from 'pc-ble-driver-js' //创建adapter实例 import { AdapterFactory, FirmwareRegistry } from 'pc-ble-driver-js'; const adapter = adapterFactory.createAdapter(sdVersion, comName, instanceId); adapter.close(error =\u003e {}); //创建DFU dfu = new bleDriver.Dfu('BLE', { adapter, targetAddress: device.address, //MAC地址 targetAddressType: device.addressType, //'BLE_GAP_ADDR_TYPE_RANDOM_STATIC' or `BLE_GAP_ADDR_TYPE_PUBLIC`. bondingData: getBondingData(), }); setupListeners(dispatch); function setupListeners(dispatch) { dfu.on('transferStart', fileName =\u003e { dispatch(transferFileStartedAction(fileName)); }); dfu.on('transferComplete', fileName =\u003e { dispatch(transferFileCompletedAction(fileName)); }); dfu.on('progressUpdate', progress =\u003e { dispatch(updateProgressAction(progress)); }); dfu.on('logMessage', onLogMessage); } function updateProgressAction(progressInfo) { return { type: UPDATE_PROGRESS, percentCompleted: progressInfo.percentCompleted, status: progressInfo.stage, bytesPerSecond: progressInfo.bytesPerSecond, averageBytesPerSecond: progressInfo.averageBytesPerSecond, completedBytes: progressInfo.completedBytes, totalBytes: progressInfo.totalBytes, }; } function removeListeners() { dfu.removeAllListeners('transferStart'); dfu.removeAllListeners('transferComplete'); dfu.removeAllListeners('progressUpdate'); dfu.removeAllListeners('logMessage'); } dfu.performDFU(filePath, (error, aborted) =\u003e { if (error) { dispatch(performDfuError(error)); dispatch(showErrorDialog({ message: error.message })); } else if (aborted) { dispatch(abortSuccessAction()); } else { dispatch(performDfuSuccessAction()); } // DFU done. The adapter might still be connected to the device, // if the DFU failed or was aborted. Make sure the adapter is // disconnected from the device before handing back control of // events to nRF Connect. disconnectFromDevice(adapter, device.address).then(() =\u003e { dispatch(enableDeviceEvents(device.address)); }); // For unbonded Buttonless DFU: disconnectFromDevice(adapter, addressPlusOne).then(() =\u003e { dispatch(enableDeviceEvents(addressPlusOne)); }); }); ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:3:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"NordicSemiconductor/pc-nrfconnect-rssi NODEJS nrfconnect app RSSI数据的可视化. The app shows dBm per frequency in the 2400-2480 MHz range, and allows the user to tweak settings like sweep delay and animation duration. The app can be installed from the Add/remove apps screen in nRF Connect. The following devices are supported: PCA10040 nRF52832 Development Kit PCA10059 nRF52840 Dongle ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:4:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"pc-nrfconnect-ble NODEJS nrfconnect app BLE连接库（管理与其他ble设备的连接） nRF Connect Bluetooth® Low Energy is a cross-platform tool that enables testing and development with Bluetooth Low Energy (previously called Bluetooth Smart). It allows easy setup of connections with other devices and use these connections for reading and writing to the external nodes. nRF Connect Bluetooth Low Energy is implemented as an app for nRF Connect. The app supports the following devices: PCA10028 nRF51 Development Kit PCA10031 nRF51 Dongle PCA10040 nRF52 Development Kit PCA10056 nRF52840 Development Kit PCA10059 nRF52840 Dongle ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:5:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"pc-nrfconnect-core 可在此框架上创建自己的APP nRF Connect is跨平台的框架运行APPfor creating desktop apps for use with development kits or dongles from Nordic Semiconductor. It provides a common foundation for creating apps that communicate with the devices ver serial port,The framework comes with a skeleton(包含一些基础UI组件) that has standard UI components for selecting devices, navigation menus, logging, etc. Apps can decorate the standard components, create new components, and use built-in libraries in order to create end-user tools. nRF Connect supports the following devices: PCA10028 nRF51 Development Kit PCA10031 nRF51 Dongle PCA10040 nRF52 Development Kit PCA10056 nRF52840 Development Kit PCA10059 nRF52840 Dongle Note that while the nRF Connect framework has support for all these devices, the device support in nRF Connect apps may vary. ","date":"2019-04-08","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/:6:0","tags":["嵌入式"],"title":"嵌入式-NRF-BLE","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nrf-ble/"},{"categories":null,"content":"NFC类型 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:1:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"NFC-A 基于ISO/IEC 14443A。类似RFID-A。AM调制弥勒编码（高低代表1和0）。106 Kbps数据速率。 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:1:1","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"NFC-B 基于ISO/IEC 14443B。类似RFID-B。AM调制曼彻斯特编码（边沿触发）。106 Kbps数据速率。 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:1:2","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"NFC-F 基于FeliCA JIS X6319-4。更快。也被称作FeliCA。它被用于各种各样的应用，如基于creadit卡或借记卡的支付，地铁车票的访问控制，在办公室和住宅公寓的个人识别等。 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:1:3","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"NFC标签类型(TAG) 参考MIFARE Type Identification Procedure可以看到ATQA和SAK与卡类型的对应关系。 type Standard Memory Size Speed Data Access Collision mechanism Compliant Products Pricing Type-1 ISO-14443A 96 bytes 106 Kbps Read/Write or Read Only Data collision protection not available Innovision Topaz Low Type-2 ISO-14443A 48 bytes/ 144 bytes 106 Kbps Read/Write or Read Only Anti-collision support available NXP Mifare Ultralight, NXP Mifare Ultralight C Low Type-3 ISO-18092, JIS-X-6319-4 1/4/9 KB 212 or 424 kbps Read/Write or Read Only Anti-collision support available Sony Felica High Type-4 NXP DESFire Tag (ISO-14443A) 4 KB/ 32 KB 106/212/424 Kbps Read/Write or Read Only Anti-collision support available NXP DESFire, NXP SmartMX-JCOP Medium to high Type-5 Tag (Type Mifare Classic Tag) ISO-14443A, MF1 IC S50 192 Bytes/ 768 bytes/ 3584 bytes 106Kbps Read/Write or Read Only Anti-collision Support available NXP Mifare Classic 1K, NXP Mifare Classic 4K, NXP Mifare Classic Mini Low ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:2:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"APDU 智能卡与智能卡读卡器之间传送的信息单元, 是给智能卡发送的命令。 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:3:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"IFD（读卡接口设备）与IC卡之间的通讯： 首先，IFD发送5个字节的命令头给IC卡，这5个字节的内容告诉了IC卡要做什么操作； 然后，IC卡回传一个过程字节给IFD，告诉IFD，IC卡是否支持该操作； 如果返回的过程字节告诉IFD——IC卡支持该操作，则接下来就进行数据的传输（如果有的话），数据从IFD输入到IC卡或数据从IC卡输出到IFD； 如果返回的过程字节告诉IFD——IC卡不支持该操作，则IC卡回传给IFD两个状态字节SW1 SW2，IFD根据SW1 SW2两字节判断IC卡不支持该操作的原因； ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:3:1","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"命令头 CLA 指令类别 其中值‘FF’被保留用于PPS。注意 ISO/IEC 7816-4 强制‘FF’对于CLA为无效值 INS 指令码 其中值‘6X’和‘9X’为无效值。注意 ISO/IEC 7816-4 强制‘6X’和‘9X’对于INS为无效值 P1 参数1 P2 参数2 Lc Data的长度 =0 Data Le 希望响应的数据的长度 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:3:2","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"指令类别和指令码 指令 类别 指令码 功能 例子 参数1 参数2 SELECT 00 A4 选择文件 READ BINARY 00 B0 读二进制文件内容 0x00, 0xb0, 0x00, 0x00, 0x10 读取16个字节 READ RECORD 00 B2 读记录文件指定内容 UPDATE BINARY 00/04 D6 写二进制文件 UPDATE RECORD 00/04 DC 写记录文件 00 a4 选择文件 0x04（根据名称选择）;0x00（根据file id选择） 0x00（根据名称选择）；0x0C（根据file id选择） ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:3:3","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"状态码 |状态码| 十进制表示 |性质|错误解释| |–|–|–| |9000 | 144， 0|正常| 成功执行| |6200 |警告 信息未提供 |6281 |警告 回送数据可能出错 |6282 |警告 文件长度小于Le |6283 |警告 选中的文件无效 |6284 |警告 FCI格式与P2指定的不符 |6300 警告 鉴别失败 |63Cx 警告 校验失败（x－允许重试次数） |6400 出错 状态标志位没有变 |6581 出错 内存失败 |6700 出错 长度错误 |6882 出错 不支持安全报文 |6981 出错 命令与文件结构不相容，当前文件非所需文件 |6982 出错 操作条件（AC）不满足，没有校验PIN |6983 出错 认证方法锁定，PIN被锁定 |6984 出错 随机数无效，引用的数据无效 |6985 出错 使用条件不满足 |6986 出错 不满足命令执行条件（不允许的命令，INS有错） |6987 出错 MAC丢失 |6988 出错 MAC不正确 |698D 保留 |6A80 出错 数据域参数不正确 |6A81 出错 功能不支持；创建不允许；目录无效；应用锁定 |6A82 | 106,130 |出错 |该文件未找到| |6A83 出错 该记录未找到 |6A84 出错 文件预留空间不足 |6A86 出错 P1或P2不正确 |6A88 出错 引用数据未找到 |6B00 出错 参数错误 |6Cxx 出错 Le长度错误，实际长度是xx |6E00 出错 不支持的类：CLA有错 |6F00 出错 数据无效 |6D00 出错 不支持的指令代码 |9301 出错 资金不足 |9302 出错 MAC无效 |9303 出错 应用被永久锁定 |9401 出错 交易金额不足 |9402 出错 交易计数器达到最大值 |9403 出错 密钥索引不支持 |9406 出错 所需MAC不可用 |6900 出错 不能处理 |6901 出错 命令不接受（无效状态） |61xx 正常 需发GET RESPONSE命令 |6600 出错 接收通讯超时 |6601 出错 接收字符奇偶错 |6602 出错 校验和不对 |6603 警告 当前DF文件无FCI |6604 警告 当前DF下无SF或KF ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:3:4","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"NDEF 参考haldean/ndef ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:4:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"读写TAG 4 使用pn532仿真tag4获得此流程。 Emulating NDEF tag now, please touch it with a second NFC device // 第一步：NDEF Tag Application Select Procedure 根据名称选择 In: 00 a4 04 00 07 d2 76 00 00 85 01 01 00 Out: 90 00 // 第二步：根据file_id选择 In: 00 a4 00 0c 02 e1 03 Out: 90 00 // 读 In: 00 b0 00 00 0f Out: 00 0f 20 00 54 00 ff 04 06 e1 04 ff fe 00 00 90 00 In: 00 a4 00 0c 02 e1 04 Out: 90 00 In: 00 b0 00 00 02 Out: 00 21 90 00 In: 00 b0 00 02 21 Out: d1 02 1c 53 70 91 01 09 54 02 65 6e 4c 69 62 6e 66 63 51 01 0b 55 03 6c 69 62 6e 66 63 2e 6f 72 67 90 00 In: 00 a4 00 0c 02 e1 03 Out: 90 00 In: 00 b0 00 00 0f Out: 00 0f 20 00 54 00 ff 04 06 e1 04 ff fe 00 00 90 00 In: 00 a4 00 0c 02 e1 04 Out: 90 00 In: 00 b0 00 00 02 Out: 00 21 90 00 // 写第一步 In: 00 d6 00 00 02 00 00 Out: 90 00 // 写第二步 In: 00 d6 00 02 16 d1 01 12 54 \u003c数据\u003e Out: 90 00 // 写第三步 In: 00 d6 00 00 02 00 16 Out: 90 00 In: 03 b0 00 00 01 nfc_emulate_target: Success ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:4:1","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"读卡器 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:5:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"ACR122U 支持Android™ OS 3.1 及以上版本（使用OTG）。 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:5:1","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"PN532 PN532是一个高度集成的非接触读写芯片，它包含80C51微控制器内核，集成了13.56MHz下的各种主动/被动式非接触通信方法和协议。 PN532传输模块支持6种不同的工作模式： 读写器模式，支持ISO/IEC 14443A / MIFARE®机制 读写器模式，支持 FeliCa机制 读写器模式，支持ISO/IEC 14443B机制 卡操作模式，支持ISO 14443A / MIFARE®机制 卡操作模式，FeliCa机制 ISO/IEC18092，ECM340点对点 用户手册 命令支持 |a |b |c |d |e |f |g |h |i |j |k | |–|–|–|–|–|–|–|–|–|–| |0x00| 0x00| 0xFF| LEN(数据长度+1)|LCS(LEN的校验)| 0xD4|CC|Optional Input Data|DCS|0x00| 00 00 FF LEN LCS D5 CC+1 Optional Output Data DCS 00 读取PN532版本 发送：0x02 返回：0x03 0x32 0x01 0x06 0x07 InDataExchange 支持读卡器（PN532）和TAG之间的协议数据（APDU）交流。 Libnfc Ubuntu下使用 安装完libnfc; 更改配置：/etc/nfc/libnfc.conf device.name = \"microBuilder.eu\" device.connstring = \"pn532_uart:/dev/ttyUSB0\" modules NFC Device/Hardware manipulation API nfc/drivers/pn532_i2c.c static nfc_device * pn532_i2c_open(const nfc_context *context, const nfc_connstring connstring) nfc/nfc/nfc-internal.c int connstring_decode(const nfc_connstring connstring, const char *driver_name, const char *bus_name, char **pparam1, char **pparam2) nfc/nfc/nfc.c void nfc_init(nfc_context ** context) // context Output location for nfc_context // (必须第一步)Initialize libnfc. This function must be called before calling any other libnfc function. size_t nfc_list_devices(nfc_context * context, // The context to operate on, or NULL for the default context. nfc_connstring connstrings[], // array of nfc_connstring. const size_t connstrings_len // size of the connstrings array. ) // (可选)扫描支持的设备 (ie. only available for some drivers)返回找到的设备数量 nfc_device* nfc_open(nfc_context * context, // The context to operate on. const nfc_connstring connstring // The device connection string if specific device is wanted, NULL otherwise ) // Open a NFC device.Returns pointer to a nfc_device struct if successfull; otherwise returns NULL value. int nfc_initiator_init(nfc_device * pnd) // Initialize NFC device as initiator (reader)读卡器 int nfc_initiator_list_passive_targets ( nfc_device * pnd, // nfc_device struct pointer that represent currently used device const nfc_modulation nm, // desired modulation nfc_target ant[], // array of nfc_target that will be filled with targets info const size_t szTargets // size of ant (will be the max targets listed) ) // List passive or emulated tags. Returns the number of targets found on success, otherwise returns libnfc's error code (negative value) int nfc_initiator_select_passive_target ( nfc_device * pnd, // nfc_device struct pointer that represent currently used device const nfc_modulation nm, //desired modulation const uint8_t * pbtInitData, // optional initiator data, NULL for using the default values. const size_t szInitData, // pbtInitData的长度. nfc_target * pnt // nfc_target struct pointer which will filled if available ) // 选择一个tag Returns selected passive target count on success, otherwise returns libnfc's error code (negative value) // 执行下边的函数必须先选择target int nfc_initiator_transceive_bytes ( nfc_device * pnd, // nfc_device struct pointer that represent currently used device const uint8_t * pbtTx, // 待发送帧的字节数组 const size_t szTx, // 待发送帧的字节数组的长度 uint8_t * pbtRx, // 用来存储从卡中读取的数据字节 const size_t szRx, // size of pbtRx (Will return NFC_EOVFLOW if RX exceeds this size) int timeout // in milliseconds ) // Returns received bytes count on success, otherwise returns libnfc's error code //The NFC device (configured as initiator) will transmit the supplied bytes (pbtTx) to the target. It waits for the response and stores the received bytes in the pbtRx byte array. //If NP_EASY_FRAMING option is disabled the frames will sent and received in raw mode: PN53x will not handle input neither output data. //The parity bits are handled by the PN53x chip. The CRC can be generated automatically or handled manually. Using this function, frames can be communicated very fast via the NFC initiator to the tag. //Tests show that on average this way of communicating is much faster than using the regular driver/middle-ware (often supplied by manufacturers). //WARNING:The configuration option NP_HANDLE_PARITY must","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:5:2","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"MFRC522 非接触CPU卡读卡模块|Mifare plus读写模块|CUT100-PLUS 周立功 ZLG522S/T RFID 读卡模块 13.56MHz 可直拍 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:5:3","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"模拟标签 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:6:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"NRF52832 NFCT(Near field communication tag)是NFC-A类型。 寄存器 功能 TXD.FRAMECONFIG 设置发送数据帧的格式 RXD.FRAMECONFIG 设置接收数据帧的格式 SDK nrf5_sdk/components/nfc/t4t_lib/nfc_t4t_lib.h This is the NFC Forum NDEF tag 4 type emulation library. It implements the ISO14443-4A protocol (ISO-DEP) and additionally can emulate a read-writable NDEF content. If the emulation of the NDEF content is not needed, the library works in a raw mode where all APDUs are delivered to the user, who is then responsible to generate a timely RPDU as a response. The sequence of initializing functions determines whether the NDEF emulation will run or whether the raw mode is used. E.g. NDEF emulation * @ref nfc_t4t_setup * @ref nfc_t4t_ndef_rwpayload_set or @ref nfc_t4t_ndef_staticpayload_set * @ref nfc_t4t_emulation_start * ... running in NDEF emulation mode ... E.g. RAW mode * @ref nfc_t4t_setup * @ref nfc_t4t_emulation_start * ... running in RAW emulation mode ... nrf5_sdk/components/nfc/t2t_lib/nfc_t2t_lib.h NFC Forum type 2 tag. ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:6:1","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"缩略语 PICC proximity card，感应卡 ","date":"2019-04-04","objectID":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/:7:0","tags":["NFC"],"title":"嵌入式-NFC","uri":"/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-nfc/"},{"categories":null,"content":"JS模块化开发规范及常用插件","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"理论 参考详解JavaScript模块化开发 参考JavaScript中的模块化开发 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 AMD规范的实现主要有RequireJS，CMD规范的主要实现有SeaJS。RequireJS在国外用的比较多，SeaJS在国内用的比较多，并且SeaJS的创始人为阿里的玉伯，所以SeaJS在阿里系用的非常广泛，包括京东等大厂也在用SeaJS，我们详细介绍的也是SeaJS。但是SeaJS已经停止维护了，因为在ES6中已经有了模块化的实现，随着ES6的普及，第三方的模块化实现将会慢慢的淘汰（但是这个在国内可能还要很多年）。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:0:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Commonjs 服务器端规范,node.js用的就是CommonJS规范. 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 在node.js中直接使用require引包，直接使用exports和module.exports暴露公开成员，并且npm基于CommonJs实现了自动加载和安装依赖。 var i = 1; var max = 30; // module指的就是当前文件 module.exports = function () { for (i -= 1; i++ \u003c max; ) { console.log(i); } max *= 1.1; }; module.exports = { [插件名]:{ } } //与下方一致 exports.[插件名] = { } ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:1:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Promises/A Promises/A是由CommonJS组织制定的异步模式编程规范，有不少库已根据该规范及后来经改进的Promises/A+规范提供了实现. 参考JS魔法堂：剖析源码理解Promises/A规范 规范 有限状态机 Promise（中文：承诺）其实为一个有限状态机，共有三种状态：pending（执行中）、fulfilled（执行成功）和rejected（执行失败）。 其中pending为初始状态，fulfilled和rejected为结束状态（结束状态表示promise的生命周期已结束）。 状态转换关系为：pending-\u003efulfilled，pending-\u003erejected。 随着状态的转换将触发各种事件（如执行成功事件、执行失败事件等）。 构造函数 Promise({Function} factory/({Function} resolve, {Function} reject)/) ，构造函数存在一个Function类型的入参factory，作为唯一一个修改promise对象状态的地方，其中factory函数的入参resolve的作用是将promise对象的状态从pending转换为fulfilled，而reject的作用是将promise对象的状态从pending转换为rejected。 入参 void resolve({Any} val) ，当val为非thenable对象和promise对象时则会将val作为执行成功事件处理函数的入参，若val为thenable对象时则会执行thenable.then方法，若val为Promise对象时则会将该Promise对象添加到Promise对象单向链表中。 入参 void reject({Any} reason) ，reason不管是哪种内容均直接作为执行失败事件处理函数的入参。 注意：关于抛异常的做法，同步模式为 throw new Error(“I’m synchronous way!\") ，而Promise规范的做法是 reject(new Error(“I’m asynchronous way!\")); 实例方法 Promise then([{Function} onFulfilled[, {Function} onRejected]]) ，用于订阅Promise对象状态转换事件，入参onFulfilled为执行成功的事件处理函数，入参onRejected为执行失败的事件处理函数。两者的返回值均作为Promise对象单向链表中下一个Promise对象的状态转换事件处理函数的入参。而then方法的返回值是一个新的Promise对象并且已添加到Promise对象单向链表的末尾。 Promise catch({Function} onRejected) ，相当于 then(null, onRejected) 。 类方法 Promise Promise.resolve({Any} obj) ，用于将非Promise类型的入参封装为Promise对象，若obj为非thenable对象则返回状态为fulfilled的Promise对象，对于非若入参为Promise对象则直接返回。 Promise Promise.reject({Any} obj) ，用于将非Promise类型的入参封装为状态为rejected的Promise对象。 Promise Promise.all({Array} array) ，当array中所有Promise实例的状态均为fulfilled时，该方法返回的Promise对象的状态也转为fulfilled（执行成功事件处理函数的入参为array数组中所有Promise实例执行成功事件处理函数的返回值），否则转换为rejected。 Promise Promise.race({Array} array) ，当array中有一个Promise实例的状态出现fulfilled或rejected时，该方法返回的Promise对象的状态也转为fulfilled或rejected。 thenable对象 拥有 then方法 的对象均称为thenable对象，并且thenable对象将作为Promise对象被处理。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:1:1","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"AMD(Asynchronous Module Definition) 在浏览器端模块化开发的规范 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD规范的实现主要有RequireJS ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:2:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"CMD CMD规范的主要实现有SeaJS 常用模块 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:3:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Browser和Nodejs共同支持 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"AXIOS（HTTP客户端） 基于promise用于浏览器和node.js的http客户端； 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 拦截器 你可以在then和catch之前拦截请求和响应。 // 添加一个请求拦截器 axios.interceptors.request.use(function (config) { // Do something before request is sent return config; }, function (error) { // Do something with request error return Promise.reject(error); }); // 添加一个响应拦截器 axios.interceptors.response.use(function (response) { // Do something with response data return response; }, function (error) { // Do something with response error return Promise.reject(error); }); 如果之后想移除拦截器你可以这么做 var myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 你也可以为axios实例添加一个拦截器 var instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:1","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"bezier-js 一个Node.js和客户端库，用于（二次和三次）贝塞尔曲线工作。 用于执行Bezier曲线操作 参考贝塞尔曲线应用（贝塞尔插值）使用两个点作为顶点，利用相邻的点生成2个控制点。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:2","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"caolan/async Async utilities for node and the browser ***** async模块是为了解决嵌套金字塔,和异步流程控制而生. ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:3","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"form-data A module to create readable \"multipart/form-data\" streams. Can be used to submit forms and file uploads to other web applications. ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:4","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"js-spline 程序包提供了JavaScript的算法实现，这些算法可从一组控制方式点生成各种类型的样条。 插值之后的曲线经过样本点，拟合的曲线不一定经过样本点。 插值算法比较:1. 反距离加权法（Inverse Distance Weighted）两个物体相似性随他们间的距离增大而减少。2. 样条插值法（Spline）样条插值是使用一种数学函数，对一些限定的点值，通过控制估计方差，利用一些特征节点，用多项式拟合的方法来产生平滑的插值曲线。这种方法适用于逐渐变化的曲面，如温度、高程、地下水位高度或污染浓度等。3、克里金法（Kriging）这种方法认为在空间连续变化的属性是非常不规则的，用简单的平滑函数进行模拟将出现误差，用随机表面函数给予描述会比较恰当。4、离散平滑插值（Discrete Smooth Interpolation）欲在一个离散化数据点间建立相互联络的网络，如果网络上的已知节点值满足某种约束条件，则未知节点上的值可以通过解线性方程而得到。5、趋势面光滑插值（Trend Surface）作为一个非精确的插值方法，趋势面插值用多项式表示的线或面按最小二乘法原理对数据点进行拟合.6.贝塞尔插值。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:5","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"kennethjiang/js-file-download保存数据到文件中 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:6","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库 ***** ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:7","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"smartprocure/futil-js Lodash的补充 ***** ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:8","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"moment 格式化分析日期和时间 ***** ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:9","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"moment/luxon A library for working with dates and times in JS ***** 每年的最后几天是下一年的第一周。 DateTimeconst { DateTime } = require(\"luxon\") var dt = DateTime.local(2017, 5, 15, 8, 30); var now = DateTime.local(); dt = DateTime.fromObject({day: 22, hour: 12, zone: 'America/Los_Angeles', numberingSystem: 'beng'}) DateTime.fromISO(\"2017-05-15\") //=\u003e May 15, 2017 at midnight DateTime.fromISO(\"2017-05-15T08:30:00\") //=\u003e May 15, 2017 at 8:30 DateTime.local().toString() //=\u003e '2017-09-14T03:20:34.091-04:00' dt = DateTime.local() dt.year //=\u003e 2017 dt.month //=\u003e 9 dt.day //=\u003e 14 dt.second //=\u003e 47 dt.weekday //=\u003e 4 dt.zoneName //=\u003e 'America/New_York' dt.offset //=\u003e -240 dt.daysInMonth //=\u003e 30 dt.toLocaleString() //=\u003e '9/14/2017' dt.toLocaleString(DateTime.DATETIME_MED) //=\u003e 'September 14, 3:21 AM' dt.toISO() //=\u003e '2017-09-14T03:21:47.070-04:00' var dt = DateTime.local(); dt.plus({hours: 3, minutes: 2});　//　计算 dt.minus({days: 7}); // 减 dt.startOf('day'); dt.endOf('hour'); var dt = DateTime.local(); dt.set({hour: 3}).hour //设置时间 var dt = DateTime.local(); var f = {month: 'long', day: 'numeric'}; dt.setLocale('fr').toLocaleString(f) //=\u003e '14 septembre' dt.setLocale('en-GB').toLocaleString(f) //=\u003e '14 September' dt.setLocale('en-US').toLocaleString(f) //=\u003e 'September 14' Info.months('long', {locale: 'fr'}) //=\u003e [ 'janvier', 'février', 'mars', 'avril', ... ] DateTime.fromObject({zone: 'America/Los_Angeles'}) // now, but expressed in LA's local time DateTime.local().setZone('America/Los_Angeles') // same DateTime.utc(2017, 5, 15); DateTime.utc(); DateTime.local().toUTC(); DateTime.utc().toLocal(); var dur = Duration.fromObject({hours: 2, minutes: 7}); dt.plus(dur); dur.hours //=\u003e 2 dur.minutes //=\u003e 7 dur.seconds //=\u003e 0 dur.as('seconds') //=\u003e 7620 dur.toObject() //=\u003e { hours: 2, minutes: 7 } dur.toISO() //=\u003e 'PT2H7M' now = DateTime.local(); later = DateTime.local(2020, 10, 12); i = Interval.fromDateTimes(now, later); i.length() //=\u003e 97098768468 i.length('years') //=\u003e 3.0762420239726027 i.contains(DateTime.local(2019)) //=\u003e true i.toISO() //=\u003e '2017-09-14T04:07:11.532-04:00/2020-10-12T00:00:00.000-04:00' i.toString() //=\u003e '[2017-09-14T04:07:11.532-04:00 – 2020-10-12T00:00:00.000-04:00) ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:10","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"moment-timezone 分析和格式化日期时间在各个时区 ***** ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:11","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Ramda 一款实用的 JavaScript 函数式编程库 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:12","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"range 类似python的range ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:13","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Simplify.js 压缩点数（轨迹不失真） ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:14","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Underscore.js 一个 JavaScript 工具库 ***** 它提供了一整套函数式编程的实用功能，但是没有扩展任何 JavaScript 内置对象. ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:15","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"when.js promise + async ****** A solid, fast Promises/A+ and when() implementation, plus other async goodies. 参考异步编程：When.js快速上手. 优化promise. ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:4:16","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"NodeJs支持 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Automattic/node-canvas 在node中实现canvas渲染 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:1","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"BULL KUE不再维护。 简单队列 简单创建一个队列实例。 const myFirstQueue = new Bull('my-first-queue'); 一个简单队列大致有3个主要角色： A job producer, a job consumer or/and an events listener. 虽然一个给定的实例可以用于3个角色，但通常将生产者和消费者分成几个实例。 一个给定的队列，总是由其实例化名称（上例中的my-first-queue）引用，可以有许多生产者，许多消费者和许多听众。 一个重要的方面是，即使当时没有可用的消费者，生产者也可以将作业添加到队列中：队列提供异步通信，这是使它们如此强大的功能之一。 相反，您可以让一个或多个worker从队列中消费作业，它将按照给定的顺序消费这些作业:FIFO(缺省值)、LIFO或根据优先级。 生产者 const myFirstQueue = new Bull('my-first-queue'); const job = await myFirstQueue.add({ foo: 'bar' }); 消费者 const myFirstQueue = new Bull('my-first-queue'); myFirstQueue.process(async (job, data) =\u003e { return doSomething(data); }); 有时您需要向外部侦听器提供作业的进度信息，这可以通过在作业对象上使用progress方法轻松完成： myFirstQueue.process( async (job, data) =\u003e { let progress = 0; for(i = 0; i \u003c 100; i++){ await doSomething(data); progress += 10; job.progress(progress); } }); 选项 速率限制 // Limit queue to max 1.000 jobs per 5 seconds. const myRateLimitedQueue = new Queue('rateLimited', { limiter: { max: 1000, duration: 5000 } }); Named jobs // Jobs producer const myJob = await transcoderQueue.add('image', { input: 'myimagefile' }); const myJob = await transcoderQueue.add('audio', { input: 'myaudiofile' }); const myJob = await transcoderQueue.add('video', { input: 'myvideofile' }); // Worker transcoderQueue.process('image', processImage); transcoderQueue.process('audio', processAudio); transcoderQueue.process('video', processVideo); 每一个命名的JOB必须有一个对应的processer。 Sandboxed Processors JOB类型 LIFO 后进先出 const myJob = await myqueue.add({ foo: 'bar' }, { lifo: true }); Delayed 延时。 设置的为最小延时，过了这个时间，才放进可执行队列中。 // Delayed 5 seconds const myJob = await myqueue.add({ foo: 'bar' }, { delay: 5000 }); 优先级 可重复 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:2","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"generic-pool 连接池 ***** NNODEJS的一般链接池模块。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:3","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"ioredis ***** 一个健壮的、以性能为中心的、功能全面的Redis Node.js客户端. redis.set(\"foo\", \"bar\"); redis.set(\"dir:key\",value); //可以创建dir文件夹，归类key redis.get(\"foo\", function(err, result) { // get value console.log(result); }); redis.del(\"foo\"); // 删除键 // Or using a promise if the last argument isn't a function redis.get(\"foo\").then(function(result) { console.log(result); }); redis.keys('course*'); // 列出匹配到给定字符串的key的列表 // Arguments to commands are flattened, so the following are the same: redis.sadd(\"set\", 1, 3, 5, 7); //集合 redis.sadd(\"set\", [1, 3, 5, 7]); // All arguments are passed directly to the redis server: redis.set(\"key\", 100, \"EX\", 10); redis.setex(\"key\", time, \"msg\");//存进redis中，并设置超时时间。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:4","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"is-type-of complete type checking for node类型检测。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:5","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"JsonWebToken JWT jwt.sign(payload, secretOrPrivateKey, [options, callback]) 生成Token secretOrPrivateKey is a string, buffer, or object 包含secret(for HMAC algorithms)或者the PEM encoded private key(for RSA and ECDSA). In case of a private key with passphrase an object { key, passphrase } can be used (based on crypto documentation), in this case be sure you pass the algorithm option. OpenSSL生成pem，der文件 jwt.verify(token, secretOrPublicKey, [options, callback]) 校验Token ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:6","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"StratoDem/pandas-js DataFrame 支持常用的统计。 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:7","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"puppeteer ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:8","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"request ***** 业务不复杂的情况下，使用Nodejs的原生http模块的客户端功能可满足需求，但在业务较复杂时使用http模块工作量会比较大，使用第三方request模块会让http请求变的简单。 Request模块封装了http请求，使你可以用很简单的方式处理http请求，同时也支持HTTPS和请求重定向. ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:9","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Request-Promise ****** request增加promise的支持。 流操作 form相关 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:5:10","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Browser支持 ","date":"2019-04-03","objectID":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/:6:0","tags":["JS","NODE"],"title":"模块化开发及常用模块","uri":"/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%8C%85%E6%8B%ACnodejs%E6%A8%A1%E5%9D%97/"},{"categories":["PROGRAM"],"content":" WebAPI指一组设备兼容套件和访问接口，它允许Web应用及其内容访问设备硬件（比如电池状态或设备振动器），同时也可以获取设备上的数据（比如日历或联系人等信息）。通过这些API，我们希望对Web应用进行扩展，实现过去只有专有平台才可以实现的功能。 在使用 JavaScript 编写 Web 代码时，有许多 API 可供调用。这里是所有接口（即对象类型）的列表，你可以在开发网站或 Web 应用程序时使用它们。 ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:0:0","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"1. F ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:1:0","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"1.1. FileReader FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 重要提示： FileReader仅用于以安全的方式从用户（远程）系统读取文件内容 它不能用于从文件系统中按路径名简单地读取文件。 要在JavaScript中按路径名读取文件，应使用标准Ajax解决方案进行服务器端文件读取，如果读取跨域，则使用CORS权限。 Note: 此特性在 Web Worker 中可用。 ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:1:1","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"1.2. FileReaderSync FileReaderSync接口允许以同步的方式读取File或Blob对象中的内容。 该接口只在workers里可用,因为在主线程里进行同步I/O操作可能会阻塞用户界面。 ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:1:2","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"2. WebSocket ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:2:0","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"2.1. 构造函数 var ws = new WebSocket('ws://localhost:8080'); ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:2:1","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"2.2. 属性 2.2.1. readyState返回实例对象的当前状态 共有四种： CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 2.2.2. webSocket.onopen 实例对象的onopen属性，用于指定连接成功后的回调函数。 ws.onopen = function () { ws.send('Hello Server!'); } 如果要指定多个回调函数，可以使用addEventListener方法。 ws.addEventListener('open', function (event) { ws.send('Hello Server!'); }); 2.2.3. webSocket.onclose 实例对象的onclose属性，用于指定连接关闭后的回调函数。 ws.onclose = function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event }; ws.addEventListener(\"close\", function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event }); 2.2.4. webSocket.onmessage 实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 ws.onmessage = function(event) { var data = event.data; // 处理数据 }; ws.addEventListener(\"message\", function(event) { var data = event.data; // 处理数据 }); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。 ws.onmessage = function(event){ if(typeOf event.data === String) { console.log(\"Received data string\"); } if(event.data instanceof ArrayBuffer){ var buffer = event.data; console.log(\"Received arraybuffer\"); } } 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 // 收到的是 blob 数据 ws.binaryType = \"blob\"; ws.onmessage = function(e) { console.log(e.data.size); }; // 收到的是 ArrayBuffer 数据 ws.binaryType = \"arraybuffer\"; ws.onmessage = function(e) { console.log(e.data.byteLength); }; 2.2.5. webSocket.send() 实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 ws.send('your message'); 发送 Blob 对象的例子。 var file = document .querySelector('input[type=\"file\"]') .files[0]; ws.send(file); 发送 ArrayBuffer 对象的例子。 // Sending canvas ImageData as ArrayBuffer var img = canvas_context.getImageData(0, 0, 400, 320); var binary = new Uint8Array(img.data.length); for (var i = 0; i \u003c img.data.length; i++) { binary[i] = img.data[i]; } ws.send(binary.buffer); 2.2.6. webSocket.bufferedAmount 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 var data = new ArrayBuffer(10000000); socket.send(data); if (socket.bufferedAmount === 0) { // 发送完毕 } else { // 发送还没结束 } 2.2.7. webSocket.onerror 实例对象的onerror属性，用于指定报错时的回调函数。 socket.onerror = function(event) { // handle error event }; socket.addEventListener(\"error\", function(event) { // handle error event }); ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:2:2","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":["PROGRAM"],"content":"2.3. 排错 参考WebSocket 经常断开原因，解决办法：心跳机制防止自动断开连接. ws.onclose = function (e) { console.log('websocket 断开: ' + e.code + ' ' + e.reason + ' ' + e.wasClean) console.log(e) } e 是 CloseEvent 对象。 CloseEvent.code: code是错误码，是整数类型 CloseEvent.reason: reason是断开原因，是字符串 CloseEvent.wasClean: wasClean表示是否正常断开，是布尔值。一般异常断开时，该值为false。 ","date":"2019-04-03","objectID":"/post/program-js-ts-webapi/:2:3","tags":["PROGRAM","JS/TS","WEBAPI"],"title":"WebApi","uri":"/post/program-js-ts-webapi/"},{"categories":null,"content":"NFC ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:1:0","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"nfc-pcsc node:\u003e=8 分析源码 NFC类（继承自EventEmitter） |----emit reader(接收到pcsc的信号) |----reader类（参数） |----async write(blockNumber, data, blockSize = 4) |----async read(blockNumber, length, blockSize = 4, packetSize = 16, readClass = 0xff) |----async authenticate(blockNumber, keyType, key, obsolete = false) |----async loadAuthenticationKey(keyNumber, key) |----control(data, responseMaxLength) |----transmit(data, responseMaxLength) |----connect(mode = CONNECT_MODE_CARD) |----disconnect() |----emit error |----emit card.off //卡离开读卡器 |----emit card |----emit end |----emit error 参考[pokusew/electron-vue-nfc]例子(https://github.com/pokusew/electron-vue-nfc) 可以用于Electron APP，但是需要使用NODE原生模块。 注：运行包含此模块的应用时，需要一个NFC读卡器硬件插到电脑上，激活读卡器服务。否则运行程序会出现空白的情况。 使用此模块读取ISO 14443-4 tags时，需要进行额外的配置： // enable when you want to auto-process ISO 14443-4 tags (standard=TAG_ISO_14443_4) // when an ISO 14443-4 is detected, SELECT FILE command with the AID is issued // the response is available as card.data in the card event // you can set reader.aid to: // 1. a HEX string (which will be parsed automatically to Buffer) // reader.aid = 'F222222222'; // 2. an instance of Buffer containing the AID bytes // reader.aid = Buffer.from('F222222222', 'hex'); // 3. a function which must return an instance of a Buffer when invoked with card object (containing standard and atr) // the function may generate AIDs dynamically based on the detected card // reader.aid = ({ standard, atr }) =\u003e { // // return Buffer.from('F222222222', 'hex'); // // }; Ubuntu使用ACR122U参考 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:1:1","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"USB ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:2:0","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"usb 在安装usb之前，需要安装libusb Ubuntu/Debian: sudo apt-get install build-essential libudev-dev Windows：Use Zadig to install the WinUSB driver for your USB device. Otherwise you will get LIBUSB_ERROR_NOT_SUPPORTED when attempting to open devices. rebuild usb需要使用原生模块 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:2:1","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"BLE(使用CSR4.0) ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:3:0","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"noble/noble windows npm install --global --production windows-build-tools 在工程目录下 npm install bluetooth-hci-socket npm install noble A WinUSB driver is required, use Zadig tool to replace the driver for your adapter. ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:3:1","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"Nordic Semiconductor（NRF） 参见[NRF-BLE] ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:3:2","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"其他 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:4:0","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"Cfonts 性感的终端字体。 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:4:1","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"chalk 终端字型。 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:4:2","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"Electron 打造桌面应用。 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:4:3","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"seafile 不好用，可以自己参照github，自己实现。 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:4:4","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"[yargs/yargs] Yargs通过解析参数和生成优雅的用户界面，帮助您构建交互式命令行工具。 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:4:5","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"错误集锦 fatal error LNK1107 Error in node module: fatal error LNK1107 ","date":"2019-03-28","objectID":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:5:0","tags":["NODE","JS"],"title":"NODEJS-外围设备模块","uri":"/post/js-nodejs-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"单板贴装 ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:1:0","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"来料检验 ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:1:1","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"贴片（包含目检和机检） ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:1:2","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"烧写程序 ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:1:3","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"单板检测 ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:1:4","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"成品组装 ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:2:0","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"来料检验 ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:2:1","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"工装夹具制作 GET DRAFTSIGHT® 2019The freedom to do more with a better 2D drafting and 3D design experience. 创建CAD制图。 Free 30-Day Trial of DraftSight Professional 2019: download below for Windows, then select “Free 30-Day Trial” in the installation window. Mac and Linux users may access DraftSight 2019 Beta below at no cost. ","date":"2019-03-27","objectID":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/:3:0","tags":null,"title":"生产管理-产品从无到有","uri":"/post/%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86-%E4%BA%A7%E5%93%81%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89/"},{"categories":null,"content":"图 图描述一种多对多的关系。 最基本的单元是顶点（vertex），顶点之间的关联关系，被称为边（edge）。有的图中边具有权重（Weight）。涉及到权重的图，被称为带权图（Weighted Graph）。有的图中边还具有方向，这类图成为有向图，否则是无向图。 ","date":"2019-03-25","objectID":"/post/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":null,"title":"编程-数据结构","uri":"/post/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"存储方式 邻接矩阵 拥有n个顶点的图，它所包含的连接数量最多是n（n-1）个。因此，要表达各个顶点之间的关联关系，最清晰易懂的方式是使用二维数组（矩阵）。 表达图中顶点关联关系的矩阵，就叫做邻接矩阵。 无向图对应的矩阵是一个对称矩阵。 优点：简单直观，可以快速查到一个顶点和另一顶点之间的关联关系。 缺点：占用了太多的空间。 邻接表和逆邻接表 在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。 优点：空间可以大大缩小。 逆邻接表每一个顶点作为链表的头节点，后继节点所存储的是能够直接达到该顶点的相邻顶点。 可以根据实际需求，选择使用邻接表还是逆邻接表。 十字链表 十字链表的每一个顶点，都是两个链表的根节点，其中一个链表存储着该顶点能到达的相邻顶点，另一个链表存储着能到达该顶点的相邻节点。 在优化之后的十字链表中，链表的每一个节点不再是顶点，而是一条边，里面包含起止顶点的下标。 邻接多重表 ","date":"2019-03-25","objectID":"/post/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:1","tags":null,"title":"编程-数据结构","uri":"/post/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"应用 广度搜索算法和深度搜索算法 深度优先遍历简称DFS（Depth First Search），广度优先遍历简称BFS（Breadth First Search），它们是遍历图当中所有顶点的两种方式。 先深入探索，走到头再回退寻找其他出路的遍历方式，就叫做深度优先遍历（DFS）。 一层一层由内而外的遍历方式，就叫做广度优先遍历（BFS）。 实现 实现深度优先遍历的关键在于回溯；实现广度优先遍历的关键在于重放。 要想实现回溯，可以利用栈的先入后出特性，也可以采用递归的方式（因为递归本身就是基于方法调用栈来实现）。 回溯与重放是完全相反的过程。 把遍历过的顶点按照之前的遍历顺序重新回顾，就叫做重放。同样的，要实现重放也需要额外的存储空间，可以利用队列的先入先出特性来实现。 可以用一个布尔类型的数组来存储所有顶点的遍历状态。 迪杰斯拉特算法 最小生成树 ","date":"2019-03-25","objectID":"/post/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:2","tags":null,"title":"编程-数据结构","uri":"/post/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["后端"],"content":"构建API服务","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"标准 OpenAPI规范 JSON Schema ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:1:0","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"设计原则 1. API版本放进URL中。 2. API执行前都需要进行认证和权限的判定（中间件）。`权限的判定，通过token获取userId，根据userId去判断请求的数据有无权限` 3. 对外网API中数据全为UUID不能使用数据库ID。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:2:0","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"安全 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:0","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"HTTPS ♥♥ 对于敏感的接口，需要使用https协议。 申请Let’s Encrypt永久免费SSL证书。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:1","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"Token（APP_KEY） ♥♥♥ 在用户成功登录时，系统可以返回客户端一个Token，并以Token-userID以键值对的形式存放进缓存服务器； 后续客户端调用服务端的接口，都需要带上Token，而服务端需要校验客户端Token的合法性。Token不一致的情况下，服务端需要拦截该请求。 参考心知天气第一种安全验证方式会在请求地址中泄露私钥。 APP_ID（公钥）。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:2","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"签名机制 ♥♥♥ 使用不对称加密（MD5或SHA-1）对请求参数进行加密，生成签名。保证请求数据不会被篡改。 服务器将签名保存到缓存服务器，并设置超时，在超时时间内收到同一签名的请求，忽略。 示例： 1. 对除签名外的所有请求参数按key做的升序排列,value无需编码。 2. 把参数名和参数值连接成字符串，得到拼装字符串。 3. 用申请到的appkey连接到接拼装字符串头部和尾部，然后进行32位MD5加密，最后将到得MD5加密摘要转化成大写。 参考心知天气第二种安全验证方式不会在请求地址泄露私钥。 参考腾讯的API规范文档。 参考阿里云的API规范。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:3","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"过载保护 对接口访问频率设置一定的阈值。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:4","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"时间戳超时机制 ♥♥♥ 用户每次请求都需要带上当前时间的时间戳，服务端比对时间戳与当前时间，如果时间差大于一定时间（比如5分钟），认为请求失效。是防御DOS攻击的有效手段。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:5","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"异常封装 构建异常统一的处理框架，将服务可能出现的异常做统一封装，返回固定的code与msg，防止程序堆栈信息暴露。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:6","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"请求和响应数据的加解密（可以使用https） ♥♥♥ 并非所有的请求和响应都需要加解密； 加密算法有对称加密和非对称加密，AES是对称加密，RSA是非对称加密。AES加密数据是因为效率高，RSA运行速度慢,可以用于签名操作。可以用RSA来加密传输AES的秘钥，用AES来加密数据，两者相互结合，优势互补。 HTTPS比HTTP慢的原因都是因为需要让客户端与服务器端安全地协商出一个对称加密算法。剩下的就是通信时双方使用这个对称加密算法进行加密解密。 1. 客户端启动，发送请求到服务端，服务端用RSA算法生成一对公钥和私钥，我们简称为pubkey1,prikey1，将公钥pubkey1返回给客户端。 2. 客户端拿到服务端返回的公钥pubkey1后，自己用RSA算法生成一对公钥和私钥，我们简称为pubkey2,prikey2，并将公钥pubkey2通过公钥pubkey1加密，加密之后传输给服务端。 3. 此时服务端收到客户端传输的密文，用私钥prikey1进行解密，因为数据是用公钥pubkey1加密的，通过解密就可以得到客户端生成的公钥pubkey2 4. 然后自己在生成对称加密，也就是我们的AES,其实也就是相对于我们配置中的那个16的长度的加密key,生成了这个key之后我们就用公钥pubkey2进行加密，返回给客户端，因为只有客户端有pubkey2对应的私钥prikey2，只有客户端才能解密，客户端得到数据之后，用prikey2进行解密操作，得到AES的加密key,最后就用加密key进行数据传输的加密，至此整个流程结束。 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:3:7","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"GraphQL ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:4:0","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"优势 GraphQL 最大的优势是查询图状数据。 前提是数据已经以图的数据结构进行保存。 可以理解为基于RESTful的一种封装，一种新的api标准。 所见即所得，相对RESTful API依赖于后端隐式的被动的数据约定，GraphQL更加显式，在获取数据和更新数据时更加主动。 减少网络请求的使用，GraphQL可以实现对多个数据源的调用，合并成一份完整的数据给前端使用。 参数类型强校验，GraphQL提供了强类型的schema机制，从而确保了参数类型的合法性。 ———————————————— 版权声明：本文为CSDN博主「小生叫不才」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/onsenOnly/java/article/details/102639327 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:4:1","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"原则 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:4:2","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"服务端和客户端必须同时支持 ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:4:3","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["后端"],"content":"框架 FastAPI ","date":"2019-03-25","objectID":"/post/%E5%90%8E%E7%AB%AF-api/:5:0","tags":["后端","API"],"title":"后端-构建API服务","uri":"/post/%E5%90%8E%E7%AB%AF-api/"},{"categories":["PROGRAM"],"content":"概述 缺点不具备多处理器，处理较大的数据集速度很慢。 ","date":"2019-03-15","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/:1:0","tags":["PROGRAM","PYTHON"],"title":"pandas","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/"},{"categories":["PROGRAM"],"content":"1. def 方法 ","date":"2019-03-15","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/:2:0","tags":["PROGRAM","PYTHON"],"title":"pandas","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/"},{"categories":["PROGRAM"],"content":"2. class 类 最重要的两个数据结构为Series和DataFrames。 对齐数据和缺失数据（dropna()和fillna()）,层次化索引。 ","date":"2019-03-15","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/:3:0","tags":["PROGRAM","PYTHON"],"title":"pandas","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/"},{"categories":["PROGRAM"],"content":"2.1. Series 类 对numpy进行了封装。 索引可以重复。 ## 定义 obj = Series([1,2,3,4,5],index=[\"a\",\"b\",\"c\",\"d\",\"e\"]) \"a\" in obj # 判断索引 obj['a'] # 访问index obj1 = Series(字典) obj1.index = # 更改index obj1.reindex([1，2，3，4],fill_value=0) # 重新定义index，空值填充0 obj1.reindex([1，2，3，4],method='ffill') # 重新定义index，利用上边的值填充，'bfill'利用后边的值填充 obj1.dropna() # 删除缺失值 ## 层次化索引，index是一个数组 ","date":"2019-03-15","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/:3:1","tags":["PROGRAM","PYTHON"],"title":"pandas","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/"},{"categories":["PROGRAM"],"content":"2.2. DataFrames 类 一般说来dataframe就是a set of columns, each column is an array of values. In pandas, the array is one way or another a (maybe variant of) numpy ndarray. 而ndarray本身不存在一种in place append的操作。因为它实际上是一段连续内存。任何需要改变ndarray长度的操作都涉及分配一段长度合适的新的内存，然后copy。【这是这类操作慢的原因】。 如果pandas dataframe没有用其他设计减少copy的话，我相信Bren说的\"That’s probably as efficient as any\"是很对的。所以in general, 正如Bren说的。Pandas/numpy structures are fundamentally not suited for efficiently growing.Matti 和arynaq说的是两种常见的对付这个问题的方法。我想Matti实际的意思是把要加的rows收集成起来然后concatenate, 这样只copy一次。arynaq的方法就是预先分配内存比较好理解。如果你真的需要incrementally build a dataframe的话，估计你需要实际测试一下两种方法。==我的建议是，如有可能，尽力避免incrementally build a dataframe, 比如用其他data structure 收集齐所有data然后转变成dataframe做分析==。 df = pd.DataFrame(一个字典)如果使用所有标量值（key和value也是标量）,value是一个值的列表，必须设置一个索引（index=字典.keys()）. 可以使用[]和.访问一列的值。 2.2.1. 实例属性 df.dtypes \"每一列的类型\" df.index \"\" df.columns \"列名\" columns.tolist() df.values \"\" df.T \"转置\" 2.2.2. 实例方法 根据一列通过算法生成另一列 # 使用apply函数, 如果city字段包含'ing'关键词，则'判断'这一列赋值为1,否则为0 如： frame['panduan'] = frame.city.apply(lambda x: 1 if 'ing' in x else 0) frame['cap'] = frame.city == \"北京\" DataFrame的排名 rank(axis=0, method='average', numeric_only=None, na_option='keep', ascending=True, pct=False) 参数 取值 功能 axis {0 or ‘index’, 1 or ‘columns’}, default 0 index to direct ranking method {‘average’, ‘min’, ‘max’, ‘first’, ‘dense’} average:相同的值给一个平均排名，min: 对于相同的值都取小的排名，max: 对于相同的值都取大的排名，first:对于相同的值按照出现的顺序排名，dense: like ‘min’, but rank always increases by 1 between groups numeric_only boolean:default None Include only float, int, boolean data. Valid only for DataFrame or Panel objects na_option {‘keep’, ‘top’, ‘bottom’} keep: leave NA values where they are,top: smallest rank if ascending,bottom: smallest rank if descending ascending boolean, default True False从高(1)到低(N)排序 pct boolean, default False Computes percentage rank of data DataFrame索引 DataFrame.set_index(keys, drop=True, append=False, inplace=False, verify_integrity=False) DataFrame将一列导出数组 df['column'].tolist() pd.date_range('20130101', periods=6) pd.to_datetime(datetime对象) #转化为日期类型 3. dataframe ## 定义 df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD')) df2 = pd.DataFrame({'A' : 1., 'B' : pd.Timestamp('20130102'), 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), 'D' : np.array([3] * 4,dtype='int32'), 'E' : pd.Categorical([\"test\",\"train\",\"test\",\"train\"]), 'F' : 'foo' }) ## 实例属性 ## 实例方法 df.head() #前5行 df.tail() \"\" df.describe() \"显示快速统计\" df.iteritems() df.iterrows() df.itertuples() df.count() \"计数\" df[\"列名\"].sum() df.astype(str) \"将dataframe所有内容变成字符串\" df[].str.contains() \"字符串是否包含\" \"排序\" df.sort_index(axis=1, ascending=False) \"按照索引排序\" df.sort_values(by='B') \"按照列值排序\" \"筛选\" df.loc[dates[0]] df.loc[:,['A','B']] df.loc['20130102':'20130104',['A','B']] df.loc['20130102',['A','B']] df.loc[dates[0],'A'] df.at[dates[0],'A'] \"比上一条命令效率更高\" df.iloc[3] df.iloc[3:5,0:2] df.iloc[[1,2,4],[0,2]] df.iloc[1:3,:] df.iloc[:,1:3] df.iloc[1,1] df.iat[1,1] \"比上一条命令效率更高\" df[df.A \u003e 0] \"Bool 筛选A列数据中大于0的行\" df[df \u003e 0] \"Bool\" df[(df.C\u003e0)\u0026(df.D\u003c0)] \"使用\u0026符号可以实现多条件筛选，当然是用\"|\"符号也可以实现多条件，只不过他是或的关系\" df[['A','B']][(df.C\u003e0)\u0026(df.D\u003c0)] \"假如我们只需要A和B列数据，而D和C列数据都是用于筛选的\" df['A'] df[0:3] df['20130102':'20130104'] df2 = df.copy() df2['E'] = ['one', 'one','two','three','four','three'] df2[df2['E'].isin(['two','four'])] \"筛选特定的值\" \"没有isnotin函数，取反的方法就是在函数前面加个 ~ ，好销魂的一飘\" ~df.isin(other) \"去重\" data.drop_duplicates(inplace=True) data.drop_duplicates(subset='column1')#找第一列重复者 data.duplicated(keep='last')#'first','last',False \"删除木一列\" DF= DF.drop('column_name', 1)； DF.drop('column_name',axis=1, inplace=True) DF.drop([DF.columns[[0,1, 3]]], axis=1,inplace=True) # Note: zero indexed \"修改\" '.loc[row_indexer筛选条件,col_indexer赋值列名] = value' df2.loc[df2.C\u003e0, \"D\"] = 6 s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6)) df['F'] = s1 df.at[dates[0],'A'] = 0 df.iat[0,1] = 0 df.loc[:,'D'] = np.array([5] * len(df)) df2 = df.copy() df2[df2 \u003e 0] = -df2 \"Grouping\" df.groupby(['A','B']).size().unstack().fillna(0) \"分类统计","date":"2019-03-15","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/:3:2","tags":["PROGRAM","PYTHON"],"title":"pandas","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/"},{"categories":["PROGRAM"],"content":"CufflinksThis library binds the power of plotly with the flexibility of pandas for easy plotting ","date":"2019-03-15","objectID":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/:4:0","tags":["PROGRAM","PYTHON"],"title":"pandas","uri":"/post/program-python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-pandas/"},{"categories":null,"content":"http HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了。 HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。长连接是指的TCP连接，而不是HTTP连接。 TCP连接才有真正的长连接（目的是重复使用，多个Http请求复用同一个TCP连接）和短连接这一说。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:1:0","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"消息结构 客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 HTTP头部信息解释分析(详细整理) ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:1:1","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"头部信息 应答头 请求说明 应答说明 Allow 服务器支持哪些请求方法（如GET、POST等）。 Connection close（告诉WEB服务器或者代理服务器，在完成本次请求的响应 后，断开连接，不要等待本次连接的后续请求了）keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求） close（连接已经关闭）keepalive（连接保持着，在等待本次连接的后续请求）。 Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。 例如：Keep-Alive：300 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path”)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh” CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面”，而不是\"每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼“executives＼\"\")。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:1:2","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"Server-Sent Events(简称SSE) SSE是一种能让浏览器通过HTTP连接自动收到服务器端更新的技术，SSE EventSource 接口被W3C制定为HTML5的一部分。 单向。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:2:0","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"websocket 双向。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:3:0","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"HTTP状态码 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:4:0","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"术语 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:5:0","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"轮询 客户端起一个定时器，定时发起请求向服务端请求数据。 服务端接到请求之后马上返回响应信息并关闭连接。 优点：后端简单。 缺点：浪费带宽和服务器资源。 场景：不适合客户端数量太多的情况。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:5:1","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"长轮询 客户端发起请求，请求返回结束后，立即发起第二次请求。 服务端接到请求后hold住连接，直到有新消息才返回响应信息或等超时返回，关闭连接。 优点：在无消息的情况下不会频繁地请求，耗费资源小。 缺点：服务器hold住连接会消耗资源，返回数据顺序无保证，难于管理维护。 场景：WebQQ网页扫码登录。不适合客户端数量太多的情况。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:5:2","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"长连接 客户端与服务端建立长连接，此连接不会断开，服务端随时可向客户端推送消息。（websocket, SSE） 优点：消息即时到达，不发无用请求；管理起来也相对方便。 缺点：服务器维护一个长连接会增加开销。 ","date":"2019-03-14","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/:5:3","tags":null,"title":"微服务架构笔记-网络协议","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-05-http%E5%8D%8F%E8%AE%AE/"},{"categories":["后端"],"content":"Flask开发","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"配置的最佳实践 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:0","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"变量的配置 通过调用自定义config.py文件中config字典，可以得到一个类，这个类里面定义的都是类变量，这些变量就是自定义的一些配置项。 敏感信息通过读取环境变量获得。 环境变量可以在Docker部署的时候确定，即docker-compose.yml，此文件不要放入到版本控制中。 import os BASEDIR = os.path.abspath(os.path.dirname(__file__)) class Config: \"\"\"base config\"\"\" SECRET_KEY = os.environ.get('SECRET_KEY') or 'secret key' SQLALCHEMY_COMMIT_ON_TEARDOWN = True SQLALCHEMY_TRACK_MODIFICATIONS = True class ProductionConfig(Config): \"\"\"运行环境配置\"\"\" SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \\ 'sqlite:///' + os.path.join(BASEDIR, 'data.sqlite') ...... config = { 'development': DevelopmentConfig, 'testing': ProductionConfig, 'production': ProductionConfig, 'default': DevelopmentConfig } app = Flask(__name__) app.config.from_object(config['testing']) 具体的变量 app.config['JSON_AS_ASCII'] = False # 让jsonify返回的json串支持中文显 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:1","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"日志的配置 log配置，实现日志自动按日期生成日志文件 def make_dir(make_dir_path): path = make_dir_path.strip() if not os.path.exists(path): os.makedirs(path) return path log_dir_name = \"flask_logs\" log_file_name = ('logger-' + time.strftime('%Y-%m-%d', time.localtime(time.time())) + '.log') log_file_folder = '/var/log' + os.sep + log_dir_name make_dir(log_file_folder) log_file_str = log_file_folder + os.sep + log_file_name log_level = logging.WARNING handler = logging.FileHandler(log_file_str, encoding='UTF-8') handler.setLevel(log_level) logging_format = logging.Formatter('%(asctime)s - %(levelname)s - %(filename)s \\ - %(funcName)s - %(lineno)s - %(message)s') handler.setFormatter(logging_format) app = Flask(__name__) app.logger.addHandler(handler) 需要一个定时任务，定时清掉日志。 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:2","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"应用工厂 App Factory Flask官方建议采用工厂的模式来创建应用 from flask import Flask from flask_mail import Mail from flask_sqlalchemy import SQLAlchemy from werkzeug.utils import import_string mail = Mail() db = SQLAlchemy() blueprints = [ 'myapp.main:main', 'myapp.admin:admin', ] def create_app(config): app = Flask(__name__) app.config.from_object(config) # Load extensions mail.init_app(app) db.init_app(app) # Load blueprints for bp_name in blueprints: bp = import_string(bp_name) app.register_blueprint(bp) return app app = create_app('config') app.run(host='0.0.0.0', debug=True) 我们不在代码中直接创建应用，而是通过调用”create_app()”方法来返回一个应用对象，这个”create_app()”就是应用工厂方法。在工厂方法里，我们分别加载了配置，扩展和蓝图。 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:3","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"使用消息队列 可参考timlardner/Docker-FlaskCeleryRabbitRedis; 参考Web开发之旅–Flask使用Celery执行异步任务 问题一Airflow: TypeError can’t pickle memoryview objects http://www.pythondoc.com/flask-celery/index.html celery 使用task嵌套时, 子task调用间隔不能太小，尤其在子task间结果相互依赖，特别是都操作数据库。 celery容器和APP容器分开运行，参考。 celery ----status --------AsyncResult 方法，获取任务ID的状态 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:4","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"使用cookiecutter myflaskapp |---autoapp.py（调用create_app） |---myflaskapp |---app.py(创建create_app) |---database.py(数据库) |---extensions.py(flask扩展集合) |---settings.py(配置) |---models.py（自己觉得可以把公用的orm放在这） |---public（其他业务） |---forms.py |---models.py |---views.py |---api.py(创建新的blueprint) |---user（用户管理） |---forms.py |---models.py（ORM） |---views.py(blueprint) |---api.py（创建新的blueprint） |---templates |---public(专有的页面) |---user（专有的页面） ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:5","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"使用docker ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:1:6","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"功能实现 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:2:0","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"认证 ==（注：站点认证使用flask-login，API认证使用flask-httpauth）== 在 ==Flask-Login== 中，如果你不特殊处理的话，session 是在你关闭浏览器之后就失效的。 \"自己控制 session 的过期时间\" session.permanent = True \"首先需要设置 login_manager 的 session类型为永久的\" app.permanent_session_lifetime = timedelta(minutes=5) \"然后再设置 session 的过期时间\" \"同时，还需要注意的是 cookie 的默认有效期其实是 一年 的，所以，我们最好也设置一下\" login_manager.remember_cookie_duration=timedelta(days=1) ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:2:1","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"Flask：Flask-Script扩展与Click ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:2:2","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"插件 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:3:0","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":["后端"],"content":"用户相关（登录、权限、角色） Flask-Principal 基于Flask-Principal的权限控制 [Flask-login] [Flask-httpauth] Flask-caching Flask-cache（已停止更新）的fork版。缓存支持。 参考flask插件系列之flask_caching缓存 常用参数配置 CACHE_TYPE:设置缓存的类型 # 下面五个参数是所有的类型共有的 CACHE_NO_NULL_WARNING = \"warning\" # null类型时的警告消息 CACHE_ARGS = [] # 在缓存类实例化过程中解包和传递的可选列表，用来配置相关后端的额外的参数 CACHE_OPTIONS = {} # 可选字典,在缓存类实例化期间传递，也是用来配置相关后端的额外的键值对参数 CACHE_DEFAULT_TIMEOUT # 默认过期/超时时间，单位为秒 CACHE_THRESHOLD # 缓存的最大条目数 CACHE_TYPE = null # 默认的缓存类型，无缓存 CACHE_TYPE = 'simple' # 使用本地python字典进行存储，线程非安全 CACHE_TYPE = 'filesystem' # 使用文件系统来存储缓存的值 CACHE_DIR = \"\" # 文件目录 CACHE_TYPE = 'memcached' # 使用memcached服务器缓存 CACHE_KEY_PREFIX # 设置cache_key的前缀 CAHCE_MEMCACHED_SERVERS # 服务器地址的列表或元组 CACHE_MEMCACHED_USERNAME # 用户名 CACHE_MEMCACHED_PASSWORD # 密码 CACHE_TYPE = 'uwsgi' # 使用uwsgi服务器作为缓存 CACHE_UWSGI_NAME # 要连接的uwsgi缓存实例的名称 CACHE_TYPE = 'redis' # 使用redis作为缓存 CACHE_KEY_PREFIX # 设置cache_key的前缀 CACHE_REDIS_HOST # redis地址 CACHE_REDIS_PORT # redis端口 CACHE_REDIS_PASSWORD # redis密码 CACHE_REDIS_DB # 使用哪个数据库 # 也可以一键配置 CACHE_REDIS_URL 连接到Redis服务器的URL。示例redis://user:password@localhost:6379/2 ","date":"2019-03-11","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/:3:1","tags":["后端","FLASK","PYTHON"],"title":"后端-web框架-Flask","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-flask/"},{"categories":null,"content":"数据库的设计注意事项及主流ORM框架的使用","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"数据库设计 数据库中的字段要区分永久性还是递变性，永久性存为一张表，递变性的字段单独为一张表，但是会随时间变化。 永久性的字段衍伸的字段，可以用时重新计算；但是递变性的字段衍伸的字段，需要当时计算好之后存进数据库中。 根据UML中定义的对象进行Model的设计，一个对象可对应多个Model。 ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:1:0","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"SQLAlchemy SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:2:0","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"配置项 ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:2:1","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"Session状态管理 语句 功能 db.session.expire(product) 清除对象里缓存的数据 db.session.refresh(product) 不仅清除对象里缓存的数据，还会立刻触发一次数据库查询更新数据 db.session.expire_all() 清除session里所有对象的缓存 db.session.flush() 所有本地修改写入到数据库，但没有提交 db.session.commit() 不仅把所有本地修改写入到数据库，同时也提交了该事务 db.session.delete() 删除一条记录，参数只能是一条记录 ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:2:2","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"SQL Statements and Expressions APISQl语句和表达式API ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:2:3","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"错误 ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:2:4","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"flask-sqlalchemy 尽量使用sqlalchemy，而不用flask-sqlalchemy. db = SQLAlchemy(app.app, session_options={'autocommit': True}) flask-sqlalchemy配置 SQLALCHEMY_POOL_RECYCLE 自动回收连接的秒数。这对 MySQL 是必须的，默认 情况下 MySQL 会自动移除闲置 8 小时或者以上的连接。 需要注意地是如果使用 MySQL 的话， Flask-SQLAlchemy 会自动地设置这个值为 2 小时。 @app.teardown_appcontext def shutdown_session(exception=None): db.session.remove() run example InvalidRequestError: No transaction is begun. #47 Invalid transaction persisting across requests Error 2006: MySQL server has gone away flask_sqlalchemy中db.session是如何保持请求间独立的–源码阅读笔记 “Mysql has gone away\"的几种可能 SQLAlchemy中的create engine默认会用到MySQLdb模块.但是此模块只支持python2.7.所以需要改变与mysql的连接模块(例如pymysql). engine = create_engine(\"mysql+pymysql://root:xxxx@192.168.1.249:9306/TestDataBank\") Flask 将数据库表转换为sqlalchemy models flask sqlalchemy 如何在models定义两个不同数据库，表名相同（tablename）的class 使用 对象 sqlalchemy.create_engine # 创建一个数据库引 sqlalchemy.Column # 纵队 sqlalchemy.Table # 表格 Table.columns # 等同于 .c Table.insert() # 获得一个插入句柄 insert().execute(name='rsj217', email='rsj21@gmail.com') # 插入一条数据 insert().execute({字典},{字典}) # 插入多条数据 sqlalchemy.Index sqlalchemy.text sqlalchemy.PassiveDefault # 定义某一列的默认操作 sqlalchemy.Numeric sqlalchemy.Integer # 整数 sqlalchemy.String # 字符串 sqlalchemy.text sqlalchemy.DateTime sqlalchemy.MetaData # 元数据,容器类对象 sqlalchemy.exc.OperationalError sqlalchemy.schema.CreateTable sqlalchemy.select sqlalchemy.dialects dialects.mysql mysql.FLOAT # mysql的float类型 precision设置有效数字膈腧scale设置小数点后数字个数 mysql.DOUBLE mysql.REAL # 可以保留原数据的精度 mysql.TIMESTAMP # 时间戳 常用的SQLAlchemy查询过滤器（query.） 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit 使用指定的值限定原查询返回的结果 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定条件对原查询结果进行分组，返回一个新查询 User.query.filter(User.name.endswith('g')).all() User.query.filter(User.name!='wang').all() User.query.filter(and_(User.name!='wang',User.email.endswith('163.com'))).all() User.query.filter(or_(User.name!='wang',User.email.endswith('163.com'))).all() User.query.filter(not_(User.name=='chen')).all() User.query.filter_by(name='zhang').update({'name':'li'}) # 查询名字结尾字符为g的所有用户[开始 / 包含] User.query.filter(User.name.endswith(\"g\")).all() User.query.filter(User.name.startswith(\"w\")).all() User.query.filter(User.name.contains(\"n\")).all() User.query.filter(User.name.like(\"%n%g\")).all() 模糊查询 # 查询名字和邮箱都以li开头的所有用户[2种方式] User.query.filter(User.name.startswith(\"li\"), User.email.startswith(\"li\")).all() from sqlalchemy import and_ User.query.filter(and_(User.name.startswith(\"li\"), User.email.startswith(\"li\"))).all() # 查询age是25 或者 `email`以`itheima.com`结尾的所有用户 from sqlalchemy import or_ User.query.filter(or_(User.age == 25, User.email.endswith(\"itheima.com\"))).all() # 查询名字不等于wang的所有用户[2种方式] from sqlalchemy import not_ User.query.filter(not_(User.name == \"wang\")).all() User.query.filter(User.name != \"wang\").all() # 查询id为[1, 3, 5, 7, 9]的用户 User.query.filter(User.id.in_([1, 3, 5, 7, 9])).all() # 所有用户先按年龄从小到大, 再按id从大到小排序, 取前5个 User.query.order_by(User.age, User.id.desc()).limit(5).all() 常用的SQLAlchemy查询执行器 方法 说明 all() 以列表形式返回查询的所有结果 first() 返回查询的第一个结果，如果未查到，返回None first_or_404() 返回查询的第一个结果，如果未查到，返回404 get() 返回指定主键对应的行，如不存在，返回None get_or_404() 返回指定主键对应的行，如不存在，返回404 count() 返回查询结果的数量 paginate() 返回一个Paginate对象，它包含指定范围内的结果 \"数据库分页\" [employees] = [Employee].query.paginate([page],per_page=[10]) \"paginate是分页的方法，第一个参数是页码，第二个是每页显示多少条\" \"属性\" [employees].items \"得到的结果不是一列表,需要在传到前台的值加一个 .items\" [employees].pages \"总的页数\" [employees].page \"当前页\" paginate.prev_num \"上一页页码\" paginate.next_num \"下一页页码\" paginate.has_prev \"有无上一页 True/False\" paginate.has_next \"有无下一页 True/False\" paginate.pages \"查询总页数\" paginate.total \"记录总数\" paginate.per_page \"每页记录数量\" \"方法\" .prev() 上一页的分页对象Pagination .next() 下一页的分页对象Pagination paginate.iter_pages()\"方法 分页导航列表\" \"用来获得针对当前页的应显示的分页页码列表\" \"假设当前共有100页，当前页为50页，按照默认的参数设置调用iter_pages获得的列表为\" \"[1,2,None,48,49,50,51,52,53,54,55,None,99,100]\" # paginate,对象，包含当前页的数据，paginate.items可被for循环遍历,每个遍历值为一个模型对象 [pag] = [News].query.filter().order_by(News.create_time.des","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:2:5","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"Django ORM（Models） ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:3:0","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"1. Manager ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:3:1","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"2. QuerySet Manager类的一些方法会返回QuerySet实例，QuerySet是一个可遍历结构，包含一个或多个元素==每个元素都是一个Model 实例(get =获得一个实例)==，它里面的方法也是表级方法. . QuerySet类似于Python中的list，list的一些方法QuerySet也有，比如切片，遍历。 QuerySet是延迟获取的，只有当用到这个QuerySet时，才会查询数据库求值。另外，查询到的QuerySet又是缓存的，当再次使用同一个QuerySet时，并不会再查询数据库，而是直接从缓存获取（不过，有一些特殊情况）。一般而言，当对一个没有求值的QuerySet进行的运算，返回的是QuerySet、ValuesQuerySet、ValuesListQuerySet、Model实例时，一般不会立即查询数据库；反之，当返回的不是这些类型时，会查询数据库。 ==from django.forms.models import model_to_dict 转换成字典对象== 下面介绍几种（并非全部）对QuerySet求值的场景。 ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:3:2","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"Field Options（Feild选项） 所有的参数对所有的field都有用，而且都是可选的。 null 若为True，则可以存储空值NULL。默认为False blank 若为True,则可以为空。默认为False default 默认值。可以是一个值也可以是一个方法。不能是可变对象。 ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:3:3","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"Field类型 Field类型 参数 功能 AutoField “如果没有指明主键，就会产生一个自增的主键” BigIntegerField “64位的整型数值，从 -2^63 (-9223372036854775808) 到 2^63-1(9223372036854775807)” BinaryField “存储原始二进制数据，仅支持字节分配。功能有限” BooleanField “布尔型和NullBooleanField有区别，true/false，本类型不允许出现null” CharField “字符串，一般都在创建时写入max_length参数\"“注意：使用django rest framework此字段必须要指定max_length参数” DateField auto_now表示每次修改时改变时间auto_now_add表示创建时表示时间 时间，对应Python的datetime.date，一般来说数据库重要的表都要有这样的字段记录创建字段时间个最后一次改变的时间。关于时间的话，建议timestamp，当然 python的话还是DateTime吧” DateTimeField 同上 对应Python的datetime.datetime DecimalField “固定精度的十进制数，一般用来存金额相关的数据。对应python的Decimal，额外的参数包括DecimalField.max_digits和DecimalField.decimal_places，这个还是要参照一下mysql的Decimal类型.例如：price = models.DecimalField(max_digits=8,decimal_places=2)” EmailField 字符串，会检查是否是合法的email地址 FileField class FileField([upload_to=None, max_length=100, **options])存文件的，参数upload_to在1.7之前的一些老版本中必选的 FloatField 浮点数，必填参数：max_digits，数字长度；decimal_places，有效位数。 ImageField class ImageField([upload_to=None, height_field=None, width_field=None, max_length=100, **options])图片文件类型，继承了FileField的所有属性和方法。参数除upload_to外，还有height_field，width_field等属性。 IntegerField [-2147483648,2147483647 ]的取值范围对Django所支持的数据库都是安全的。 IPAddressField 点分十进制表示的IP地址，如10.0.0.1 GenericIPAddressField ip v4和ip v6地址表示，ipv6遵循RFC 4291section 2.2, NullBooleanField 可以包含空值的布尔类型，相当于设置了null=True的BooleanField。 PositiveIntegerField 正整数或0类型，取值范围为[0 ,2147483647] PositiveSmallIntegerField 正短整数或0类型，类似于PositiveIntegerField，取值范围依赖于数据库特性，[0 ,32767]的取值范围对Django所支持的数据库都是安全的。 SlugField 只能包含字母，数字，下划线和连字符的字符串，通常被用于URLs表示。可选参数max_length=50，prepopulate_from用于指示在admin表单中的可选值。db_index，默认为True。 SmallIntegerField 小整数字段，类似于IntegerField，取值范围依赖于数据库特性，[-32768 ,32767]的取值范围对Django所支持的数据库都是安全的。 TextField “文本类型” TimeField 时间，对应Python的datetime.time URLField 存储URL的字符串，默认长度200；verify_exists(True)，检查URL可用性。 FilePathField class FilePathField(path=None[, match=None, recursive=False, max_length=100, **options])类似于CharField，但是取值被限制为指定路径内的文件名，path参数是必选的。 \"常见参数\" null \"如果设置为 True , Django 存放一个 NULL 到数据库字段。默认为 False。\" blank \"如果设置为 True , 此 field 允许为 blank （空白），默认为 False。\" choices \"一个2元元组的元组或者列表，如果执行 choices ， Django 的 admin 就会使用 选择框而不是标准的 text 框填写这个 field\" YEAR_IN_SCHOOL_CHOICES = ((u'FR', u'Freshman'),(u'SO', u'Sophomore'),(u'JR', u'Junior'),(u'SR', u'Senior'),(u'GR', u'Graduate'),) \"2元元组的第一个元素是要存入 database 的数据，第二个元素是 admin 的界面 显示的数据。\" 使用了 choices 参数的 field 在其 model 示例里，可以用 \"get_field的名 字_display\" 方法 显示 choices 的显示字串（就是2元元组的第二个数据）。示 例： from django.db import models class Person(models.Model): GENDER_CHOICES = ( (u'M', u'Male'), (u'F', u'Female'), ) name = models.CharField(max_length=60) gender = models.CharField(max_length=2, choices=GENDER_CHOICES) \u003e\u003e\u003e p = Person(name=\"Fred Flinstone\", gender=\"M\") \u003e\u003e\u003e p.save() \u003e\u003e\u003e p.gender u'M' \u003e\u003e\u003e p.get_gender_display() u'Male' default \"field 的默认值，可以使用可调用对象（a callable object），如果使用可调用 对象，那么每次创建此 model 的新对象时调用可调用对象。常见如 datatime \" help_text \"help_text 的值可以在 admin form 里显示，不过即使不使用 admin ，也可以当 做描述文档使用\" primary_key 如果为 True ， 这个 field 就是此 model 的 primary key 。 unique 如果为 True， 此 field 在这个 table 里必须唯一。 verbose_name verbose，详细的意思。verbose_name，就可以理解为详细的名字吧。 除了ForeignKey, ManyToManyField 和 OneToOneField之外，每个类型的字段都有一个可选的第一位置参数－详细的名字。如果没有给出详细的名称，Django将自动使用字段的属性名来代替他。替代过程中会转换下划线为空格。 该字段中，名字的详情为”person’s first name”： first_name = models.CharField(\"person's first name\", max_length=30) 以下字段中，first_name的详细名字为\"first name\": first_name = models.CharField(max_length=30) ForeignKey, ManyToManyField 和 OneToOneField要求第一个参数是模型的类，所以需要使用verbose_name关键字参数，如： poll = models.ForeignKey(Poll, verbose_name=\"the related poll\") sites = models.ManyToManyField(Site, verbose_name=\"list of sites\") place = models.OneToOneField(Place, verbose_name=\"related place\") 在需要的时候Django会自动大写 verbose_name的首字母。 原来verbose_name字段就是为ForeignKey, ManyToManyField 和 OneToOneField这三种关系准备的啊！ ","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:3:4","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":null,"content":"4. 常用操作: \"\"\" 1. values my_string = \"id\", \"name\" my_model.objects.values(*my_string) \"\"\" \"__gt 大于 __gte 大于等于\" User.objects.filter(age__gt=10) // 查询年龄大于10岁的用户 User.objects.filter(age__gte=10) // 查询年龄大于等于10岁的用户 \"__lt 小于 __lte 小于等于\" User.objects.filter(age__lt=10) // 查询年龄小于10岁的用户 User.objects.filter(age__lte=10) // 查询年龄小于等于10岁的用户 \"__in\" 查询年龄在某一范围的用户 User.objects.filter(age__in=[10, 20, 30]) \"like\" __exact 精确等于 like 'aaa' __iexact 精确等于 忽略大小写 ilike 'aaa' __contains 包含 like '%aaa%' __icontains 包含 忽略大小写 ilike '%aaa%'，但是对于sqlite来说，contains的作用效果等同于icontains。 \"__isnull 判空\" User.objects.filter(username__isnull=True) // 查询用户名为空的用户 User.objects.filter(username__isnull=False) // 查询用户名不为空的用户 \"不等于/不包含于\" User.objects.filter().excute(age=10) // 查询年龄不为10的用户 User.objects.filter().excute(age__in=[10, 20]) // 查询年龄不为在 [10, 20] 的用户 \"range\" Tb1.objects.filter(id__range=[1, 2]) # 范围bettwen and \"startswith，istartswith, endswith, iendswith\" \"order by\" Tb1.objects.filter(name='seven').order_by('id') # asc Tb1.objects.filter(name='seven').order_by('-id') # desc \"group by\" from django.db.models import Count, Min, Max, Sum models.Tb1.objects.filter(c1=1).values('id').annotate(c=Count('num')) 如同:SELECT \"app01_tb1\".\"id\", COUNT(\"app01_tb1\".\"num\") AS \"c\" FROM \"app01_tb1\" WHERE \"app01_tb1\".\"c1\" = 1 GROUP BY \"app01_tb1\".\"id\" ==django do not support group_concat== 3functions: raw sql. django-mysql Creating your own Aggregate Functions \"limit 、offset\" models.Tb1.objects.all()[10:20] #### 2.12 regex正则匹配，iregex 不区分大小写 Entry.objects.get(title__regex=r'^(An?|The) +') Entry.objects.get(title__iregex=r'^(an?|the) +') #### 2.13 date Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1)) Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1)) #### 2.14 year month day 类似 Entry.objects.filter(pub_date__year=2005) Entry.objects.filter(pub_date__year__gte=2005) #### 2.15 week_day Entry.objects.filter(pub_date__week_day=2) Entry.objects.filter(pub_date__week_day__gte=2) #### 2.16 hour minute second类似 Event.objects.filter(timestamp__hour=23) Event.objects.filter(time__hour=5) Event.objects.filter(timestamp__hour__gte=12) #### 2.17 filter是包含,exclude是不包含 #### 2.18 orm的F功能 就是用来更新获取原来值的功能 假设数据库有一个员工表，表中的年龄都自加“1”，这里就需要到orm的F功能，如下面的代码： from django.db.models import F#首先要导入这个F模块 models.Uinfo.objects.all().update(age=F(\"age\")+1)#这里的F功能后面的age，它就会让数据表表中的age这列+1 #### 2.19 orm的Q功能 Q能把查询相互嵌套 Q用于构造复杂的查询条件的，使用方法有对象方法和直接创建创建对象方法 数据库的查询条件我们可以使用filter，在filter里面的可以是两个条件他们之间是and的关系，也可以是一个字典，例如下面的代码 models.Uinfo.objects.all().filter(id=1,name=‘李伟‘) conditon={‘id‘:‘1‘,‘name‘:‘李伟‘} models.Uinfo.objects.all().filter(**conditon) 除了上面的方法，我们还可以加Q的对象，例如： from django.db.models import Q models.Uinfo.objects.all().filter(Q(id=1))#条件是id为1的时候 models.Uinfo.objects.all().filter(Q(id=1)|Q(id__gt=3))#条件是或的关系，| models.Uinfo.objects.all().filter(Q(id=1) \u0026 Q(id=4))# 条件是and的关系 Q的另外一种用法 #q1 里面的条件都是or的关系 q1=Q() q1.connector = ‘OR‘ q1.children.append((‘id‘,1)) q1.children.append((‘id‘,3)) q1.children.append((‘id‘,6)) #q2里面的条件都是or的关系 q2=Q() q2.connector = ‘OR‘ q2.children.append((‘c‘,2)) q2.children.append((‘c‘,4)) q2.children.append((‘c‘,6)) #con 通过and的条件把q1和q2 联系到一块 con=Q() con.add(q1,‘AND‘) con.add(q2,‘AND‘) #### 2.20 extra 在QuerySet的基础上继续执行子语句 extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) models.UserInfo.objects.extra( select={'newid':'select count(1) from app01_usertype where id\u003e%s'}, select_params=[1,], where = ['age\u003e%s'], params=[18,], order_by=['-age'], tables=['app01_usertype'] ) \"\"\" select app01_userinfo.id, (select count(1) from app01_usertype where id\u003e1) as newid from app01_userinfo,app01_usertype where app01_userinfo.age \u003e 18 order by app01_userinfo.age desc \"\"\" #### 2.21 执行原生SQL * 更高灵活度的方式执行原生SQL语句 ```python from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) row = cursor.fetchone() 2.22 去重 models.Book.objects.val","date":"2019-03-08","objectID":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/:3:5","tags":["后端","ORM"],"title":"后端-ORM-PYTHON","uri":"/post/%E5%90%8E%E7%AB%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-python/"},{"categories":["TOOLS"],"content":"1. 支持QT开发 下载并安装Qt Visual Studio Tools. 在VS的[扩展]中增加QT版本即选中qt安装目录下的qmake.exe。 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:1:0","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"1.1. 设置 1.1.1. Qt 1.1.1.1. General Qt Designer:Run in detached window：true。 允许在新的窗口打开。 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:1:1","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"2. 导入老项目 打开老的解决方案，会提示重定向解决方案，选择最新的生成工具。 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:2:0","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"3. 使用 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:3:0","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"3.1. 新建项目 【win32 项目】用于创建Win32应用程序、控制台应用程序、DLL或其他静态库的项目。 【生成的动态链接库并不能直接修改库文件的名称，而是需要重新编译】。 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:3:1","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"3.2. 配置项目 3.2.1. 项目配置文件*.vcxproj \u003cKeyword\u003e\u003c/Keyword\u003e # vs2013+qt5.6+addin1.2.5 Qt4VSv1.0 就转变为为qt项目 3.2.2. 用户配置文件*.vcxproj.user \u003cQTDIR\u003e\u003cQTDIR\u003e\r 3.2.3. 项目属性图形化配置 我们一般不会修改解决方案的属性，而是设置每个项目各自的属性. 一个项目有release和debug两套【独立】属性。 //1.Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。\r//2.Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。\r 路径推荐使用编译器提供给我们的宏变量，而尽量不要使用绝对的名称，这样程序更具有移植性。 如果有某些项目是作为导出链接库用的。需要把导出的dll, lib（即输出文件路径）设置到上面的Bin目录下。然后在需要使用导出的dll和lib文件的项目中设置项目依赖项这前者，并设置附加库目录和附加依赖项。这样可以很方便的使用同一解决方案中其他项目导出的链接库了。 通用属性配置属性常规输出目录（.exe的目录）中间目录（中间文件的目录）MFC的使用# [在共享DLL中使用MFC]\r字符集调试工作目录# $(OutDir)\rC/C++\r常规\r附加包含目录# 设置其他库的头文件的目录 $(ProjectDir)项目配置文件所在的目录；$(SolutionDir)解决方案配置文件所在的目录\rSDL检查代码生成启用最小重新生成# 不用每次都编译整个项目\r语言符合模式# 设置成否，就不会报const char*等错误\r预编译头预编译头# 不使用\r命令行其他选项# /utf-8 设置源文件的编码格式和执行文件的编码格式/source-charset:utf-8或者/execution-charset:utf-8 VS\r# /\r链接器常规附加库目录# 设置其他库的.lib以及.dll链接库的目录，程序运行需要将其拷贝到exe的当前目录或者将其放进PATH中\r输入附加依赖项# 设置的就是xx.lib静态链接库的名称，qt项目（debug输入xxd.lib,release输入xx.lib）\r生成事件后期生成事件# 重新生成程序之后执行的命令\r命令行# 具体的命令，可以在这里使用copy命令，来将程序需要的.dll文件自动拷贝到.exe文件所在的目录。当然，在这里你可以做更多的事情，比如如果你的程序需要读取配置文件，你也可以把配置文件拷贝过来\r ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:3:2","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"3.3. utf-8 参考VS2017修改编码格式为utf-8，再也不用担心乱码了 使用ForceUTF8（No BOM）插件。 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:3:3","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"4. 问题答疑 could not find or load the Qt platform plugin windows的解决方法. VS工程 转 Qt 工程时 Qt VS Tools 功能键是灰色的问题 解决错误：error MSB8031: Building an MFC project for a non-Unicode character set is deprecated. QSqlDatabase::drivers() 输出为空解决方案 VS+Qt链接出现错误LNK2001，因为没有生成moc文件，需要按照其他h文件修改自己头文件的属性【其他执行方法】。 【MFC】fatal error C1189: #error : Building MFC application with /MD[d] (CRT dll version) requires MF. error C2440: “static_cast” error C2491 error C2664 error C3867 error C4996: ‘strcpy’: This function or variable may be unsafe. Consider using strcpy_s instead. error C4996 ‘stricmp‘ error LNK2019: 无法解析的外部符号 _Netbios@4 Windows 下 由SQLite3.def文件生成SQLite3.LIB文件 vs2017无法打开“stdio.h”等源文件 VS2017出现无法使用stdlib.h，string.h等SDK中的头文件选择windows sdk然后重定向项目。 ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:4:0","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"5. C++ MFC不能跨平台。 使用自己的MSVC编译器，与其他编译器不兼容，甚至不同版本兼容性也不是很好。 编码问题：MSVC使用GBK编码。 1. 对于 MBCS 编码，字符变量用 char 定义。\r2. 对于 Unicode 编码中，字符变量用 wchar_t 定义。\r3. 在程序中使用 #include \u003ctchar.h\u003e 添加对 TCHAR 的支持。（我在vs里没加也编译通过了，不过还是加上的保险）\r4. 对于字符串，例如 \"abc\" 用 _T(\"abc\") 表示。就是加上 _T(\"\")。\r5. 定义字符变量时，将 char 换成 TCHAR。\r6. 【尽量不要在源码中使用中文】。\r ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:5:0","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"5.1. Microsoft 专用的修饰符 #define DllExport __declspec( dllexport ) //定义了可导出类，导出其所有成员函数和静态数据\r#define DllImport __declspec( dllimport ) //定义了可导入类，导入其所有成员函数和静态数据，一个程序中不能既是导出又是导入\r ","date":"2019-03-02","objectID":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/:5:1","tags":["TOOLS","VS"],"title":"Visual Studio","uri":"/post/plat-%E7%BC%96%E8%AF%91-vs-msvc/"},{"categories":["TOOLS"],"content":"1. 安装 sudo snap install code --classic ","date":"2019-03-02","objectID":"/post/tools-vscode/:1:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"2. 配置 打开设置（快捷键Ctrl + ,）,里面有两个设置。 【一个】是USER SETTINGS（用户设置）也就是全局配置，其他项目也会应用这个配置。 【另一个】是WORKSPACE SETTINGS（工作区设置）也就是项目配置，会在当前项目的根路径里创建一个.vscode/settings.json文件，然后配置只在当前项目生效。 配置同步，左下角登陆，同步。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:2:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3. 快捷键 ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.1. 单个键 End行尾。 Home行首； ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:1","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.2. Ctrl加1 Ctrl+/注释整行或取消注释整行； Ctrl+D 选择当前单词的下一个匹配项，并出现多个光标； Ctrl+End文件尾； Ctrl+F2选中所有的匹配项，并增加光标； Ctrl+G跳转到指定行； Ctrl+Home文件首； Ctrl+K+C注释； Ctrl+K+U取消注释； Ctrl+L选中当前行。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:2","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.3. Shift加1 Shift+End光标到行尾之间选中； Shift+Home光标到行首之间选中； ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:3","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.4. Alt加1 Alt+上下箭头将当前整行上移或下移； ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:4","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.5. ‵Ctrl+Alt`加1 Ctrl+Alt+-跳回上一个光标位置。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:5","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.6. Ctrl+Shift加1 Ctrl+Shift+上下箭头在相邻行增加光标； 配合`左右箭头`实现框选； 配合`Shift+End`实现框选； 配合`End`，光标都移动到行尾； 配合`Ctrl+C`可粘贴，还可粘贴框复制的内容（行数相同）。 Ctrl+Shift+K删除整行； Ctrl+Shift+L选中所有的匹配项，并增加光标； ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:6","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"3.7. ALt+Shift加1 Alt+Shift+上下箭头将当前整行向上复制或向下复制（编辑python,C的时候只是增加光标） Alt+Shift+I在选中区域的每一行的行尾添加光标； ","date":"2019-03-02","objectID":"/post/tools-vscode/:3:7","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"4. 命令 F1呼出命令行输入框，直接输入命令。 renderwhitespace# 显示空格sortlinesAscending# 正向排序sortlinesDescending# 逆向排序 ","date":"2019-03-02","objectID":"/post/tools-vscode/:4:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"5. 通用插件 ","date":"2019-03-02","objectID":"/post/tools-vscode/:5:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"5.1. increment-selection 编辑或是插入递增数字; 首先进入多行编辑，Ctrl+Alt+I即可完成递增数字的插入，默认从0开始，如果想改变起始数字，在多行编辑前将第一项改为想要的数字，多行选中后再使用快捷键。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:5:1","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"6. 应用场景 ","date":"2019-03-02","objectID":"/post/tools-vscode/:6:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"6.1. C/C++ 安装插件C/C++; 格式化： Clang_format_fallbackStyle#预定义样式。在没有找到.clang-format文件情况下使用这里定义的样式。可以设置的值为：Visual Studio、LLVM、【Google】、Chromium、Mozilla、WebKit、none，或者{key: value，…}这样的键值对. ","date":"2019-03-02","objectID":"/post/tools-vscode/:6:1","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"6.2. 访问数据库 安装插件vscode-database; 在命令框中输入 SQL 可以看到支持的操作。 Ctrl+Q直接输入 sql 语句enter执行。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:6:2","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"6.3. 编写前端项目 Vue Vue-cli Eslint 在 vscode 里代码自动格式化 6.3.1. 相关插件 禁用beautify 注:由于需要同时使用 prettier 和 eslint，而 prettier 的一些规则和 eslint 的一些规则可能存在冲突，例如 prettier 字符串默认是用双引号而 esLint 定义的是单引号的话这样格式化之后就不符合 ESLint 规则了。 所以要解决冲突就需要在 Prettier 的规则配置里也配置上和 ESLint 一样的规则，直接覆盖 6.3.1.1. Eslint * 6.3.1.1.1. 配置文件 在node工程目录下（即和package.json平级的目录），不是在文件夹跟目录下 JavaScript - use .eslintrc.js 文件导出一个包含配置信息的对象。 YAML - 使用 .eslintrc.yaml 或 .eslintrc.yml 定义配置。 JSON - 使用 .eslintrc.json 定义配置信息，JSON 文件中支持 JavaScript 注释。 package.json - 在 package.json 文件中增加一个 eslintConfig 字段，在该字段中定义配置信息。 .eslintrc - 已废弃 如果在同一个目录中有多个配置文件，则它们中间只有一个是有效的，优先级如下： .eslintrc.js .eslintrc.yaml .eslintrc.yml .eslintrc.json .eslintrc package.json .eslintrc.js module.exports = { root: true, env: { node: true }, extends: ['plugin:vue/essential', 'eslint:recommended'], rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', //强制使用单引号 quotes: ['error', 'single'], // double //强制不使用分号结尾 semi: ['error', 'never'] //always总是使用分号 //默认最后有逗号 \"comma-dangle\": [\"error\", \"never\"] }, parserOptions: { parser: 'babel-eslint' } } 6.3.1.1.2. 使用命令行 6.3.1.2. Vetur * 6.3.1.2.1. 格式化 只支持格式化整个文档。 格式器 prettier:Forcss/scss/less/js/ts.prettier-eslint:Forjs.Runprettierandeslint--fix.prettyhtml:Forhtml.stylus-supremacy:Forstylus.vscode-typescript:Forjs/ts.Thesamejs/tsformatterforVSCode. 设置 .prettierrc为配置文件，配置文件优先于 setting.json. \"vetur.format.enable\" # 格式化开关 \"vetur.format.options.tabSize\": 2, \"vetur.format.options.useTabs\": false setting.json \"vetur.format.defaultFormatterOptions\": { \"prettier\": { \"semi\": false, \"singleQuote\": true } } \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, \"vetur.format.defaultFormatter.js\": \"vscode-typescript\" \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\", { \"language\": \"vue\", \"autoFix\": true } ] ","date":"2019-03-02","objectID":"/post/tools-vscode/:6:3","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7. 扩展 ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:0","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7.1. koroFileHeader * 用于在文件头部插入注释Ctrl + Alt + I。 头部注释会自动创建。 函数注释可使用命令cursorTip。 在preferences-\u003esettings-\u003e搜索file Header-\u003e编辑settings.js. ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:1","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7.2. Tabnine * 闭源的强大的自动补全插件（运用机器学习算法）。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:2","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7.3. aiXcode * 免费版的只能500条/日。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:3","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7.4. cdr/code-server ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:4","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7.5. Python 可以首先使用 pyenv 创建一个虚拟环境，在 vscode 左下角选择这个虚拟环境。 ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:5","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":["TOOLS"],"content":"7.6. Python Docstring Generator 函数和方法的注释文档 docstring. ctrl+shift+2. ","date":"2019-03-02","objectID":"/post/tools-vscode/:7:6","tags":["TOOLS","VSCODE"],"title":"VSCODE","uri":"/post/tools-vscode/"},{"categories":null,"content":"监控系统 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:0:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"Grafana ***** Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:1:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"核心特点 展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式； 数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等； 通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知； 混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源； 注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记； 过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:1:1","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"部署 官方镜像grafana/grafana 环境变量 GF_INSTALL_PLUGINS# 指定插件版本GF_SECURITY_ADMIN_PASSWORD# admin的密码 挂载Volumns volumes:- $PWD/extra/grafana_db:/var/lib/grafanagrafana/grafana 部署完之后，需要登录进去创建数据源和创建DashBoard。 持久化 Grafana存储的配置以及图表在自己生成的sqlit数据库中长期存储，并不友好。 可以使用mysql ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:1:2","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"prometheus ***** 2012年，2016年加入CNCF； 参考Prometheus实战 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"核心特点 提供包含时间序列的强大的多维数据模型，identified by metric name and key/value pairs，如Counter、Gauge、Histogram、Summary； PromQL，自研一套高性能的时序数据库，在V3版本可以达到每秒千万级别的数据存储； 不依赖分布式存储； 提供pull模式、push gateway方式实现时间序列数据的采集； 通过服务发现或静态配置发现目标； 多种图形和仪表板支持模式,还支持导出（Grafana、Web UI、API clients）； 通过中间网关支持推送时间序列。 【优点】不仅支持SWAM原生集群；还支持K8S集群的监控；是目前容器监控最好的解决方案。 【优点】Go凭借简洁的语法和优雅的并发，在Java占据业务开发，C占领底层开发的情况下，准确定位中间件开发需求，在当前开源中间件产品中被广泛应用。 【优点】Prometheus开始成为主导及容器监控方面的标配，并且在未来可见的时间内被广泛应用。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:1","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"组件（可选） Main Server，负责抓取pull（周期性）和存储时间序列数据。 客户端代码库，集成在业务代码中。 Push gateway; special-purpose exporters; an alertmanager to handle alerts; various support tools. ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:2","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"数据模型 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:3","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"架构及生态组件 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:4","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"应用场景 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:5","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"部署 官方镜像prom/prometheus 配置文件(/etc/prometheus/prometheus.yml)docker 运行时挂载 global:scrape_interval:15s# evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.# scrape_timeout is set to the global default (10s).external_labels:# 与外部通信时的附加标签monitor:'raysonxin-monitor'scrape_configs:# 抓取配置 - job_name:'prometheus'scrape_interval:5sstatic_configs:- targets:['localhost:9090']# 目标主机(本地server)labels:group:'local'- job_name:'bn'scrape_interval:5sstatic_configs:- targets:['api_host:9000']# 目标主机（业务主机）labels:group:'arithmetic' docker-compose volumes:- /prometheus/prometheus/config:/etc/prometheus- /prometheus/prometheus/data:/prometheuscommand:- ‘--config.file=/etc/prometheus/prometheus.yml‘- ‘--log.level=info‘- ‘--web.listen-address=0.0.0.0:9090‘- ‘--storage.tsdb.path=/prometheus‘- ‘--storage.tsdb.retention=15d‘- ‘--query.max-concurrency=50‘- ‘--web.enable-lifecycle‘ 数据持久化 Prometheus的存储数据库默认只保留15天的数据. 可以使用InfluxDB ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:2:6","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"Rollbar 实时收集分析Web应用抛出的错误.免费版一个月5000次错误事件。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:3:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"SENTRY ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:4:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"使用docker安装 Installation with Docker ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:4:1","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"ZABBIX 一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。 2012年； ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:5:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"核心特点 可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上； 【缺点】Zabbix由于使用了关系型数据存储时序数据，所以在监控大规模集群时常常在数据存储方面捉襟见肘。所以从Zabbix 4.2版本后开始支持TimescaleDB时序数据库，不过目前成熟度还不高。 【缺点】对容器支持不是很好。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:5:1","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"组件 zabbix由2部分构成，zabbix server与可选组件zabbix agent。 zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能； Zabbix Server将收集的监控数据存储到Zabbix Database中。Zabbix Database支持常用的关系型数据库，如果MySQL、PostgreSQL、Oracle等，默认是MySQL，并提供Zabbix Web页面（PHP编写）数据查询。 Agent主要负责采集数据并通过主动或者被动的方式采集数据发送到Server/Proxy，除此之外，为了扩展监控项，Agent还支持执行自定义脚本。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:5:2","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"应用场景 作者：徐亮偉 链接：https://www.zhihu.com/question/19973178/answer/154424211 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 硬件监控 通过SNMP来进行路由器交换机的监控(这些可以跟一些厂商沟通来了解如何做)、服务器的温度以及其他，可以通过IPMI来实现。当然如果没有硬件全都是云，直接跳过这一步骤。 系统监控。 如CPU的负载，上下文切换、内存使用率、磁盘读写、磁盘使用率、磁盘inode节点。当然这些都是需要配置触发器，因为默认太低会频繁报警。 服务监控。 比如用LNMP nginx自带Status模块、PHP也有相关的Status、MySQL的话可以通过percona来进行监控。Redis这些通过自身的info获信息进行过滤等。方法都类似。要么服务自带。要么通过脚本来实现想监控的内容，以及报警和图形功能。 网络监控。 如果是云主机又不是跨机房，那么可以选择不监控网络。当然你说我们是跨机房以及如何如何。推荐使用smokeping来做网络相关的监控。或者直接交给你们的网络工程师来做。因为术业有专攻。 安全监控。 如果是云主机可以考虑使用自带的安全防护。当然也可以使用iptables。如果是硬件，那么推荐使用硬件防火墙。使用云可以购买防DDOS，避免出现故障导致down机一天。如果是系统，那么权限、密码、备份、恢复基础的方案要做好。web同时也可以使用nginx+waf来实现一个web层面的防火墙。当然也可以使用集成好的openresty。 Web监控。 web监控的话题其实还是很多。比如可以使用自带的web监控来监控页面相关的延迟、js响应时间、下载时间、等等。这里我推荐使用专业的商业软件，听云来做这一块。毕竟人家全国各地都有机房。（如果本身是多机房那就另说了） 日志监控。 如果是web的话可以使用监控Nginx的500x日志。PHP的ERROR日志。其实这些需求无非是，收集、存储、查询、展示，我们其实可以使用开源的ELKstack来实现。ogstash（收集）、elasticsearch（存储+搜索）、kibana（展示） 业务监控(API) ****** 所以业务层面这块的监控需要和开发以及总监开会讨论，监控比较重要，如API、等。通过简单的脚本就可以实现，最后设置触发器即可 流量分析。 平时我们分析日志都是拿awk sed xxx一堆工具来实现。这样对我们统计ip、pv、uv不是很方便。那么可以使用百度统计、google统计、商业，让开发嵌入代码即可。当然避免隐私也可以使用piwiki来做相关的流量分析。 可视化。 通过screen以及引入一些第三方的库来美化界面，同时我们也需要知道、订单量突然增加、突然减少。或者说突然来了一大波流量，这流量从哪儿来，是不是推广了，还是被攻击了。可以结合监控平来来梳理各个系统之间的业务关系。 自动化监控。 可以通过Zabbix的主动模式以及被动模式来实现。当然最好还是通过API来实现。 问题排查 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:5:3","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"服务器变慢 服务器整体情况、CPU使用情况、内存、磁盘、磁盘IO、网络IO。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:6:0","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"vmstat(CPU使用情况) 其中主要关注 procs 和 cpu 这两个参数 procs ： r ：运行和等待 CPU 时间片的进程数，一般来说整个系统的运行队列不要超过总核数的 2 倍，要不然系统压力太大了 b : 等待资源的进程数，比如正在等待磁盘 IO ，网络 IO 这种 cpu ： us ：用户进程消耗 CPU 时间百分比， us 值高的话，说明用户进程消耗 CPU 时间比较长，如果长期大于 50% 的话，那就说明程序还有需要优化的地方 sy ：内核进程消耗的 CPU 时间百分比 us + sy 参考值为 80% ，如果大于 80% 的话，说明可能存在 CPU 不足 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:6:1","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"free（内存使用情况） free、free -g、free -m； 如果应用程序可用内存/系统物理内存大于 70% 的话，说明内存是充足的，没啥问题，但是如果小于 20% 的话，就要考虑增加内存了。 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:6:2","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"df（磁盘使用情况） ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:6:3","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"iostat（磁盘IO） iostat -xdk 3 2 rkB/s ：每秒读取数据量 kB ； wkB/s ：每秒写入数据量 kB ； svctm ：I/O 请求的平均服务时间，单位毫秒； util ：一秒中有百分之几的时间用于 I/O 操作，如果接近 100% 说明磁盘带宽跑满了，这个时候就要优化程序或者增加磁盘了 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:6:4","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"sar（网络IO） sar -n DEV 3 2 IFACE ：LAN 接口 rxpck/s ：每秒钟接收的数据包 txpck/s ：每秒钟发送的数据包 rxKB/s ：每秒接收的数据量，单位 KByte txKB/s ：每秒发出的数据量，单位 KByte rxcmp/s ：每秒钟接收的压缩数据包 txcmp/s ：每秒钟发送的压缩数据包 rxmcst/s：每秒钟接收的多播数据包 ","date":"2019-02-27","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:6:5","tags":["运维"],"title":"运维-监控系统-问题排查","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":null,"content":"负载均衡的作用 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"转发功能 按照一定的算法【权重、轮询】，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:1","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"故障移除 通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:2","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"恢复添加 如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:3","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"OSPF负载均衡 OSPF（开放式最短链路优先）是一个内部网关协议（Interior Gateway Protocol，简称 IGP）。 OSPF 通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，OSPF 会自动计算路由接口上的 Cost 值，但也可以通过手工指定该接口的 Cost 值，手工指定的优先于自动计算的值。 OSPF 计算的 Cost，同样是和接口带宽成反比，带宽越高，Cost 值越小。到达目标相同 Cost 值的路径，可以执行负载均衡，最多 6 条链路同时执行负载均衡。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:2:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"LVS 它是一种集群（Cluster）技术，采用 IP 负载均衡技术和基于内容请求分发技术。 调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"HAProxy可靠，高性能的TCP / HTTP负载均衡器 haproxy是工作在四层之上的，这也就意味着它可以代理的服务要比nginx更广泛，性能比nginx也要更高一些。 让一个端口同时做两件事：http/https和ssh 需要设置为开机启动。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:4:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"NGINX ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:5:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"Nginx的负载分发策略 Nginx 的 upstream目前支持的分配算法：  轮询 ——1：1 轮流处理请求（默认）,每个请求按时间顺序逐一分配到不同的应用服务器，如果应用服务器down掉，自动剔除，剩下的继续轮询。  权重 ——you can you up.通过配置权重，指定轮询几率，权重和访问比率成正比，用于应用服务器性能不均的情况。  ip_哈希算法:每个请求按访问ip的hash结果分配，这样每个访客固定访问一个应用服务器，可以解决session共享的问题。  ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:5:1","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"配置Nginx的负载均衡与分发策略 通过在upstream参数中添加的应用服务器IP后添加指定参数即可实现，如： upstream tomcatserver1 { server 192.168.72.49:8080 weight=3; server 192.168.72.49:8081; } server { listen 80; server_name 8080.max.com; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://tomcatserver1; index index.html index.htm; } } 通过以上配置，便可以实现，在访问8080.max.com这个网站时，由于配置了proxy_pass地址，所有请求都会先通过nginx反向代理服务器，在服务器将请求转发给目的主机时，读取upstream为 tomcatsever1的地址，读取分发策略，配置tomcat1权重为3，所以nginx会将大部分请求发送给49服务器上的tomcat1，也就是8080端口；较少部分给tomcat2来实现有条件的负载均衡，当然这个条件就是服务器1、2的硬件指数处理请求能力。  nginx其他配置 upstream myServer { server 192.168.72.49:9090 down; server 192.168.72.49:8080 weight=2; server 192.168.72.49:6060; server 192.168.72.49:7070 backup; } down:表示单前的server暂时不参与负载 Weight:默认为1.weight越大，负载的权重就越大。 max_fails:允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 fail_timeout:max_fails 次失败后，暂停的时间。 Backup:其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:5:2","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"使用Nginx的高可用  除了要实现网站的高可用，也就是提供n多台服务器用于发布相同的服务，添加负载均衡服务器分发请求以保证在高并发下各台服务器能相对饱和的处理请求。同样，负载均衡服务器也需要高可用，以防如果负载均衡服务器挂掉了，后面的应用服务器也紊乱无法工作。 实现高可用的方案：添加冗余。添加n台nginx服务器以避免发生上述单点故障。具体方案详见下文：keepalive+nginx实现负载均衡高可用. ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:5:3","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"keepalive+nginx实现负载均衡高可用 为了避免负载均衡服务器的宕机故障，需要建立一个备份机。主备机上都运行高可用（High Availability）监控程序，通过传送心跳信息来监控对方的运行状况。当备份机不能在一定的时间内收到对方的正常心跳时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。 keepalive 安装 keepalive 配置 ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:5:4","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"PACHE ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"反向代理 \u003cVirtualHost *:80\u003e ServerName www.songsong.red ServerAlias songsong.red ProxyRequests off # off表示开启反向代理，on表示开启正向代理 \u003cProxy *\u003e Order deny,allow Allow from all \u003c/Proxy\u003e \u003cLocation /\u003e ProxyPass http://localhost:8080/ ProxyPassReverse http://localhost:8080/ \u003c/Location\u003e \u003c/VirtualHost\u003e ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:1","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"TRAEFIK 云原生Edge路由器。 是一个现代HTTP反向代理和负载均衡器，使部署微服务更容易. ","date":"2019-02-26","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:7:0","tags":["运维"],"title":"负载均衡\\反向代理","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["项目管理"],"content":"参考[原创]基于VueJs的前后端分离框架搭建之完全攻略 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:0:0","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"1. API概述 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:1:0","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"2. 重要性 API文档服务器就是专门用来生成API文档的。有了API文档，前端开发人员就可以基于API文档产生模拟数据（mock），然后使用mock的数据完成页面样式和页面交互；有了API文档，后端开发人员就可以基于API文档完成请求的处理以及返回响应数据。 API文档服务器（通常为WEB服务器）是一个可以动态生成最新版本API文档的服务器，并支持本地维护+远程访问。 软件开发流程中的几个关键环节： （1）产品经理提需求，画原型； （2）UI设计师根据原型出设计图； （3）测试团队根据产品原型编写测试用例，制定测试计划； （4）架构师根据原型编写API文档； （5）前后端工程师基于API文档完成业务开发； （6）测试、改BUG、发布。 swagger之不够完美的地方： （1）通过swagger生成的API文档看不见版本修改记录，你不知道什么时候后端开发人员悄悄改了下API文档而忘记/有意不通知前端开发人员，这样的锅前端背了太多； （2）接口文档由后端开发人员编写，前端开发人员的地位实际上比后端的低，并且前端开发人员仍然会经常找后端开发人员沟通修改API文档（强依赖仍然存在）； （3）本来swagger的API定义应该由架构师或项目经理编写，但由于后端开发人员可以直接改文档，这导致的实际效果就是：基本上API文档都直接由开发人员编写（或修改），其质量水平很难达到期望； （4）swagger生成API文档的类的定义可能是多层引用关联的，但是这个类又太容易被开发人员修改到，或者不小心改到，如果开发人员忘记通知前端或者只通知了部分改动，那就会造成严重的问题； （5）使用swagger的语法来编写API文档，其实还是很麻烦的，我们希望这个语法能够超级简单； （6）swagger会污染你的代码。 wagger的这些缺点其实综合来讲，其主要的问题就在于它让API编写/修改太过容易，让软件开发过程和管理过程太容易出错。如果你们团队建立了严格的管理机制，那还是可以将swagger用的很和谐的，但这不是笔者，作为一个架构师，可以撇开责任的理由。 如何让开发人员更不容易写出错误的代码是评价一个架构师能力的重要标准。 笔者在写代码或做架构的时候有一个思维习惯，就是不管某个问题多么复杂具体解决方案是什么，我会先去想想这个问题的最佳的处理方式应该是什么样子，然后再去想这些最佳的处理方式哪些可以实现，哪些实现不了而只能用次一点的方案，然后次一点的方案是否可以接受。 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:2:0","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3. API工具 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:0","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3.1. Apifox****** Apifox = Postman + Swagger + Mock 接口文档、调试、Mock、自动化测试，提升 10 倍效率！ ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:1","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3.2. POSTMAN工具 优点 缺点 只有在线版，不能私有部署 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:2","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3.3. rap2 非官方rap2-delos部署文档 阿里妈妈前端团队出品的开源接口管理工具RAP第二代后端 RAP2前端 优点 缺点 可以导出postman文件 支持自动生成mock数据 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:3","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3.4. Showdoc 优点 缺点 可以权限管理 版本控制不完善，需要手动添加 可以私有部署 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:4","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3.5. Crapapi 优点 缺点 接口 文档 数据库表 BUG管理 附件 团队协作 ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:5","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":["项目管理"],"content":"3.6. apiDoc creates a documentation from API annotations in your source code ","date":"2019-02-22","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/:3:6","tags":["项目管理"],"title":"API文档服务器","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-api%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"前端风向标 THX from Alimama FE THX 是一系列前端开发相关的工具，框架和类库的集合，也是阿里集团阿里妈妈、一淘网和无线产品线 以及小微金服部分前端工程师的技术组织名称。 ","date":"2019-02-21","objectID":"/post/%E5%89%8D%E7%AB%AF-%E6%89%A9%E5%B1%95/:1:0","tags":["前端"],"title":"前端扩展和工程模板","uri":"/post/%E5%89%8D%E7%AB%AF-%E6%89%A9%E5%B1%95/"},{"categories":null,"content":"协议 ","date":"2019-02-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-03-%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["微服务","架构"],"title":"微服务架构笔记(3)流媒体服务器","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-03-%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"HLS协议 HTTP Live Streaming（缩写是HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。 HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 HLS协议规定： 视频的封装格式是TS。 视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。 除了TS视频文件本身，还定义了用来控制播放的m3u8文件（文本文件）。 HLS也有一些无法跨越的坑，比如采用HLS协议直播的视频延迟时间无法下到10秒以下，而RTMP协议的延迟最低可以到3、4秒左右。所以说对直播延迟比较敏感的服务请慎用HLS。 ","date":"2019-02-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-03-%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:1","tags":["微服务","架构"],"title":"微服务架构笔记(3)流媒体服务器","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-03-%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"1. 配置 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:1:0","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"1.1. 配置文件nginx.conf # 全局块:配置影响nginx全局的指令usernobody;#配置用户或者组，默认为nobody nobody。worker_processes1;#允许生成的进程数，默认为1error_loglogs/error.log;#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg# error_log logs/error.log notice;# error_log logs/error.log info;pidlogs/nginx.pid;#指定nginx进程运行文件存放地址worker_rlimit_nofile65535;#指定进程可以打开的最大描述符：数目# events块：配置影响nginx服务器或与用户的网络连接events{accept_mutexon;#设置网路连接序列化，防止惊群现象（一个网路连接到来，多个睡眠的进程被同事叫醒，但只有一个进程能获得链接，这样会影响系统性能）发生，默认为onmulti_accepton;#设置一个进程是否同时接受多个网络连接，默认为off# use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventportworker_connections1024;#最大连接数，默认为512keepalive_timeout60;# keepalive超时时间open_file_cachemax=65535inactive=60s;#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。open_file_cache_valid80s;#这个是指多长时间检查一次缓存的有效信息。}# http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。http{includemime.types;#文件扩展名与文件类型映射表default_typeapplication/octet-stream;#默认文件类型，默认为text/plain#access_log off; #取消服务日志#log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '# '$status $body_bytes_sent \"$http_referer\" '# '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 自定义日志格式$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；$remote_user ：用来记录客户端用户名称；$time_local ： 用来记录访问时间与时区；$request ： 用来记录请求的url与http协议；$status ： 用来记录请求状态；成功是200；$body_bytes_s ent ：记录发送给客户端文件主体内容大小；$http_referer ：用来记录从那个页面链接访问过来的；$http_user_agent ：记录客户端浏览器的相关信息；#access_log logs/access.log main; #combined为日志格式的默认值sendfileon;#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。sendfile_max_chunk100k;#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。#tcp_nopush on;client_max_body_size1m;# 设置客户端请求体的最大值，默认是1Mclient_body_buffer_size；# Nginx分配给请求数据的Buffer大小。小于client_body_buffer_size直接在内存中高效存储。如果大于client_body_buffer_size小于client_max_body_size会存储临时文件，临时文件一定要有权限。如果追求效率，就设置 client_max_body_size client_body_buffer_size相同的值，这样就不会存储临时文件，直接存储在内存了。#keepalive_timeout 0;keepalive_timeout65;#连接超时时间，默认为75s，可以在http，server，location块。upstreammysvr{# 配置负载均衡server127.0.0.1:7878;server192.168.10.121:3333backup;#热备}error_page404https://www.baidu.com;#错误页#gzip on;# server块：配置【虚拟主机】的相关参数，一个http中可以有【多个server】server{keepalive_requests120;#单连接请求上限次数。listen80;# 监听端口server_namelocalhost;# 监听地址#charset koi8-r;#access_log logs/host.access.log main;#location块：配置请求的路由，以及各种页面的处理情况。location/{#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。roothtml;# 设置根目录indexindex.htmlindex.htm;# 设置默认页# 使用文件夹浏览功能时配置autoindexon;//开启目录浏览功能；autoindex_exact_sizeoff;//关闭详细文件大小统计，让文件大小显示MB，GB单位，默认为b；autoindex_localtimeon;//开启以服务器本地时区显示文件修改日期！}#error_page 404 /404.html;# redirect server error pages to the static page /50x.html#error_page500502503504/50x.html;location=/50x.html{roothtml;}# proxy the PHP scripts to Apache listening on 127.0.0.1:80#location~\\.php${proxy_passhttp://127.0.0.1;# 代理}location/{proxy_passhttp://fe:80;indexindex.html;}# 反向代理可以用于前端页面的代理【在前端项目中，最好不要写死接口的域名，最好使用反向代理。写死之后在部署的时候，尤其端口转发部署的时候，有坑。】# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \\.php$ {# root html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;# include fastcgi_params;#}# deny access to .htaccess files, if Apache's document root# concurs with nginx's one##location ~ /\\.ht {# deny all; # 拒绝的IP all# allow all; # 允许的IP#}}# another virtual host using mix of IP-, name-, and port-based configuration##server {# listen 8000;# listen somename:8080;# server_name somename alias another.alias;# location / {# root html;# index index.html index.htm;# }#}# HTTPS server##server {# listen 443 ssl;# server_name localhost;# ssl_certificate cert.pem;# ssl_certificate_key cert.key;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 5m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;# location / {# root html;# index index.html index.htm;# }location~*.(js)${add_headerContent-Type'text/javascript;charset=utf-8';# 其中匹配所有.js文件，给其responent header的Content-Type值赋值为\"text/javascript;charset=utf-8\"。}#}} ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:1:1","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"1.2. 其他 在nginx.conf配置文件中http选项配置多个serve即可实现多虚拟主机 1.2.1. http配置 1.2.1.1. uwsgi_ignore_client_abort Determines whether the connection with a uwsgi server should be closed when a client closes the connection without waiting for a response. 1.2.2. 超时配置 1.2.2.1. keepalive_timeout HTTP 有一个 KeepAlive 模式，它告诉 webserver 在处理完一个请求后保持这个 TCP 连接的打开状态。若接收到来自客户端的其它请求，服务端会利用这个未被关闭的连接，而不需要再建立一个连接。 一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。 keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。 1.2.2.2. client_body_timeout 指定客户端与服务端建立连接后发送 request body 的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx 返回 HTTP 408（Request Timed Out）。 1.2.2.3. client_header_timeout 客户端向服务端发送一个完整的 request header 的超时时间。如果客户端在指定时间内没有发送一个完整的 request header，Nginx 返回 HTTP 408（Request Timed Out）。 1.2.2.4. send_timeout 服务端向客户端传输数据的超时时间。 1.2.2.5. lingering_timeout TCP连接关闭时的SO_LINGER延时设置，默认5s 1.2.2.6. resolver_timeout 域名解析超时，默认30s 1.2.2.7. send_timeout 发送数据至客户端超时, 默认60s, 如果连续的60s内客户端没有收到1个字节, 连接关闭 1.2.2.8. proxy_connect_timeout nginx与upstream server的连接超时时间， 默认60s 1.2.2.9. proxy_read_timeout nginx接收upstream server数据超时, 默认60s, 如果连续的60s内没有收到1个字节, 连接关闭 1.2.2.10. proxy_send_timeout nginx发送数据至upstream server超时, 默认60s, 如果连续的60s内没有发送1个字节, 连接关闭 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:1:2","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"2. 命令 命令 功能 nginx -s reload 重载配置文件 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:2:0","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"3. 管理 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:3:0","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"3.1. 查看当前连接数 netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:3:1","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"4. 扩展 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:4:0","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"4.1. Tengine Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:4:1","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"4.2. apache /etc/apache2/sites-enabled/中存储虚拟主机配置文件。 \u003cVirtualHost *:80\u003e # The ServerName directive sets the request scheme, hostname and port ServerName www.test.cn ServerAdmin webmaster@localhost DocumentRoot /var/www/public ServerAlias test.cn \u003cDirectory \"/var/www/public\"\u003e \u003c/Directory\u003e ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined \u003c/VirtualHost\u003e /etc/a[acje2/sites-available/中存储指向上边目录中配置文件中的软连接。 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:4:2","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"4.3. 主机记录 主机记录类型 说明 www 将域名解析为www.example.com，填写www @ 将域名解析为example.com（不带www），填写@或者不填写 mail 将域名解析为mail.example.com，通常用于解析邮箱服务器 * 泛解析，所有子域名均被解析到统一地址（除单独设置的子域名解析） 二级域名 如：mail.example.com或abc.example.com，填写mail或abc 手机网站 如：m.example.com，填写m ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:4:3","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"4.4. 注意 配置域名之后，需要到域名控制处增加解析配置 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:4:4","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"5. HTTP 状态码 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:5:0","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"5.1. 499 5.1.1. nginx client has closed connection,客户端关闭连接。一般是nginx主动拒绝，如果客户端重连次数过快。 可以更改nginx配置解决:proxy_ignore_client_abort on;，但是这样不安全。 ","date":"2019-02-18","objectID":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/:5:1","tags":["WEB服务器","平台"],"title":"Nginx","uri":"/post/plat-web%E6%9C%8D%E5%8A%A1%E5%99%A8-nginx/"},{"categories":null,"content":"炒 干锅花菜 花菜切小块，清洗干净备用； 猪肉切片备用； 蒜切小粒，小米椒切小粒，二荆条辣椒切小粒，干辣椒剪碎，备用。 洋葱切撕备用。 加水，放入盐，烧开，放入花菜，放一点食用油，焯水40秒; 放油，油热，放入五花肉，爆出猪油; 放入第三步料，爆香， 放花菜，生抽，白糖，盐，翻炒; 放在洋葱上即可。 青椒肉丝 青椒和木耳切丝备用； 猪里脊，切丝；放生抽、老抽、料酒、淀粉腌制； 拌汁：白糖、生抽、老抽、淀粉、水；搅匀备用； 放油，油热，下肉丝，待肉丝变色再翻炒片刻；放入木耳、放入青椒、炒至青椒变软，倒入汁即可。 手撕包菜 包菜撕小块，洗净沥干水分备用； 葱和红辣椒切小段，大蒜和姜切末； 调汁：糖、醋、生抽、淀粉和清水，搅匀备用; 放油，五成热，放葱 姜 蒜，爆香； 放入红辣椒炒出香味; 放入包菜炒至断生变软； 淋入调好的酱汁翻炒均匀。 放入盐即可。 鸡蛋虾仁超秋葵 虾皮炒茄条 茄子洗净切条，肥肉切小条； 姜、蒜、辣椒切碎； 虾皮洗净； 水淀粉小半碗； 锅烧热，下肥肉煸出油；待油全部炸出，加姜、蒜、辣椒炒香；入虾皮炒匀。 加入茄子翻炒，刚开始吸油，变软之后吐油（约两分钟）； 盐、鸡精、生抽、开水少许；倒入水淀粉炒匀； 出锅，撒葱花。 豆腐皮炒胡萝卜 ","date":"2019-02-17","objectID":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/:1:0","tags":["生活"],"title":"家常菜","uri":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/"},{"categories":null,"content":"饼 包菜鸡蛋煎饼 包菜切碎一小碗，面粉一小碗、鸡蛋两个； 上述混合,加盐\\油\\水调成糊状; 电饼铛摊开,焖2分钟,翻面,再焖2分钟,即可. ","date":"2019-02-17","objectID":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/:2:0","tags":["生活"],"title":"家常菜","uri":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/"},{"categories":null,"content":"煲（焖） 红焖猪脚 准备一小碗黄酒； 猪脚清洗，冷水下锅焯糖，放入两片姜，和一点料酒； 焯烫好了之后，捞出清洗干净； 放入自封袋中，两个八角，两片香叶，几片姜，一个小洋葱，两勺生抽，一小勺盐，一勺耗油，最后把黄酒加进来； 封口，将空气挤压干净，混合均匀，放入冰箱冷藏2个小时； 放入电饭锅中，摊平，煮饭键1个半小时，中间翻几次； 可以上桌了。 ","date":"2019-02-17","objectID":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/:3:0","tags":["生活"],"title":"家常菜","uri":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/"},{"categories":null,"content":"凉菜 凉拌黄瓜木耳 干木耳提前用水浸泡3小时，洗净，撕成小朵； 姜末、葱白、葱花； 黄瓜用削皮刀，削薄薄一层，用筷子卷起，置于盘子周围； 锅烧开水，放点盐，木耳煮5分钟，捞出，用水冲净，控干水分，置于盘子中间； 锅烧热倒油，放葱白姜末爆香；调小火，放1勺生抽、半勺耗油、1勺陈醋、少许白糖、3勺清水搅拌均匀，关火，淋在木耳上，撒上葱花和白芝麻，再淋少许香油增香。 ","date":"2019-02-17","objectID":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/:4:0","tags":["生活"],"title":"家常菜","uri":"/post/%E6%97%A5%E5%B8%B8-%E5%AE%B6%E5%B8%B8%E8%8F%9C/"},{"categories":["TOOLS"],"content":"chrome插件","date":"2019-01-30","objectID":"/post/tools-chrome/","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":["TOOLS"],"content":"插件网站 ","date":"2019-01-30","objectID":"/post/tools-chrome/:0:0","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":["TOOLS"],"content":"1. t9tio/tomato-pie 不太好用 ","date":"2019-01-30","objectID":"/post/tools-chrome/:1:0","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":["TOOLS"],"content":"2. Awesome Screenshot 比较好用 ","date":"2019-01-30","objectID":"/post/tools-chrome/:2:0","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":["TOOLS"],"content":"3. Tampermonkey ","date":"2019-01-30","objectID":"/post/tools-chrome/:3:0","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":["TOOLS"],"content":"3.1. 油猴脚本网站Greasy Fork ","date":"2019-01-30","objectID":"/post/tools-chrome/:3:1","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":["TOOLS"],"content":"3.2. 编写油猴脚本 3.2.1. 元数据块 元数据块是描述脚本的一个用户脚本部分。它通常包含脚本名称，命名空间，描述和包含和排除规则。元数据块出现在JavaScript行注释中，可能会出现在脚本内的任何位置， 但通常靠近文件的顶部 键 示例 备注 @name @name 脚本名称 脚本的名称。该项将显示在页面的标题以及链接内容，必填项 @description @description 脚本功能描述 脚本功能的描述，显示在脚本标题下面，必填项 @namespace @namespace 及 @name 这两个属性将帮助用户脚本管理器判断是否已安装该脚本 @version @version 0.0.1 脚本的版本标记将使用 Mozilla 版本格式 并显示于脚本的简介页面，必填项 @include @exclude @match @match ://www.52pojie.cn/ 描述脚本将执行的页面。该列表会被分析并展示到脚本的简介页面，以及用于脚本分类 @require @require http://cdn.bootcss.com/jquery.min.js 引用外部脚本到您的脚本 @updateURL @installURL @downloadURL 告知用户脚本管理器应该在哪个地址获取脚本更新。 @license 脚本所使用的许可协议名称或地址，该协议需包含用户是否允许二次分发或修改脚本的权利。不提供许可协议则表示用户仅允许个人使用且不得二次分发；该协议将在脚本的简介页面显示 @supportURL 用户可获得该脚本技术支持的链接地址 (如：错误反馈系统、论坛、电子 邮件)，该链接将显示在脚本的反馈页面 @contributionURL 用于捐赠脚本作者的链接，该链接将显示在脚本的反馈页面 @contributionAmount 建议捐赠金额，请配合 @contributionURL 使用 @compatible 标记此脚本与某个浏览器兼容，兼容性信息将显示在脚本的简介页面上 @incompatible 标记此脚本与某个浏览器不兼容，兼容性信息将显示在脚本的简介页面上 @run-at document-start\\document-body\\document-end\\document-idle\\context-menu 参考Tampermonkey中文文档（部分） ","date":"2019-01-30","objectID":"/post/tools-chrome/:3:2","tags":["TOOLS","VSCODE"],"title":"chrome插件","uri":"/post/tools-chrome/"},{"categories":null,"content":"Docker进程管理 参考从一个实例，一窥docker进程管理 在Docker中，进程管理的基础是Linux内核的PID命名空间技术。在不同的PID命名空间下，可以有相同的PID。 Linux内核为所有的PID命名空间维护了一个树状的数据结构，最顶层是系统初始化时创建的root namespace（根命名空间）， 父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点名空间中的任何内容，也不可能通过kill或ptrace影响父节点或其他名空间中的进程。 在docker中有一个很特殊的进程——PID为1的进程，这也是docker的主进程(支持这一个)，通过Dockerfile中的 ENTRYPOINT 和/或 CMD指令指定。当主进程退出的时候，容器所拥有的PIG命名空间就会被销毁，容器的生命周期也会结束docker最佳实践建议的是一个container一个service，并不强制要你一个container一个线程。有的服务，会催生更多的子进程，比如Apache和uwsgi，这是完全OK的。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:1:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"安装 使用清华源 sudo snap install docker The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The Docker daemon always runs as the root user. 将用户添加到docker组中，sudo usermod -aG docker jayzhen只有不用重启docker，并重新登录。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:2:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"配置 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:3:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Dockerfile ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:4:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"ADD ADD指令可以让你使用URL作为参数。当遇到URL时候，可以通过URL下载文件并且复制到。 ADD的另外一个特性是有能力自动解压文件。如果参数是一个可识别的压缩格式（tar, gzip, bzip2, etc）的本地文件（所以实现不了同时下载并解压），就会被解压到指定容器文件系统的路径。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:4:1","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"COPY ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:4:2","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"ENTRYPOINT CMD 指定启动容器执行的命令 在指令格式上，一般推荐使用 exec 格式（不启动shell），这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。 CMD [\"executable\",\"param1\",\"param2\"] 使用 exec 执行，推荐方式； CMD [\"sh\", \"shell脚本\"] 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。 CMD command param1 param2 如： CMD echo $HOME CMD [\"param1\",\"param2\"] 提供给 ENTRYPOINT 的默认参数； 每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。 如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 至少有一个CMD或者ENTRYPOINT。 ENTRYPOINT should be defined when using the container as an executable. CMD should be used as a way of defining default arguments for an ENTRYPOINT command or for executing an ad-hoc command in a container. CMD will be overridden when running the container with alternative arguments. If CMD is defined from the base image, setting ENTRYPOINT will reset CMD to an empty value. In this scenario, CMD must be defined in the current image to have a value. No ENTRYPOINT ENTRYPOINT exec_entry p1_entry ENTRYPOINT [“exec_entry”, “p1_entry”] No CMD error, not allowed /bin/sh -c exec_entry p1_entry exec_entry p1_entry CMD [“exec_cmd”, “p1_cmd”] exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry exec_cmd p1_cmd CMD [“p1_cmd”, “p2_cmd”] p1_cmd p2_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry p1_cmd p2_cmd CMD exec_cmd p1_cmd /bin/sh -c exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:4:3","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"最佳实践 使用.dockerignore排除构建无关文件，可提高构建速度。 当我们在 docker build 的过程中，首先会将指定的上下文目录`Sending build context to Docker daemon 27.41MB `打包传递给 docker引擎，而这个上下文目录中可能并不是所有的文件我们都会在 Dockerfile 中使用到，那么这个时候就可以在 .dockerignore 文件中指定在传递给 docker引擎时需要忽略掉的文件或文件夹。 使用多阶段构建。 一个容器只做一件事，需要网络通信，则可以将他们置于一个网络下。 减少镜像层数，只有RUN,COPY,ADD会创建层数，其他指令不会增加层数。 将多行参数进行排序。 充分利用构建缓存。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:4:4","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"配置网络 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"bridge 默认。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:1","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"host 容器与主机享受相同的network namespace。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:2","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"overlay ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:3","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"macvlan ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:4","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"none ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:5","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Network plugins ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:6","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"命令 docker network create创建一个网络。 docker network ls列出网络。 docker commit docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS说明： -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:5:7","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"解决问题 GitLab CI with docker and dind “mount: permission denied (are you root?)\" Docker容器修改hosts文件重启不变 1./etc/hosts, /etc/resolv.conf和/etc/hostname，容器中的这三个文件不存在于镜像，而是存在于/var/lib/docker/containers/\u003ccontainer_id\u003e，在启动容器的时候，通过mount的形式将这些文件挂载到容器内部。因此，如果在容器中修改这些文件的话，修改部分不会存在于容器的top layer，而是直接写入这三个物理文件中。 2.为什么重启后修改内容不存在了？原因是：每次Docker在启动容器的时候，通过重新构建新的/etc/hosts文件，这又是为什么呢？原因是：容器重启，IP地址为改变，hosts文件中原来的IP地址无效，因此理应修改hosts文件，否则会产生脏数据。 docker运行nginx为什么要使用 daemon off 宿主机可以访问外网，但是容器不能，重启Docker可以解决（或者升级Docker并重启宿主机）。 docker中使用定时任务，定时任务放进supervisord中. ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:6:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"选择镜像 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:7:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Ubuntu ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:7:1","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"CENTOS 使用Docker创建容器时，基础镜像通常选择Ubuntu或Centos，不管哪个镜像的大小都在100MB以上。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:7:2","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"ALPINE Alpine Linux的最大优势是小，Alpine Linux是一个面向安全的轻型的Linux发行版，Alpine Linux采用了 musl libc 和 busybox以减小系统的体积和运行时资源消耗。在保持瘦身的同时，Alpine Linux还提供了自己的包管理工具apk。 Alpine Linux使用了musl，可能和其他Linux发行版使用的glibc实现会有些不同。 musl实现的DNS服务不会使用resolv.conf文件中的search和domain两个配置，通过DNS来进行服务发现时需要注意。 sgerrand / alpine-pkg-glibc. Alpine与glibc。 安装GCC apk add build-base 安装基础库（包含GCC、libc-dev、binutils）。 OSError: mysql_config not found执行apk add mariadb-dev mariadb-client. fatal error: linux/limits.h 执行 apk add linux-headers. The headers or library files could not be found for jpeg 执行 apk add libjpeg-turbo-dev. RUN pip install \"celery[librabbitmq,redis,msgpack]\" 安装过程中出错，“poll or select”只需要安装6安装glibc即可。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:7:3","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"NGINX 官方镜像 nginx:alpine 包含envsubst命令。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:7:4","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"资源限制 ***** 参考Docker(二十)-Docker容器CPU、memory资源限制 在使用 docker 运行容器时，默认的情况下，docker没有对容器进行硬件资源的限制，当一台主机上运行几百个容器，这些容器虽然互相隔离，但是底层却使用着相同的 CPU、内存和磁盘资源。如果不对容器使用的资源进行限制，那么容器之间会互相影响，小的来说会导致容器资源使用不公平；大的来说，可能会导致主机和集群资源耗尽，服务完全不可用。 docker 作为容器的管理者，自然提供了控制容器资源的功能。正如使用内核的 namespace 来做容器之间的隔离，docker 也是通过内核的 cgroups 来做容器的资源限制；包括CPU、内存、磁盘三大方面，基本覆盖了常见的资源配额和使用量控制。 Docker内存控制OOME在linxu系统上，如果内核探测到当前宿主机已经没有可用内存使用，那么会抛出一个OOME(Out Of Memory Exception:内存异常 )，并且会开启killing去杀掉一些进程。 一旦发生OOME，任何进程都有可能被杀死，包括docker daemon在内，为此，docker特地调整了docker daemon的OOM_Odj优先级，以免他被杀掉，但容器的优先级并未被调整。经过系统内部复制的计算后，每个系统进程都会有一个OOM_Score得分，OOM_Odj越高，得分越高，（在docker run的时候可以调整OOM_Odj）得分最高的优先被kill掉，当然，也可以指定一些特定的重要的容器禁止被OMM杀掉，在启动容器时使用 –oom-kill-disable=true指定。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:8:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Cgroup 可以使用stress工具来测试CPU和内存. ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:8:1","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"内存限制 Docker 提供的内存限制功能有以下几点： a. 容器能使用的内存和交换分区大小。 b. 容器的核心内存大小。 c. 容器虚拟内存的交换行为。 d. 容器内存的软性限制。 e. 是否杀死占用过多内存的容器。 f. 容器被杀死的优先级. 一般情况下，达到内存限制的容器过段时间后就会被系统杀死。 执行docker run命令时能使用的和内存限制相关的所有选项如下。 |选项| 描述| |–|–| |-m,–memory |内存限制，格式是数字加单位，单位可以为 b,k,m,g。最小为 4M| |–memory-swap |内存+交换分区大小总限制。格式同上。必须比-m设置的大| |–memory-reservation | 内存的软性限制。格式同上| |–oom-kill-disable |是否阻止 OOM killer 杀死容器，默认没设置| |–oom-score-adj |容器被 OOM killer 杀死的优先级，范围是[-1000, 1000]，默认为 0| |–memory-swappiness |用于设置容器的虚拟内存控制行为。值为 0~100 之间的整数| |–kernel-memory |核心内存限制。格式同上，最小为 4M | ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:8:2","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"CPU限制 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:8:3","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"磁盘IO限制 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:8:4","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"高级应用 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:9:0","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Source-To-Image (S2I) 参考s2i简介 s2i原理 s2i是红帽推出的一种基于容器的应用镜像构建工具。它需要三个元素：源码，基础镜像，构建配置。大概流程如下： (1)首先用户需要制作一个基础镜像，作为构建的基础环境，用户需要配置好相应的软件包，环境变量，等等; (2)s2i负责启动一个容器（其镜像为用户指定的基础镜像）; (3)s2i将源码拉取到容器中的/tmp/src目录下，然后读取s2i的配置信息进行源码编译及安装配置; (4)s2i将编译好的容器提交成新的镜像. ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/:9:1","tags":["Docker","运维"],"title":"Docker笔记","uri":"/post/%E8%BF%90%E7%BB%B4-5-docker%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"1. 思想 容器间通讯，使用docker内部网络，最好不要映射出来再调用，会有坑。 默认情况下，Compose会为我们的应用创建一个网络，服务的每个容器都会加入该网络中。这样，容器就可被该网络中的其他容器访问，不仅如此，该容器还能以服务名称作为hostname被其他容器访问。默认情况下，应用程序的网络名称基于Compose的工程名称，而项目名称基于docker-compose.yml所在目录的名称(例如:app_default)。如需修改工程名称，可使用–project-name标识或COMPOSE_PORJECT_NAME环境变量。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:1:0","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"2. 命令 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:2:0","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"3. 配置 docker-compose.yml ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:3:0","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"3.1. version version: '3.7' ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:3:1","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"3.2. services: [server name]: // 每个服务为一条 [配置选项] 配置选项，如下。 3.2.1. build build:context:.dockerfile:Dockerfile 3.2.2. command 覆盖默认命令。 3.2.3. depends_on 用于指定服务依赖，一般是mysql、redis等。 指定了依赖，将会优先于服务创建并启动依赖，也可以使用容器名作为主机名。 3.2.4. deploy Version 3 only. 用来配置服务运行和部署时的参数。 注：This only takes effect when deploying to a swarm with docker stack deploy, and is ignored by docker-compose up and docker-compose run. 3.2.5. entrypoint 覆盖默认entrypoint 3.2.6. environment 设置环境变量 environment: RACK_ENV: development SESSION_SECRET: # 只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据 environment: - RACK_ENV=development - SESSION_SECRET 3.2.7. env_file 从文件中获取变量 如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则以后者为准。 env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 # common.env: Set Rails/Rack environment RACK_ENV=development 3.2.8. external_links 链接到 docker-compose.yml 外部的容器，甚至 并非 Compose 管理的容器。参数格式跟 links 类似。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql 3.2.9. healthcheck HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。 而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。 当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 因此我们需要使用 HEALTHCHECK 从应用的业务层面检查容器的状态。 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:9000/minio/health/live\"] interval: 30s # 两次健康检查的间隔，默认为 30 秒，单位(h/m/s)； timeout: 20s # 健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒，单位(h/m/s)； retries: 3 # 当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 3.2.10. hostname 通过指定hostname，/etc/hosts中的记录，不再是hash值，而是hostname。 3.2.11. image 3.2.12. links 允许在连接其他服务时定义别名。 注意：They are not required to enable services to communicate - by default, any service can reach any other service at that service’s name. links: - db - db:mysql - redis # 使用了别名将自动会在容器的/etc/hosts文件里创建相应记录： 172.17.2.186 db 172.17.2.186 mysql 172.17.2.187 redis # 所以我们在容器里就可以直接使用别名作为服务的主机名。 link指定的服务名，必须在此compose配置文件中定义。ERROR: Service 'nginx_fe' has a link to service 'dc_api:gym_dc_api' which is undefined. 3.2.13. networks 指定加入的网络. 3.2.14. volumes 将本机的文件夹挂载到container中. 注：此时可能会出现，此文件夹的所有者和组都为1000. 3.2.15. user 指定用户。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:3:2","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"3.3. networks 配置集群的网络。 3.3.1. 配置默认网络 default默认网络，compose启动就会创建。 networks: default: # Use a custom driver driver: custom-driver-1 # host, bridge, overlay 3.3.2. 增加新的网络进行网络隔离 networks: [定义不是default的名称，即创建一个新的网络，default依然存在] 3.3.3. 使用已存在的网络 networks: default: external: name: my-pre-existing-network 3.3.4. 通过上边的组合可以将不同docker-compose中的服务放进一个网络中 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:3:3","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"3.4. volumes 3.4.1. 非service中volumes（即namedvolumes） volumes:[named volumes]:external:name:actual-name-of-volume#表示使用外部创建的卷 冒号后边为空。会默认挂载在/var/lib/docker/volumes/。但是后边不能跟主机路径 不能指定主机本地路径。 3.4.2. service中的volumes volumes:# Just specify a path and let the Engine create a volume- /var/lib/mysql# 使用绝对路径- /opt/data:/var/lib/mysql# 相对于the Compose file的相对路径- ./cache:/tmp/cache# User-relative path- ~/configs:/etc/configs/:ro# 命名过的卷- datavolume:/var/lib/mysql ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/:3:4","tags":["Docker，运维"],"title":"Docker-compose编排容器","uri":"/post/%E8%BF%90%E7%BB%B4-6-docker-compose%E7%BC%96%E6%8E%92%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"内存 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-01-%E7%A1%AC%E4%BB%B6/:1:0","tags":null,"title":"服务器硬件","uri":"/post/%E8%BF%90%E7%BB%B4-01-%E7%A1%AC%E4%BB%B6/"},{"categories":null,"content":"内存颗粒 DDR内存的颗粒为长方形； DDR2和DDR3内存的颗粒为正方形,而且体积大约只有DDR内存颗粒的三分之一。 项目 DDR DDR2 普通DDR3 普通DDR4 SO-DIMM DDR3 SO-DIMM DDR4 驱动电压VDD/VDDQ 2.5V/2.5V 1.8V/1.8V(±0.1) 1.5V/1.5V(±0.075) 1.2V 引脚标准 184Pin(52+40)x2 240Pin(64+56)x2 240Pin(72+48)x2 284Pin 204Pin 256Pin ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-01-%E7%A1%AC%E4%BB%B6/:1:1","tags":null,"title":"服务器硬件","uri":"/post/%E8%BF%90%E7%BB%B4-01-%E7%A1%AC%E4%BB%B6/"},{"categories":["运维"],"content":"Ubuntu服务系统","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"1. U盘安装 windows 7以上系统； 下载Rufus; 下载Ubuntu server镜像； 使用Rufus制作启动U盘； U盘启动即可安装。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:1:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"2. 文件系统 根目录 一级子目录 二级子目录 描述 /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录 /include 用户安装的lib库的头文件都在这里 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:2:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3. 系统管理 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.1. SHELL终端 3.1.1. SH 3.1.2. BASH bash shell的命令分为两类：外部命令和内部命令。外部命令是通过系统调用或独立的程序实现的，如sed、awk等等。内部命令是由特殊的文件格式(.def)所实现，如cd、history、exec等等。 fork是linux的系统调用，用来创建子进程(child process)。子进程是父进程(parent process)的一个副本，从父进程那里获得一定的资源分配以及继承父进程的环境。子进程与父进程唯一不同的地方在于pid(process id)。 环境变量只能单向从父进程传给子进程。不管子进程的环境变量如何变化，都不会影响父进程的环境变量。 exec命令不产生新的子进程。在执行时会把当前的shell process关闭，然后换到后面的命令继续执行。PID不变。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:1","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.2. PATH 普通用户使用$PATH； 使用sudo去执行一个程序时，出于安全的考虑，这个程序将在新的、最小化的环境中执行。也就是说，诸如PATH这样的环境变量，在sudo命令下已经被重置成默认的状态了。所以当一个刚初始化的PATH变量中不会包含你所要运行的程序所在的目录，用sudo去执行，你就会得到“command not found”的错误。 要改变PATH在sudo会话中的初始值，打开/etc/sudoers文件，找到“secure_path”一行。当值执行sudo命令时，”secure_path“中包含的路径将被当做默认PATH变量使用。比如加入/usr/local/bin到其中： Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin 更改会即可生效。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:2","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.3. systemctl Systemctl是一个systemd(系统初始化程序，系统开始的第一个进程，pid为1)工具，主要负责控制systemd系统和服务管理器。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:3","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.4. iostat 查看磁盘IO avg-cpu：为总体CPU使用统计情况，对于多核CPU，这里为所有CPU的平均值;主要看iowait的值，它指示CPU用于等待io请求完成的时间。 Device：为各磁盘设备的io统计信息。 Device中各列含义: a. Device：设备名称 b. tps：每秒进程下发的IO读、写请求数量 c. Blk_read/s：每秒读扇区数量（一扇区为512bytes） d. Blk_wrtn/s：每秒写扇区数量 e. Blk_read：取样时间间隔内读扇区总数量 f. Blk_wrtn：取样时间间隔内写扇区总数量 iostat 1 3表示每隔1秒打印1次，共打印3次。iostat命令还有一个非常实用的选项-x，它可以显示更多的信息，也是一个最常用的选项. -d选项可以把CPU相关信息过滤掉，只显示磁盘相关信息: rrqm/s：每秒对该设备的读请求被合并次数，文件系统会对读取同块（block）的请求进行合并。 wrqm/s：每秒对该设备的写请求被合并次数。 r/s：每秒完成的读次数。 w/s：每秒完成的写次数。 rkB/s：每秒读数据量（kB为单位）。 wkB/s：每秒写数据量（kB为单位）。 avgrq-sz：平均每次IO操作的数据量（扇区数为单位）。 avgqu-sz：平均等待处理的IO请求队列长度。 await：平均每次IO请求等待时间（包括等待时间和处理时间，毫秒为单位）。 svctm：平均每次IO请求的处理时间（毫秒为单位）。 %util：采用周期内用于IO操作的时间比率，即IO队列非空的时间比率。 最应该关注的是%util，磁盘使用率100%，其实就是%util的值为100%。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:4","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.5. iotop 查看哪个进程磁盘读写最高 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:5","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.6. netstat -t –tcp -l –listening ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:6","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.7. lsof 列出打开文件，在linux中一切皆文件 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:7","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.8. nc 验证网络连接. ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:8","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.9. 为网络连接设置文件描述符 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:9","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.10. 包管理 优先snap包管理器。 系统中最好安装有一个版本的docker。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:10","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.11. STRACE strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。 root@ubuntu:/usr# strace cat /dev/null execve(\"/bin/cat\", [\"cat\", \"/dev/null\"], [/* 22 vars */]) = 0 brk(0) = 0xab1000 access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory) mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000 access(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory) ... brk(0) = 0xab1000 brk(0xad2000) = 0xad2000 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 open(\"/dev/null\", O_RDONLY) = 3 fstat(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0 read(3, \"\", 32768) = 0 close(3) = 0 close(1) = 0 close(2) = 0 exit_group(0) = ? 每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:11","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.12. Command xargs Linux xargs 命令 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:12","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.13. shell脚本 在脚本中使用export设置环境变量，./之后没有生效。原因是执行脚本用./test.sh的方式，如果采用source test.sh，则环境变量会生效。 直接执行一个脚本文件是在一个子shell中运行的，而source则是在当前shell环境中运行的。 #! /bin/zsh function mimvp_randnum_uuid(){ min=$1 max=$2 mid=$(($max-$min+1)) num=$(head -n 20 /proc/sys/kernel/random/uuid | cksum | cut -f1 -d ' ') randnum=$(($num%$mid+$min)) echo $randnum } function print_randnum_uuid(){ for i in {1..50}; do randnum=$(mimvp_randnum_uuid 40000000 50000000) #echo -e \"$i \\t $randnum\" echo $randnum done } print_randnum_uuid ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:13","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.14. 定时任务 参考Ubuntu 16.04设置crontab定时计划任务 参考每天一个linux命令（50）：crontab命令 crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具（如果使用的容器镜像，可能被裁减），并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 Linux下的任务调度分为两类，系统任务调度和用户任务调度。 在/etc/crontab文件，是系统任务调度的配置文件。 用户任务调度：用户定期要执行的工作。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron/crontabs目录中。其文件名与用户名一致。 3.14.1. crontab命令 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:14","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"3.15. 系统日志 3.15.1. rsyslog 日志收集 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:3:15","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4. SSH访问 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.1. 常用操作 上传目录到服务器 scp -r /tmp/local_dir username@servername:remote_dir 免密登录 #客户端配置 ssh-keygen -t rsa //（会有提示输入密码，直接回车即可） # 之后会在家目录下建立 .ssh 文件夹，内有id_rsa（私钥）和id_rsa.pub（公钥）两个文件 # 将公钥文件上传到服务器上server的家目录 scp ~/.ssh/id_rsa.pub server@192.168.0.10:~ # 服务器端配置 # 使用server用户登录并进入家目录 # cd /home/server # 建立 .ssh 文件夹 mkdir .ssh; # 修改文件夹权限【Ubuntu和Centos一样】 chmod 700 .ssh # 将客户端传过来的id_rsa.pub文件中的内容加入到authorized_keys中 cat id_rsa.pub \u003e\u003e .ssh/authorized_keys chmod 644 .ssh/authorized_keys 【Ubuntu和Centos不一样】 #之后你从客户端使用 client 用户登录服务器的server用户时就不需要再输入密码了，但是第一次连接时还是会提示你进行远程主机公钥指纹核对并将其存入 ~/.ssh/known_hosts 文件。 免密登录之后，还需要输入密码： 【Centos】 首先我们就要去查看系统的日志文件 tail /var/log/secure -n 20 【tail /var/log/auth.log】 发现问题的所在：Authentication refused: bad ownership or modes for file 从字面上可以看出是目录的属主和权限配置不当，查找资料得知：SSH不希望home目录和~/.ssh目录对组有写权限，通过下面几条命令改下 chmod g-w /home/zhangming chmod 700 /home/zhangming/.ssh chmod 600 /home/zhangming/.ssh/authorized_keys 多个私钥 临时生效 ssh-agent bash # ssh-add 私钥名称 ssh-add id_rsa 修改配置文件 cd ~/.ssh touch config chmod 600 ~/.ssh/config #主机服务器 , Host 别名 HostName 填入云服务器ip Port 22 User 用户名 IdentityFile ~/.ssh/私钥文件名 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:1","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.2. 修改SSH默认端口（安全第一步） 备份原sshd配置文件cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup 修改sshd_config文件，打开port 22,再新增一个Port，保存。 重启sshd服务，systemctl restart sshd或/etc/init.d/sshd restart或/etc/init.d/ssh restart。ss -ntl 或 netstat -ntl 查看一下端口。 防火墙（iptables）、安全组（ECS）规则设置。 -A INPUT -m state --state NEW -m tcp -p tcp --dport 60022 -j ACCEPT $ systemctl restart iptables.service $ systemctl restart sshd.service ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:2","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.3. 增加系统管理员（非超级管理员）用户（安全第二步） 添加新用户sudo useradd mangues useradd与adduser都是创建新的用户 1、useradd在使用该命令创建用户是不会在/home下自动创建与用户名同名的用户目录，而且不会自动选择shell版本，也没有设置密码，那么这个用户是不能登录的，需要使用passwd命令修改密码。 2、adduser在使用该命令创建用户是会在/home下自动创建与用户名同名的用户目录，系统shell版本，会在创建时会提示输入密码，更加友好。 ———————————————— 版权声明：本文为CSDN博主「mangues」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u012915455/java/article/details/80080005 修改ssh配置sudo vim /etc/ssh/sshd_config。 AllowUsers mangues mangues@192.168.0.1 //允许 mangues 和从 192.168.0.1 登录的 mangues 帐户通过 SSH 登录系统。 DenyUsers mangues // 黑名单 /etc/hosts.allow和/etc/hosts.deny这两个文件。 将用户放进sudoers中，sudo usermod -a -G sudo hduser和sudo adduser ostechnix sudo。 移除用户的sudo权限，sudo deluser ostechnix sudo。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:3","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.4. 查看上方使用私钥登录，取消密码登录（安全第三步） 在/etc/ssh/sshd_config配置文件中设置以下参数PasswordAuthentication no。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:4","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.5. 禁止root用户直接登录ssh（安全第四步） 在/etc/ssh/sshd_config配置文件中设置以下参数PermitRootLogin no。 禁用 root 用户远程登录, root登录时可能报用户名或者密码错误。如果您需要使用root进行远程登录, 需要通过其他方式(如vnc)连接到服务器. ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:5","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.6. ssh隧道 ssh -Nfg -L [本地主机]:[本地端口]:[目标机地址]:[目标机端口] [中间机IP] 这里我们用到了SSH客户端的三个参数，下面我们一一做出解释： -N 告诉SSH客户端，这个连接不需要执行任何命令，仅仅做端口转发 -f 告诉SSH客户端在后台运行 -L 做本地映射端口 -g 指定该选项表示允许外界主机连接本地转发端口 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:6","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"4.7. 连接问题排查方法 1. 停止sshd服务 service sshd stop 2. 前台运行sshd,可以看到连接时的打印信息 /usr/sbin/sshd -d ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:4:7","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"5. windows下工具 cmder类linux终端，支持很多linux命令 putty小而美 注：putty支持putty私钥，不支持openssh密钥，需要转换。Unable to use key file “xxx” (OpenSSH SSH-2 private key) ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:5:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"5.1. webshell huashengdun/webssh功能较简单; liftoff/GateOne功能强大，代码也很大。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:5:1","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"5.2. HAProxy 让一个端口同时做两件事：http/https和ssh ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:5:2","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"6. 系统管理工具 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:6:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"6.1. webmin ubuntu上下载deb文件之后，直接安装即开始运行，可以通过https://localhost:10000访问。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:6:1","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"7. 常用工具 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:7:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"7.1. envsubst 将环境变量传递给文件 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:7:1","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["运维"],"content":"8. 常见问题 ubuntu-18.04 设置开机启动脚本 Ubuntu 18.04 Server 设置静态IP Ubuntu 16.04 DNS 修改 /etc/resolv.conf 被清空 或重启不生效解决 Ubuntu 18.04设置dns [Ubuntu安装软件出现依赖问题]一般是由于依赖老版本，但是已经安装了新版本，此时可以使用apitude工具，不接受推荐，使用降低版本。 ","date":"2019-01-23","objectID":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/:8:0","tags":["运维"],"title":"Ubuntu服务器系统及基础设施","uri":"/post/%E8%BF%90%E7%BB%B4-02-%E7%B3%BB%E7%BB%9F-ubuntu/"},{"categories":["PROGRAM"],"content":"1. 面向对象 参考 面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 注:对ORM中的model就可以看做一个对象，可以定义丰富的方法。 ","date":"2019-01-22","objectID":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["PROGRAM","PYTHON"],"title":"Python-面向对象","uri":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.1. 类和实例 面向对象最重要的概念就是类（Class）和实例（Instance），类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 1.1.1. 类属性 直接在class中定义属性，这种属性是类属性，这个属性虽然归类所有，但类的所有实例都可以访问到，但是不能修改，只能类名.属性进行修改。 1.1.2. 实例属性 在类方法中定义的属性为实例属性，各个实例相互独立。 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 通过方法访问私有变量，可以对参数做检查，避免传入无效的参数。 变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。 1.1.3. 动态绑定属性和方法 正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。 \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.name = 'Michael' # 动态给实例绑定一个属性 \u003e\u003e\u003e def set_age(self, age): # 定义一个函数作为实例方法 ... self.age = age ... \u003e\u003e\u003e from types import MethodType \u003e\u003e\u003e s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 为了给所有实例都绑定方法，可以给class绑定方法： \u003e\u003e\u003e def set_score(self, score): ... self.score = score ... \u003e\u003e\u003e Student.set_score = set_score 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性： class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 1.1.4. 使用@property Python内置的@property装饰器就是负责把一个方法变成属性调用的。 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value \u003c 0 or value \u003e 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作. 1.1.5. 定制类(特殊属性) 1.1.5.1. __call__ 对象可call，注意不是类，是对象 对象通过提供__call__(self, [,*args [,**kwargs]])方法可以模拟函数的行为，如果一个对象x提供了该方法，就可以像函数一样使用它，也就是说x(arg1, arg2…) 等同于调用x.__call__(self, arg1, arg2) 。模拟函数的对象可以用于创建防函数(functor) 或代理(proxy) 1.1.5.2. __dict__ 包含这个对象的所有属性; 不是所有的对象都有 dict 属性。例如，如果你在一个类中添加了 slots 属性，那么这个类的实例将不会拥有 dict 属性，但是 dir() 仍然可以找到并列出它的实例所有有效属性。 同理许多内建类型都没有 dict 属性，例如 list 没有 dict 属性，但你仍然可以通过 dir() 列出 list 所有的属性。 1.1.5.3. __enter__ 1.1.5.4. __exit__ 在__exit__中返回True,则不会产生异常. 在__init__或者__enter__中抛出异常，则不会进入到__exit__中 1.1.5.5. __getattr__ 只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。 利用完全动态的__getattr__，我们可以写出一个链式调用： class Chain(object): def __init__(self, path=''): self._path = path def __getattr__(self, path): return Chain('%s/%s' % (self._path, path)) def __str__(self): return self._path __repr__ = __str__ 试试： \u003e\u003e\u003e Chain().status.user.timeline.list '/status/user/timeline/list' 1.1.5.6. __getitem__ Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素： \u003e\u003e\u003e Fib()[5] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: 'Fib' object does not support indexing 要表现得像list那样按照下标取出元素，需要实现__getitem__()方法： class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a 现在，就可以按下标访问数列的任意一项了： \u003e\u003e\u003e f = Fib() \u003e\u003e\u003e f[0] 1 \u003e\u003e\u003e f[1] 1 \u003e\u003e\u003e f[2] 2 \u003e\u003e\u003e f[3] 3 \u003e\u003e\u003e f[10] 89 \u003e\u003e\u003e f[100] 573147844013817084101 但是list有个神奇的切片方法： \u003e\u003e\u003e list(range(100))[5:10] [5, 6, 7, 8, 9] 对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断： class Fib(object): def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x \u003e= start: L.append(a) a, b = b, a + b return L 现在试试Fib的切片： \u003e\u003e\u003e f = Fib() \u003e\u003e\u003e f[0:5] [1, 1, 2, 3, 5] \u003e\u003e\u003e f[:10] [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 但是没有对step参数作处理： \u003e\u003e\u003e f[:10:2] [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] 也没有对负数作处理，所以，要正确实现一个__getitem__()还是有很多工作要做的。 此外，如果把对象看成dict，getitem()的参数也可能是一个可以作key的object，例如str。 与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。 总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。 1.1.5.7. __init__ 对象的初始化， 是一个实例方法，第一个参数是self。 1.1.5.8. _","date":"2019-01-22","objectID":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:1","tags":["PROGRAM","PYTHON"],"title":"Python-面向对象","uri":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.2. 继承 通过多重继承，一个子类就可以同时获得多个父类的所有功能。 class Bat(Mammal, Flyable): pass def __init__(self): super().__init__() 这种设计通常称之为MixIn。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 所有类都继承object. 【注】派生类重新定义__init__()之后，需要显式地调用父类的__init__()函数,否则会出现raise RuntimeError(\"thread.__init__() not called\")。 1.2.1. 相关的方法 type() isinstance() ","date":"2019-01-22","objectID":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:2","tags":["PROGRAM","PYTHON"],"title":"Python-面向对象","uri":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.3. 多态 ","date":"2019-01-22","objectID":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:3","tags":["PROGRAM","PYTHON"],"title":"Python-面向对象","uri":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["PROGRAM"],"content":"1.4. with 在python中实现了 __enter__ 和__exit__方法，即支持上下文管理器协议. 当with语句在开始运行时，会在上下文管理器对象上调用 __enter__ 方法。with语句运行结束后，会在上下文管理器对象上调用 __exit__ 方法 class TmpTest: def __init__(self,filename): self.filename=filename def __enter__(self): self.f = open(self.filename, 'r') return self.f def __exit__(self, exc_type, exc_val, exc_tb): self.f.close() test=TmpTest('file') with test as t: print ('test result: {}'.format(t)) ","date":"2019-01-22","objectID":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:4","tags":["PROGRAM","PYTHON"],"title":"Python-面向对象","uri":"/post/program-python-05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"解决问题：微服务之间以及你的应用和微服务之间是怎么信任对方的？ 参考理解OAuth 2.0 参考OAuth2.0 原理流程及其单点登录和权限控制 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:0:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"概念 认证(authentication)和授权(authorization)。这是两个不同的概念，通俗点讲，认证是指系统需要确认你是谁，而授权是指在通过认证之后，你能干什么。 第三方应用程序(Third-party application):即需要访问用户在HTTP服务中的资源,下文又称'客户端’； HTTP服务提供商(HTTP service); 资源所有者(Resource Owner):即HTTP服务的用户; 用户代理(User Agent):例浏览器； 认证服务器(Authorization server):即服务提供商专门用来处理认证的服务器; 资源服务器(Resource server):即服务提供商存放用户生成的资源的服务器;它与认证服务器，可以是同一台服务器，也可以是不同的服务器. ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:1:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"认证 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"Http Basic认证 将用户名密码按照格式\"用户名:密码\"通过Base-64编码成一个hash值，然后通过Authorization header传递到服务端，然后服务端再通过同样的Base-64编码方式进行解码成为\"用户名:密码\"格式进行认证。 容易被破解，结合Https使用。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:1","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"Http Digest认证 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:2","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"Cookies \u0026 Session 一般采用Token。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:3","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"授权 在微服务架构中，一般都需要有自己的一个授权服务器，它的作用主要是分发token给不同的调用方，然后它们可以使用这个token去访问相应的微服务。 可以把授权服务器看成是提供一组REST API的service： 授权API(/oauth/authorize) - 这个API会对调用方请求进行授权，返回一个authorization code。 获取Token API(/oauth/token) - 这个API会根据客户请求传入的authorization code来生成一个access token并返回。 校验Token API(/oauth/introspect) - 这个API一般会是resource server用来校验请求方的access token是否有效。 撤销Token API(/oauth/revoke) - 这个API 会把access token直接撤销。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:3:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"单点登录 单点登录是多域名企业站点流行的登录方式。 传统的多点登录系统中，每个站点都实现了本站专用的帐号数据库和登录模块。各站点的登录状态相互不认可，各站点需要逐一手工登录。 单点登录，英文是 Single Sign On，缩写为 SSO。多个站点共用一台认证授权服务器(用户数据库和认证授权模块共用)。用户经由其中任何一个站点登录后，可以免登录访问其他所有站点。而且，各站点间可以通过该登录状态直接交互。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:4:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"OAuth2 OAuth的作用既可以满足微服务架构中服务的统一认证和授权，也可以让\"第三方应用程序\"安全可控地获取\"资源所有者\"的授权，与\"服务商提供商\"进行互动。 OAuth在\"客户端\"与\"服务提供商\"之间，设置了一个授权层（authorization layer）。“客户端\"不能直接登录\"服务提供商”，只能登录授权层，以此将用户与客户端区分开来。“客户端\"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。“客户端\"登录授权层以后，“服务提供商\"根据令牌的权限范围和有效期，向\"客户端\"开放用户储存的资料。 资源服务器也要会判断认证服务器给的Token的有效性，可以通过共享数据库 OAuth2中文文档 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:5:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"流程 A. 用户打开客户端以后，客户端要求用户给予授权。 B. 用户同意给予客户端授权。 C. 客户端使用上一步获得的授权，向认证服务器申请令牌。 D. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 E. 客户端使用令牌，向资源服务器申请获取资源。 F. 资源服务器确认令牌无误，同意向客户端开放资源。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:5:1","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"授权方式 授权码方式 授权码方式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与\"服务提供商\"的认证服务器进行互动。 （A）用户访问客户端，后者将前者导向认证服务器。 （B）用户选择是否给予客户端授权。 （C）假设用户给予授权，认证服务器将用户导向客户端事先指定的\"重定向URI”（redirection URI），同时附上一个授权码。 （D）客户端收到授权码，附上早先的\"重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。 （E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 简化方式 简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了\"授权码\"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 （A）客户端将用户导向认证服务器。 （B）用户决定是否给于客户端授权。 （C）假设用户给予授权，认证服务器将用户导向客户端指定的\"重定向URI”，并在URI的Hash部分包含了访问令牌。 （D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。 （E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。 （F）浏览器执行上一步获得的脚本，提取出令牌。 （G）浏览器将令牌发给客户端。 用在移动app或者web app(这些app是在用户的设备上的，如在手机上调起微信来进行认证授权)。 密码模式 密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向\"服务商提供商\"索要授权。 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。 （A）用户向客户端提供用户名和密码。 （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。 （C）认证服务器确认无误后，向客户端提供访问令牌。 客户端模式 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向\"服务提供商\"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求\"服务提供商\"提供服务，其实不存在授权问题。 （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。 （B）认证服务器确认无误后，向客户端提供访问令牌。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:5:2","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"更新令牌 如果用户访问的时候，客户端的\"访问令牌\"已经过期，则需要使用\"更新令牌\"申请一个新的访问令牌。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:5:3","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"实现 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:6:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"Python Flask–搭建OAuth2.0认证服务器（一） Flask–搭建OAuth2.0认证服务器（二） 使用Python实现OAuth2.0认证服务器 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:6:1","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"Java 大多数情况下我们都需要实现自己的authentication server，好在spring 框架提供了一个基于spring security 的oauth框架来帮助实现对应的authentication server, resource server 以及client。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:6:2","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"javascript 参考oauthjs/node-oauth2-server。 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:6:3","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"案例分析 参考github的oauth登陆系列之注册appkey 参考github的oauth登陆的基本流程，oauth2.0原理解析 ","date":"2019-01-21","objectID":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:7:0","tags":["微服务","架构"],"title":"微服务架构笔记(1)认证和授权","uri":"/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0-01-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":null,"content":"矩阵向量 ","date":"2019-01-19","objectID":"/post/%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95-1/:1:0","tags":["算法"],"title":"算法(一)","uri":"/post/%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95-1/"},{"categories":null,"content":"向量积 a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。） 假设屏幕坐标系x向右，y向上，那么叉乘方向朝向本人。叉乘的结果是正数，说明a到b是逆时针，反之顺时针；若是0，则说明a，b共线。 a=[a1，a2，a3]=a1i+a2j+a3k； b=[b1，b2，b3]=b1i+b2j+b3k； 则a×b=[a2b3-a3b2，a3b1-a1b3，a1b2-a2b1]。 ","date":"2019-01-19","objectID":"/post/%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95-1/:1:1","tags":["算法"],"title":"算法(一)","uri":"/post/%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95-1/"},{"categories":null,"content":"JS插件","date":"2019-01-19","objectID":"/post/js-html%E5%AF%B9%E8%B1%A1/","tags":["前端","JS"],"title":"JS笔记","uri":"/post/js-html%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"CANVAS 使用实时凸包算法实现 ","date":"2019-01-19","objectID":"/post/js-html%E5%AF%B9%E8%B1%A1/:0:0","tags":["前端","JS"],"title":"JS笔记","uri":"/post/js-html%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"规范 JavaScript Standard Style ","date":"2019-01-19","objectID":"/post/js-html%E5%AF%B9%E8%B1%A1/:1:0","tags":["前端","JS"],"title":"JS笔记","uri":"/post/js-html%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"插件 ","date":"2019-01-19","objectID":"/post/js-html%E5%AF%B9%E8%B1%A1/:2:0","tags":["前端","JS"],"title":"JS笔记","uri":"/post/js-html%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"Velocity.js Velocity.js是一款动画切换插件，它重新实现了jQuery的$.animate()方法，并且你无须引入JQuery。它比JQuery更快，并实现了变色动画，形变，循环，擦除和SVG支持以及滚动。它是jQuery和CSS变换 的最佳组合。 Velocity 接收一组 css 属性键值对 (css map) 作为它的第一个参数，该参数作为动画效果的最终属性。第二个参数是可选参数 为动画的额外配置项 // 当使用jQuery时，Velocity和jQuery的animate()用法类似 $(\"#test\").velocity({ left: \"200px\" }, { duration: 450, delay: 300 }); 动画配置项 duration: 400, // 动画执行时间 easing: “swing”, // 缓动效果 queue: “\", // 队列 begin: undefined, // 动画开始时的回调函数 progress: undefined, // 动画执行中的回调函数（该函数会随着动画执行被不断触发） complete: undefined, // 动画结束时的回调函数 display: undefined, // 动画结束时设置元素的 css display 属性 visibility: undefined, // 动画结束时设置元素的 css visibility 属性 loop: false, // 循环 delay: false, // 延迟 mobileHA: true // 移动端硬件加速（默认开启） ","date":"2019-01-19","objectID":"/post/js-html%E5%AF%B9%E8%B1%A1/:2:1","tags":["前端","JS"],"title":"JS笔记","uri":"/post/js-html%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"Jquery $方法：$就是jquery对象，$()就是jQuery()，在里面可以传参数，作用就是获取元素 $(\".div1\") 表示获取类名为div1的元素，例如获取\u003cdiv class=\"div1\"\u003e\u003c/div\u003e $(\".div1\").onclick表示类名为div1的div点击事件 jquery中$.，例如$.post()，$.get()，$.ajax()等这些都是jquery这个对象的方法 语句 功能 $(document).ready(function(){}) 必须等到页面内包括图片的所有元素加载完毕后才能执行 $(window).ready() DOM结构绘制完毕后就执行，不必等到加载完毕 JQ $.ajax和$.getJson同步异步切换 ","date":"2019-01-19","objectID":"/post/js-html%E5%AF%B9%E8%B1%A1/:2:2","tags":["前端","JS"],"title":"JS笔记","uri":"/post/js-html%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"变量、函数、对象、方法","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"变量 $在js并不是特殊的存在，在Jquery中有$函数。一般地，在开发js脚本，而框架中必然要定义一些变量，而你又不希望用你脚本的人在定义变量的时候与你的变量重名，导致脚本中的变量被覆盖，这时，就可以使用$符号来进行标记一下哪些是你的脚本中的变量。 this指的是调用函数的那个对象，就是函数运行时所在的环境对象。 a. 全局对象; b. 函数作为某个对象的方法调用，这时this就指这个上级对象； c. 作为构造函数调用:通过这个函数，可以生成一个新对象。这时，this就指这个新对象，如new function()； d. apply 调用:apply()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。apply()的参数为空时，默认调用全局对象。 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:1:0","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"语法 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:2:0","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"Throw 和 Try to Catch try 语句使您能够测试代码块中的错误。 catch 语句允许您处理错误。 throw 语句允许您创建自定义错误。 finally 使您能够执行代码，在 try 和 catch 之后，无论结果如何。 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:2:1","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"ES6中的class和static 类就是实例的原型，new一个类,在类中定义的方法，都会被实例继承；如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 父类的静态方法，可以被子类继承，super也可以调用。 JavaScript语言的传统方法是通过构造函数（属性在构造函数中定义）,定义并生成新对象,prototype 属性使您有能力向对象添加属性和方法（实例都会有这个属性和方法）（构造器生成的实例.没有prototype属性）。 定义“类”的方法的时候,前面不需要加上function这个关键字,直接把函数定义放进去了就可以了。方法之间不需要逗号分隔,加了会报错。 console.log(typeof Person);//function console.log(Person === Person.prototype.constructor);//true 类的数据类型就是函数,类本身就指向构造函数。 类的所有方法都定义在类的prototype属性上面,可以通过prototype覆盖方法或者添加方法。 在类的实例上面调用方法，其实就是调用原型上的方法。 ES6 明确规定， Class 内部只有静态方法， 没有静态属性但是ES7有了静态属性。 定义实例属性， 只能写在类的constructor方法里面（使用this）或者function定义中（使用this）或者使用prototype属性。 Object.keys（obj），返回一个数组，数组里是`该obj（实例）可被枚举的所有属性(不包括原型中的属性)`，但是for...in可以包含原型链中的可枚举属性。 Object.getOwnPropertyNames(obj)，返回一个数组，数组里是该obj上所有的实例属性。 非Object都是实例，JS中的对象也是实例。 constructor方法是类的构造函数是默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个默认的constructor方法会被添加。所以即使你没有添加构造函数,也是有默认的构造函数的。一般constructor方法默认返回实例对象this，但是也可以指定constructor方法返回一个全新的对象,让返回的实例对象不是该类的实例。 类的构造函数，不使用new是没法调用的,即使你使用实例对象去调用也是不行的,这是它跟普通构造函数的一个主要区别。 可以通过实例的__proto__属性为Class添加方法。 这个类的名字是Expression而不是Expre，Expre只在Class的内部代码可用，指代当前类。 const Expression = class Expre{ static getAge(){ return '12'; } getClassName(){ return \" ClassName1= \" +Expre.name + \" ClassName2= \" +Expression.name; } }; ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:2:2","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"可枚举属性和不可枚举属性 对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的。可枚举性决定了这个属性能否被for…in查找遍历到。 js中基本包装类型的原型属性是不可枚举的，如Object, Array, Number等. 对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false。 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:2:3","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"函数（自定义） ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:3:0","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"异步编程的解决方案 回调函数 function f1(callback){ setTimeout(function () { // f1的任务代码 callback(); }, 1000); } f1(f2); 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听 JQUERY的写法 f1.on('done', f2); function f1(){ setTimeout(function () { // f1的任务代码 f1.trigger('done'); }, 1000); } 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\"去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布和订阅 我们假定，存在一个\"信号中心”，某个任务执行完成，就向信号中心\"发布”（publish）一个信号，其他任务可以向信号中心\"订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\"发布/订阅模式”（publish-subscribe pattern），又称\"观察者模式”（observer pattern）。 这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。 jQuery.subscribe(\"done\", f2); function f1(){ setTimeout(function () { // f1的任务代码 jQuery.publish(\"done\"); }, 1000); } jQuery.unsubscribe(\"done\", f2); // 取消订阅 这种方法的性质与\"事件监听\"类似，但是明显优于后者。因为我们可以通过查看\"消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promises对象 Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。 每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成f1().then(f2);。 jquery的实现 function f1(){ var dfd = $.Deferred(); setTimeout(function () { // f1的任务代码 dfd.resolve(); }, 500); return dfd.promise; } 优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。 指定多个回调函数：f1().then(f2).then(f3); 再比如，指定发生错误时的回调函数：f1().then(f2).fail(f3); 还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。 async 和 await async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 await 只能出现在 async 函数中。 async 函数返回的是一个 Promise。 如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。then() 链来处理这个 Promise 对象。 联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。 await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await 的优势在于处理 then 链，与promise类似。 可以使用 Promise.all 来 await 多个 async（异步）函数。 await Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) Generator co 把 Generator 和 Promise 封装，达到自动执行 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:3:1","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"默认参数 使用对象解构(destructuring)模拟命名参数. function doSomething({ foo = 'Hi', bar = 'Yo!', baz = 13 }) { // ... } function doSomething({ foo = 'Hi', bar = 'Yo!', baz = 13 } = {}) { // ... } ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:3:2","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"对象（前端） ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:4:0","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"canvas对象标示一个html画布元素 标签只有两个属性—— width和height，这两个属性是可选的。当我们没有定义时，Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，我们也可以使用HTML的高度和宽度属性来自定义尺寸。 canvas元素有两套尺寸：一个是元素本身的大小(通过CSS设置)，另一个是元素绘图表面的大小(通过canvas自身的width和height属性设置)。 注意：通过CSS修改width和height，只是改变了元素本身大小，对元素绘图表面的大小并无影响; var Canvas = document.getElementById('tutorial'); 父 子 参数 功能 备注 ctx=Canvas.getContext(contextID) ‘2d’ 返回一个用于在画布上绘图的环境 绘图参考 .strokeStyle 描述画笔（绘制图形）颜色或者样式的属性 .lineWidth .fillstyle 使用内部方式描述颜色和样式的属性。默认值是 #000 （黑色） .font 描述绘制文字时，当前字体样式的属性 .textAlign textAlign的值为center时候文本的居中是基于你在fillText的时候所给的x的值，也就是说文本一半在x的左边，一半在x的右边 .textBaseline top文本基线在文本块的顶部。hanging文本基线是悬挂基线。middle文本基线在文本块的中间。alphabetic文本基线是标准的字母基线。ideographic文字基线是表意字基线；如果字符本身超出了alphabetic 基线，那么ideograhpic基线位置在字符本身的底部。bottom文本基线在文本块的底部。 与 ideographic 基线的区别在于 ideographic 基线不需要考虑下行字母。默认值是 alphabetic。 当前文本基线的属性 void ctx.clearRect(x, y, width, height) 设置指定矩形区域内（以 点 (x, y) 为起点，范围是(width, height) ）所有像素变成透明，并擦除之前绘制的所有内容的方法 void ctx.translate(x, y) 绘图原点移动 void ctx.fillRect(x, y, width, height) 绘制填充矩形的方法。矩形的起点在 (x, y) 位置，矩形的尺寸是 width 和 height ，fillStyle 属性决定矩形的样式 void ctx.scale(x, y) 根据 x 水平方向和 y 垂直方向，为canvas 单位添加缩放变换的方法 void ctx.rotate(angle) 在变换矩阵中增加旋转的方法。角度变量表示一个顺时针旋转角度并且用弧度表示。旋转中心点一直是 canvas 的起始点。 如果想改变中心点，我们可以通过 translate() 方法移动 canvas 。 beginPath() 创建一个新的路径 moveTo(x,y) 将一个新的子路径的起始点移动到(x，y)坐标的方法 lineTo(x,y) 使用直线连接子路径的终点到x，y坐标的方法（并不会真正地绘制） stroke() closePath() save() 通过将当前状态放入栈中，保存 canvas 全部状态的方法 restore() 通过在绘图状态栈中弹出顶端的状态，将 canvas 恢复到最近的保存状态的方法。 void ctx.fillText(text, x, y [, maxWidth]) 文本、x坐标，y坐标[,宽]（是字左下点的位置） 绘制文字 Canvas.height 画布的高度 Canvas.width 画布的宽度 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:4:1","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"技巧 绘制2D图形时，使用极坐标的话，可以通过旋转一定角度，那么x y坐标系跟着旋转。 案例学习 cuijing1031/Canvas-Gauge ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:4:2","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"document对象 每个载入浏览器的 HTML 文档都会成为 Document 对象。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 属性和方法 功能 备注 document.addEventListener() 用于向文档添加事件句柄 具体事件可查看html笔记中DOM事件 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:4:3","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"element对象 指定元素。 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:4:4","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"window对象 Window 对象表示浏览器中打开的窗口。 属性和方法 功能 window.requestAnimationFrame(animate) 告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 window.location.href 当前页面的路由，可以修改这个值跳转到其他页面 window.ScrollTo 当前页面滚动 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:4:5","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"内置方法 encodeURIComponent() 函数可把字符串作为URI组件进行编码，返回正常打印看不见的字符。 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:5:0","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"JavaScript中Get和Set访问器 标准用法 function Field(val){ this.value = val; } Field.prototype = { get value(){ return this._value; }, set value(val){ this._value = val; } }; var field = new Field(\"test\"); field.value=\"test2\"; //field.value will now return \"test2\" ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:5:1","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"constructor 是一种用于创建和初始化class创建的对象的特殊方法 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:5:2","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"数学计算 方法　 　功能　 parseInt　 　丢弃小数部分　 Math.ceil　 向上取整　 Math.round　 四舍五入　 Math.floor 向下取整　 % 取余　｜ ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:5:3","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"apply() 方法接受数组形式的参数 Math.max.apply(null, [1,2,3]); // 返回数组最大值 Math.min.apply(null, [1,2,3]); // 返回数组最小值 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:5:4","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:5:5","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"声明 “use strict” 的目的是指定代码在严格条件下执行,严格模式下你不能使用未声明的变量。 ","date":"2019-01-19","objectID":"/post/js-%E8%AF%AD%E6%B3%95es6/:6:0","tags":["前端","JS"],"title":"JS语法(ES6)","uri":"/post/js-%E8%AF%AD%E6%B3%95es6/"},{"categories":null,"content":"标签 换行 \u003ci\u003e 显示斜体文本效果 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-html%E7%AC%94%E8%AE%B0/:1:0","tags":["前端"],"title":"html笔记","uri":"/post/%E5%89%8D%E7%AB%AF-html%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"DOM DOM （文档对象模型）定义了访问 HTML 和 XML 文档的标准. DOM事件 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-html%E7%AC%94%E8%AE%B0/:1:1","tags":["前端"],"title":"html笔记","uri":"/post/%E5%89%8D%E7%AB%AF-html%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"设计原则 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:1:0","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector {property: value；property: value} 选择器通常是需要改变样式的 HTML 元素；每条声明由一个属性和一个值组成。 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:2:0","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"CSS定位 定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。 一切皆为框： div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。 您可以使用 display 属性改变生成的框的类型。这意味着，通过将 display 属性设置为 block，可以让行内元素（比如 \u003ca\u003e 元素）表现得像块级元素一样。还可以通过把 display 设置为 none，让生成的元素根本没有框。这样的话，该框及其所有内容就不再显示，不占用文档中的空间。 但是在一种情况下，即使没有进行显式定义，也会创建块级元素。这种情况发生在把一些文本添加到一个块级元素（比如 div）的开头。即使没有把这些文本定义为段落，它也会被当作段落对待： \u003cdiv\u003e some text \u003cp\u003eSome more text.\u003c/p\u003e \u003c/div\u003e 在这种情况下，这个框称为无名块框，因为它不与专门定义的元素相关联。 块级元素的文本行也会发生类似的情况。假设有一个包含三行文本的段落。每行文本形成一个无名框。无法直接对无名块或行框应用样式，因为没有可以应用样式的地方（注意，行框和行内框是两个概念）。但是，这有助于理解在屏幕上看到的所有东西都形成某种框。 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:2:1","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"选择器 选择器 例子 例子描述 CSS .class .intro 选择 class=\"intro” 的所有元素。 1 .class element .static h1 选择 class=\"static” 中 h1 的所有元素 element.class h1.static 选择class为static的所有h1元素 #id #firstname 选择 id=\"firstname” 的所有元素。 1 * * 选择所有元素。 2 element p 选择所有 元素。 1 element,element div,p 选择所有 元素和所有 元素 1 element element div p 选择 元素内部的所有 元素 1 element\u003eelement div\u003ep 选择父元素为 元素的所有 元素 2 element+element div+p 选择紧接在 元素之后的所有 元素 2 [attribute] [target] 选择带有 target 属性所有元素。 2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [attribute =value] [lang =en] 选择 lang 属性值以 “en” 开头的所有元素。 2 :link a:link 选择所有未被访问的链接。 1 :visited a:visited 选择所有已被访问的链接。 1 :active a:active 选择活动链接。 1 :hover a:hover 选择鼠标指针位于其上的链接。 1 :focus input:focus 选择获得焦点的 input 元素。 2 :first-letter p:first-letter 选择每个 元素的首字母。 1 :first-line p:first-line 选择每个 元素的首行。 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 元素。 2 :before p:before 在每个 元素的内容之前插入内容。 2 :after p:after 在每个 元素的内容之后插入内容。 2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 元素。 2 element1~element2 p~ul 选择前面有 元素的每个 元素。 3 [attribute^=value] a[src^=\"https”] 选择其 src 属性值以 “https” 开头的每个 元素。 3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 元素。 3 [attribute*=value] a[src*=\"abc”] 选择其 src 属性中包含 “abc” 子串的每个 元素。 3 :first-of-type p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 3 :last-of-type p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 3 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 元素。 3 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 3 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 元素的每个 元素。 3 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 元素。 3 :root :root 选择文档的根元素。 3 :empty p:empty 选择没有子元素的每个 元素（包括文本节点）。 3 :target #news:target 选择当前活动的 #news 元素。 3 :enabled input:enabled 选择每个启用的 元素。 3 :disabled input:disabled 选择每个禁用的 元素 3 :checked input:checked 选择每个被选中的 元素。 3 :not(selector) :not(p) 选择非 元素的每个元素。 3 ::selection ::selection 选择被用户选取的元素部分。 3 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:3:0","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"属性 属性 功能 可能的值 示例 background 背景色 border 在一个声明中设置所有的边框属性按顺序（border-width，border-style，border-color） color 颜色：red，#ff0000，#f00，rgb(255,0,0)，rgb(100%,0%,0%) display 规定元素应该生成的框的类型 参考 float 块级元素加入这个属性，就不会换行 font-family 字体系列 “sans serif” font-size 字体大小px font-weight 规定字体的粗细 normal:默认值,定义标准的字符;bold:定义粗体字符;bolder:定义更粗的字符;lighter:定义更细的字符;100\\200\\300\\400\\500\\600\\700\\800\\900:定义由粗到细的字符,400 等同于 normal，而 700 等同于 bold;inherit:规定应该从父元素继承字体的粗细。 left 原始位置左侧增加px，可以为负 letter-spacing 设置字符间距 normal：默认，规定字符间没有额外的空间；length：定义字符间的固定空间（允许使用负值）；inherit：规定应该从父元素继承 letter-spacing 属性的值 line-height 设置行间的距离（行高） normal:默认,设置合理的行间距;number:设置数字，此数字会与当前的字体尺寸相乘来设置行间距;length:设置固定的行间距;%:基于当前字体尺寸的百分比行间距 inherit 规定应该从父元素继承 line-height 属性的值。 margin 在一个声明中设置所有外边距属性。 margin-bottom 设置元素的下外边距 margin-left 设置元素的左外边距 margin-right 设置元素的右外边距 margin-top 设置元素的上外边距 object-fit 指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框 contain：被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。cover：被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。fill：被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。none：被替换的内容将保持其原有的尺寸。scale-down：内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 例如video填充div opacity 规定元素的不透明级别 padding 在一个声明中设置所有内边距属性 position 定义建立元素布局所用的定位机制 默认：static；relative：相对于其正常位置进行定位；absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位；fixed：生成绝对定位的元素，相对于浏览器窗口进行定位；inherit：规定应该从父元素继承 position 属性的值 table-layout 用来显示表格单元格、行、列的算法规则 automatic 默认。列宽度由单元格内容设定。fixed 列宽由表格宽度和列宽度设定。inherit 规定应该从父元素继承 table-layout 属性的值。 text-align 文字对齐：center text-transform 控制文本的大小写 none：默认，定义带有小写字母和大写字母的标准的文本；capitalize：文本中的每个单词以大写字母开头；uppercase：定义仅有大写字母；lowercase：定义无大写字母，仅有小写字母；inherit：规定应该从父元素继承 text-transform 属性的值 top transform 向元素应用 2D 或 3D 转换 参考 z-index 设置元素的堆叠顺序 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:4:0","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"案例分析 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:5:0","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"DIV层叠与固定 在父对象上设置：position:relative; 在子对象上设置：position:absolute; top: 10px; left: 10px; 这样如果父对象里面有其他元素的话。上面设置的子对象就可以\"悬浮\"在父对象上面了。 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:5:1","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"B站视频布局 ","date":"2019-01-18","objectID":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/:5:2","tags":["前端"],"title":"CSS笔记","uri":"/post/%E5%89%8D%E7%AB%AF-css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"思路 Django提供 django.contrib.staticfiles 中间件来管理静态文件。 ","date":"2019-01-16","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/:1:0","tags":["Django"],"title":"Django静态文件","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"方法 ","date":"2019-01-16","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/:2:0","tags":["Django"],"title":"Django静态文件","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"配置 将 django.contrib.staticfiles 包含进 INSTALLED_APPS； 在配置文件中定义 STATIC_URL； ","date":"2019-01-16","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/:2:1","tags":["Django"],"title":"Django静态文件","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"访问 开发 开发中，使用 runserver 并且 DEBUG=TRUE，可以直接访问；但是效率低而且不安全，不能用于生产环境。 生产环境 ","date":"2019-01-16","objectID":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/:2:2","tags":["Django"],"title":"Django静态文件","uri":"/post/%E5%90%8E%E7%AB%AF-web%E6%A1%86%E6%9E%B6-django-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"思路 资产配置都是反人性的。 首先问自己使用保险要解决什么问题. ","date":"2019-01-15","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:1:0","tags":["保险"],"title":"给自己上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"需求 ","date":"2019-01-15","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:2:0","tags":["保险"],"title":"给自己上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"重疾险 作用 1. 疾病赔偿：轻症赔付、重症赔付； 2. 身故赔偿； 3. 到期或返还保险金，或身后留给受益人。 保多少 1. 家长打底20万，争取50万，有能力到100万； 2. 收入高的一方多一些； 缴费期 1. 40岁以内，可以交20年； 2. 40岁以上，不要超过60岁； 3. 异地投保缩短缴费期。 ","date":"2019-01-15","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:2:1","tags":["保险"],"title":"给自己上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"产品对比 ","date":"2019-01-15","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:3:0","tags":["保险"],"title":"给自己上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"重疾险 ","date":"2019-01-15","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:3:1","tags":["保险"],"title":"给自己上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"参考JavaScript 标准内置对象 感谢 作者：小黎也 链接：https://juejin.im/post/5e523e726fb9a07c9a195a95 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1. 值属性 这些全局属性返回一个简单值，这些值没有自己的属性和方法，就是一个常数。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:0:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"1.1. Infinity ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:1:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"1.2. NaN ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:2:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"1.3. undefined ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:3:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"1.4. null 字面量 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:4:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"1.5. globalThis 2. 函数属性 全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:5:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.1. eval() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:6:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.2. uneval() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:7:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.3. isFinite() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:8:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.4. isNaN() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:9:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.5. parseFloat() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:10:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.6. parseInt() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:11:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.7. decodeURI() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:12:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.8. decodeURIComponent() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:13:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.9. encodeURI() ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:14:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"2.10. encodeURIComponent() 3. 基本对象 基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:15:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"3.1. Object Object 构造函数创建一个对象包装器。 JavaScript 中的所有对象都来自 Object；所有对象从 Object.prototype 继承方法和属性，尽管它们可能被覆盖。例如，其他构造函数的原型将覆盖 constructor 属性并提供自己的 toString() 方法。Object 原型对象的更改将传播到所有对象，除非受到这些更改的属性和方法将沿原型链进一步覆盖。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:16:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"3.1.1. Object 构造函数 的属性 Object.length 值为 1。 Object.prototype 可以为所有 Object 类型的对象添加属性。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:16:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"3.1.2. Object 构造函数 的方法 3.1.2.1. Object.assign() 通过复制一个或多个对象来创建一个新的对象。 注意：Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已，其内层还是引用地址。 3.1.2.2. Object.create() 使用指定的原型对象和属性创建一个新对象。 const pureObject = Object.create(null);您可以创建一个 100％ 纯对象，它不会从 Object 继承任何属性或方法. 3.1.2.3. Object.defineProperty() 给对象添加一个属性并指定该属性的配置。 3.1.2.4. Object.defineProperties() 给对象添加多个属性并分别指定它们的配置。 3.1.2.5. Object.entries() 返回给定对象自身可枚举属性的 [key, value] 数组。 3.1.2.6. Object.freeze() 冻结对象：其他代码不能删除或更改任何属性。 3.1.2.7. Object.getOwnPropertyDescriptor() 返回对象指定的属性配置。 3.1.2.8. Object.getOwnPropertyNames() 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。 3.1.2.9. Object.getOwnPropertySymbols() 返回一个数组，它包含了指定对象自身所有的符号属性。 3.1.2.10. Object.getPrototypeOf() 返回指定对象的原型对象。 3.1.2.11. Object.is() 比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。 3.1.2.12. Object.isExtensible() 判断对象是否可扩展。 3.1.2.13. Object.isFrozen() 判断对象是否已经冻结。 3.1.2.14. Object.isSealed() 判断对象是否已经密封。 3.1.2.15. Object.keys() 返回一个包含所有给定对象自身可枚举属性名称的数组。 3.1.2.16. Object.preventExtensions() 防止对象的任何扩展。 3.1.2.17. Object.seal() 防止其他代码删除对象的属性。 3.1.2.18. Object.setPrototypeOf() 设置对象的原型（即内部 [[Prototype]] 属性）。 3.1.2.19. Object.values() 返回给定对象自身可枚举值的数组。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:16:2","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"3.1.3. Object 实例的方法 3.1.3.1. Object.prototype.hasOwnProperty() 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。 3.1.3.2. Object.prototype.isPrototypeOf() 返回一个布尔值，表示指定的对象是否在本对象的原型链中。 3.1.3.3. Object.prototype.propertyIsEnumerable() 判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。 如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。 3.1.3.4. Object.prototype.toLocaleString() 直接调用 toString()方法。 3.1.3.5. Object.prototype.toString() 返回对象的字符串表示。 3.1.3.6. Object.prototype.valueOf() 返回指定对象的原始值。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:16:3","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"3.2. Symbol 在 symbol 出现之前，对象键只能是字符串，如果试图使用非字符串值作为对象的键，那么该值将被强制转换为字符串。 Symbol 的作用非常的专一，换句话说其设计出来就只有一个目的——作为对象属性的唯一标识符，防止对象属性冲突发生。 简单了解 ES6/ES2015 Symbol() 方法. 4. 数字和日期对象 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:17:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"4.1. Number ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:18:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"4.1.1. 实例方法 4.1.1.1. Number.prototype.toFixed() 使用定点表示法（小数点位置固定）来格式化一个数值 toFixed 对于四舍六入没问题，但对于尾数是 5 的处理就非常诡异（向5靠近）。 (1.235).toFixed(2) \"1.24\" (1.245).toFixed(2) \"1.25\" (1.255).toFixed(2) \"1.25\" (1.265).toFixed(2) \"1.26\" (1.275).toFixed(2) \"1.27\" ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:18:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"4.1.2. Number实战 10 进制转其他进制：Number(val).toString([2,8,10,16]) 其他进制转成10进制：Number.parseInt(“1101110”,[2,8,10,16]) 其他进制互转：先将其他进制转成 10 进制，在把 10 进制转成其他进制 5. 字符串 6. 可索引的集合对象 表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:18:2","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.1. Array Array 既是一个数组，也是一个字典。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:19:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.1.1. Array 构造函数的属性 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:19:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.1.2. Array 构造函数的方法 6.1.2.1. Array.from() 从类数组对象或者可迭代对象中创建一个新的数组实例。 6.1.2.2. Array.isArray() 用来判断某个变量是否是一个数组对象。 6.1.2.3. Array.of() 根据一组参数来创建新的数组实例，支持任意的参数数量和类型。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:19:2","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.1.3. Array 实例的属性 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:19:3","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.1.4. Array 实例的方法 6.1.4.1. 修改器方法 下面的这些方法会改变调用它们的对象自身的值： 6.1.4.1.1. Array.prototype.pop() 删除数组的最后一个元素，并返回这个元素。 6.1.4.1.2. Array.prototype.push() 在数组的末尾增加一个或多个元素，并返回数组的新长度。 6.1.4.1.3. Array.prototype.reverse() 颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 6.1.4.1.4. Array.prototype.shift() 删除数组的第一个元素，并返回这个元素。 6.1.4.1.5. Array.prototype.sort() 对数组元素进行排序，并返回当前数组。 6.1.4.1.6. Array.prototype.splice() 在任意的位置给数组添加或删除任意个元素。 6.1.4.1.7. Array.prototype.unshift() 在数组的开头增加一个或多个元素，并返回数组的新长度。 6.1.4.2. 访问方法 下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 6.1.4.2.1. Array.prototype.concat() 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 6.1.4.2.2. Array.prototype.join() 连接所有数组元素组成一个字符串。 6.1.4.2.3. Array.prototype.slice() 抽取当前数组中的一段元素组合成一个新数组。 6.1.4.2.4. Array.prototype.toString() 返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。 6.1.4.2.5. Array.prototype.toLocaleString() 返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。 6.1.4.2.6. Array.prototype.indexOf() 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 6.1.4.2.7. Array.prototype.lastIndexOf() 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 6.1.4.3. 迭代方法 在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的 length 属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 6.1.4.3.1. Array.prototype.forEach() 为数组中的每个元素执行一次回调函数。 回调函数是异步执行的，但是整个forEach是同步的。 6.1.4.3.2. Array.prototype.every() 如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 6.1.4.3.3. Array.prototype.some() 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 6.1.4.3.4. Array.prototype.filter() 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 6.1.4.3.5. Array.prototype.map() 返回一个由回调函数的返回值组成的新数组。 6.1.4.3.6. Array.prototype.reduce() 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 6.1.4.3.7. Array.prototype.reduceRight() 从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:19:4","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.1.5. Array 实战 JavaScript 高性能数组去重. 将数组放进对象中，可实现去重，而且效率高；若key为数字，还能天然排序（使用Object.Values）. 在不重新给数组赋值的情况下，清空或截断数组的最简单方法是更改其 length 属性值。 可以使用对象解构将数组项分配给各个变量. const csvFileLine = '1997,John Doe,US,john@doe.com,New York'; const { 2: country, 4: state } = csvFileLine.split(','); ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:19:5","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.2. Uint8Array 表示一个 8 位无符号整型数组，创建时内容被初始化为 0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:20:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"6.2.1. Node 中 Buffer Node 中 Buffer 类是 JavaScript 语言内置的 Uint8Array 类的子类。 Buffer 转 Json。 7. 使用键的集合对象 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:20:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"7.1. Set Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:21:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"7.1.1. Set 实战 7.1.1.1. 集合运算 var a = [1, 2, 3, 4, 5]; var b = [2, 4, 6, 8, 10]; console.log(\"数组a：\", a); console.log(\"数组b：\", b); var sa = new Set(a); var sb = new Set(b); // 交集 let intersect = a.filter((x) =\u003e sb.has(x)); // 差集 let minus = a.filter((x) =\u003e !sb.has(x)); // 补集 let complement = [ ...a.filter((x) =\u003e !sb.has(x)), ...b.filter((x) =\u003e !sa.has(x)), ]; // 并集 let unionSet = Array.from(new Set([...a, ...b])); console.log(\"a与b的交集：\", intersect); console.log(\"a与b的差集：\", minus); console.log(\"a与b的补集：\", complement); console.log(\"a与b的并集：\", unionSet); 8. 结构化数据 这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON （JavaScript Object Notation）编码的数据。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:21:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"8.1. ArrayBuffer ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。 它是一个字节数组，通常在其他语言中称为“byte array”。 你不能直接操作 ArrayBuffer 的内容，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:22:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"8.2. DataView DataView 视图是一个可以从 二进制ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:23:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"8.3. JSON JSON.stringify 不仅可以简单地将对象转化为字符串。你也可以用它来格式化JSON输出：第三个参数用来指定空格的数目。 JSON.parse() 可以接受第二个参数，它可以在返回之前转换对象值。比如这例子中，将返回对象的属性值大写。 const user = { name: 'John', email: 'john@awesome.com', plan: 'Pro' }; const userStr = JSON.stringify(user); const newUserStr = JSON.parse(userStr, (key, value) =\u003e { if (typeof value === 'string') { return value.toUpperCase(); } return value; }); console.log(newUserStr); //{name: \"JOHN\", email: \"JOHN@AWESOME.COM\", plan: \"PRO\"} JSON.stringify() 可以带两个额外的参数，第一个是替换函数，第二个间隔字符串，用作隔开返回字符串。 value ： 将要转为JSON字符串的javascript对象。 replacer ：该参数可以是多种类型,如果是一个函数,则它可以改变一个javascript对象在字符串化过程中的行为, 如果是一个包含 String 和 Number 对象的数组,则它将作为一个白名单.只有那些键存在域该白名单中的键值对才会被包含进最终生成的JSON字符串中.如果该参数值为null或者被省略,则所有的键值对都会被包含进最终生成的JSON字符串中。 space ：该参数可以是一个 String 或 Number 对象,作用是为了在输出的JSON字符串中插入空白符来增强可读性. 如果是Number对象, 则表示用多少个空格来作为空白符; 最大可为10,大于10的数值也取10.最小可为1,小于1的数值无效,则不会显示空白符. 如果是个 String对象, 则该字符串本身会作为空白符,字符串最长可为10个字符.超过的话会截取前十个字符. 如果该参数被省略 (或者为null), 则不会显示空白符 利用toJSON方法,我们可以修改对象转换成JSON的默认行为。 var obj = { foo: 'foo', toJSON:function(){ return 'bar'; } } JSON.stringify(obj);//'\"bar\"' JSON.stringify({x:obj});//'{\"x\":\"bar\"}' 9. 控制抽象对象 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:24:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.1. Promise Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。Promise 是一个绑定了回调的对象，而不是将回调传进函数内部。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:25:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.1.1. 使用Promise 若一个函数返回promise对象，就可以使用链式操作（then,catch）。 then() 函数会返回一个全新的 Promise，和原来的不同. 如果想要在回调中获取上个 Promise 中的结果，上个 Promise 中必须要返回结果。(使用 () =\u003e x 比() =\u003e { return x; } 更简洁一点). 一遇到异常抛出，promise链就会停下来，直接调用链式中的catch处理程序来继续当前执行。 doSomething() .then(result =\u003e doSomethingElse(result)) .then(newResult =\u003e doThirdThing(newResult)) .then(finalResult =\u003e console.log(`Got the final result: ${finalResult}`)) .catch(failureCallback); ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:25:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.1.2. 构建Promise 构造函数主要是用来包装还未支持promises的函数。 //Promise构造函数执行时立即调用executor 函数 //resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。 //resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。 //executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。 //如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。 var promise1 = new Promise(function(resolve, reject) { setTimeout(function() { resolve('foo'); }, 300); }); promise1.then(function(value) { console.log(value); // expected output: \"foo\" }); console.log(promise1); // expected output: [object Promise] 9.1.2.1. Promise.all(iterable) 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。 9.1.2.2. Promise.race(iterable) 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 9.1.2.3. Promise.reject(reason) 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 9.1.2.4. Promise.resolve(value) 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:25:2","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.2. Generator 生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 function* gen() { yield 1; yield 2; yield 3; } let g = gen(); // \"Generator { }\" 异步任务的容器，生成器本质上是一种特殊的迭代器， Generator 执行后返回的是个指针对象，调用对象里的 next 函数，会移动内部指针，分阶段执行 Generator 函数 ，指向 yield 语句，返回一个对象 {value:当前的执行结果，done:是否结束} ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:26:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.2.1. 方法 9.2.1.1. Generator.prototype.next() 返回一个由 yield表达式生成的值。 9.2.1.2. Generator.prototype.return() 返回给定的值并结束生成器。 9.2.1.3. Generator.prototype.throw() 向生成器抛出一个错误。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:26:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.3. GeneratorFunction ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:27:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.4. AsyncFunction ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:28:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.5. Iterator ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:29:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"9.6. AsyncIterator 10. 反射 11. 国际化 12. WebAssembly 13. 其他 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:30:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.1. arguments arguments 是一个对应于传递给函数的参数的类数组对象。 arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。 arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array： 在浏览器中箭头函数没有 arguments 在 nodejs 中，有 arguments ，可通过其获取参数长度，但不能通过改对象获取参数列表 var args = Array.prototype.slice.call(arguments); var args = [].slice.call(arguments); // ES2015 const args = Array.from(arguments); const args = [...arguments]; | var a = new Array() | 定义一个数组或者字典，定义字典最好使用 new Object | | for (var key in dic){} | 遍历 | | delete dic[“r”]; | 删除一个 KEY,使用 empty 替换，但是长度不变 | | delete dic.r | 删除一个 KEY，使用 empty 替换，但是长度不变 | | array.map() | 基本用法跟 forEach 方法类似，作用不难理解，“映射”嘛，也就是原数组被“映射”成对应新数组 | array.ma(element=\u003e{return element.id}) | | [].some() | 返回一个 boolean，判断是否有元素是否符合 func 条件,返回 true 时终止遍历 | | [].every() | 返回一个 boolean，判断每个元素是否符合 func 条件,every 返回 false 时终止遍历,返回 true 继续遍历 | | array.length | 数组的长度　｜ | | arrayObject.concat(arrayX,arrayX,……,arrayX) | 返回一个新的数组,不改变原数组的值。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组 | | Array.from() | 从一个类似数组或可迭代对象中创建一个新的数组实例 | console.log(Array.from('foo'));// expected output: Array [\"f\", \"o\", \"o\"]console.log(Array.from([1, 2, 3], x =\u003e x + x));// expected |output: Array [2, 4, 6] | | […new Array(10).keys()] | 序列化一个新数组 | | indexOf() | 判断是否存在 | 不存在返回-1 | 判断 JS 对象是否拥有某属性两种方式，但稍有区别 1. in 运算符 var obj = {name:'jack'}; alert('name' in obj); // --\u003e true alert('toString' in obj); // --\u003e true 可看到无论是name，还是原形链上的toString，都能检测到返回true。 2. hasOwnProperty 方法 var obj = {name:'jack'}; obj.hasOwnProperty('name'); // --\u003e true obj.hasOwnProperty('toString'); // --\u003e false 原型链上继承过来的属性无法通过hasOwnProperty检测到，返回false。 需注意的是，虽然in能检测到原型链的属性，但for in通常却不行。 当然重写原型后for in在IE9/Firefox/Safari/Chrome/Opera下是可见的。见：for in的缺陷 js 扩展运算符（spread）是三个点（…）:将一个数组转为用逗号分隔的参数序列。 array.push(...items); function add(x, y) { return x + y; } var numbers = [4, 38]; add(...numbers) // 42 //扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 // ES5 的写法 Math.max.apply(null, [14, 3, 77]) // ES6 的写法 Math.max(...[14, 3, 77]) // 等同于 Math.max(14, 3, 77); //通过push函数，将一个数组添加到另一个数组的尾部 // ES5的 写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6 的写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1.push(...arr2); //合并数组 // ES5 [1, 2].concat(more) // ES6 [1, 2, ...more] var arr1 = ['a', 'b']; var arr2 = ['c']; var arr3 = ['d', 'e']; // ES5的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6的合并数组 [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] 扩展运算符将字符串转为真正的数组 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:31:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.1.1. 对象方法 13.1.1.1. foreach array.forEach(function(currentValue, index, arr), thisValue) 用于调用数组的每个元素，并将元素传递给回调函数,没有返回值，forEach 无法跳出循环（使用 return 也不行，只能抛异常跳出）。 foreach为同步执行，回调函数中不能使用await语法。 foreach放在async函数中，如果回调函数中有异步执行，则异步执行。防止异步执行可使用for（const element of array）在回调函数中使用await。 13.1.1.2. includes 不会改变原数组 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。 13.1.1.3. splice 此方法会改变原数组 splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。 var array=[0,1,2,3,4,5]; 1、向数组中的指定位置添加数据 arr.splice(2,0,\"10\") 输出: array=[0,1,10,2,3,4,5]; 2、删除数组中的指定位置的数据并用新数据替换 arr.splice(2,1,\"10\") 输出: array=[0,1,10,3,4,5]; 3、删除数组中的指定位置开始的多个数据并用新数据替换 arr.splice(2,3,\"10\") 输出: array=[0,1,10,5]; 4、删除数组中的指定位置的数据方法 获取数组中数据的下标 var index = array.indexOf(4); 删除数据 if(index\u003e-1){ array.splice(index,1); } ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:31:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.2. 字符串 语句 功能 str.split() 字符串转字符串数组 [‘1’,‘2’,‘3’].map(Number) 数字字符串数组转数字数组 parseInt(str) 字符串转整数 parseFloat(str) 字符串转浮点数 string.indexOf(‘str’) 判断字符串是否包含另一个字符串 encodeURIComponent(str) 函数可把字符串作为 URI 组件进行编码 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:32:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.3. json 语句 功能 备注 JSON.stringify(arr) 字典转 json 注：arr 必须是 Object 不能是 Array JSON.parse(jsonStr) json 转数组 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:33:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.4. 转换 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:34:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.5. buffer(NodeJs) 在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区. 一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:35:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.5.1. 创建 Buffer 类 Buffer 提供了以下 API 来创建 Buffer 类： Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例 // 创建一个长度为 10、且用 0 填充的 Buffer。 const buf1 = Buffer.alloc(10); // 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1); // 创建一个长度为 10、且未初始化的 Buffer。 // 这个方法比调用 Buffer.alloc() 更快， // 但返回的 Buffer 实例可能包含旧数据， // 因此需要使用 fill() 或 write() 重写。 const buf3 = Buffer.allocUnsafe(10); // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。 const buf4 = Buffer.from([1, 2, 3]); // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。 const buf5 = Buffer.from('tést'); // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。 const buf6 = Buffer.from('tést', 'latin1'); ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:35:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.6. Date 创建var myDate=new Date()；自动把当前日期和时间保存为其初始值。 Date对象直接/1000获得时间戳。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:36:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.7. NaN 和 Number.Nan 值一样 表示不是一个数字（Not a Number）； 编码中很少直接使用到 NaN。通常都是在计算失败时，作为 Math 的某个方法的返回值出现的（例如：Math.sqrt(-1)）或者尝试将一个字符串解析成数字但失败了的时候（例如：parseInt(“blabla”)）； 等号运算符（== 和 ===） 不能被用来判断一个值是否是 NaN。必须使用 Number.isNaN() 或 isNaN() 函数。 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:37:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.8. 运算符 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:38:0","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"13.8.1. 位运算符 位运算符工作于 32 位的数字上。任何数字操作都将转换为 32 位。结果会转换为 JavaScript 数字。 运算符 描述 例子 类似于 结果 十进制 \u0026 AND x = 5 \u0026 1 0101 \u0026 0001 0001 1 OR x = 5 1 0101 ~ 取反 x = ~ 5 ~0101 1010 -6 ^ 异或 x = 5 ^ 1 0101 ^ 0001 0100 4 « 左移 x = 5 « 1 0101 « 1 1010 10 » 右移 x = 5 » 1 0101 » 1 0010 2 ","date":"2019-01-15","objectID":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/:38:1","tags":["JS","NODE"],"title":"JS标准内置对象(全局作用域里的对象)","uri":"/post/program-js-js%E5%AF%B9%E8%B1%A1%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"categories":["桌面应用"],"content":"使用electron开发桌面应用","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"Electron API 演示(中文版) ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:0:0","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"完成一个桌面项目 ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:1:0","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"使用Xmind制作功能描述和模块划分 ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:1:1","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"使用pencil制作界面原型 ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:1:2","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"使用yed制作流程图 ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:1:3","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"开始一个工程 注：创建一个新的空的工程之后，跑通整个流程（打包之后可运行，可CI/CD）之后，再开始写业务代码。 参考项目NordicSemiconductor/pc-nrfconnect-core electron-vue 基于 vue (基本上是它听起来的样子) 来构造 electron 应用程序的样板代码。 项目结构 webpack配置 .electron-vue/webpack.renderer.config.js 针对 electron 的 renderer 进程。此配置用来处理你的 Vue 应用程序，因此它包含 vue-loader 和许多其他可在官方 vuejs-templates/webpack 样板中找到的配置。 白名单里的外部组件 一个关于此配置的重要的事情是，你可以将特定的模块列入白名单，而不是把它视为 webpack 的 externals。并没有很多情况需要这个功能，但在某些情况下，对于提供原始的 *.vue 组件的 Vue UI 库，他们需要被列入白名单，以至于 vue-loader 能够编译它们。另一个使用情况是使用 webpack 的 alias，例如设置 vue 来导入完整的 编译+运行环境 的构建。因此，vue 已经在白名单中了。 例如element-ui。 打包分发 参考如何深入理解 electron-vue 的 build 构建命令 使用electron-builder，配置文件在package.json中的build项中，需要先node .electron/build.js,然后electron-builder. 使用electron-packager，配置文件在.electron/build.config.js中,packager的调用直接在.electron/build.js中，只需要node .electron/build.js. electron-vue构建之后，会有asar文件。如何查看asar文件内部结构？asar辅助查看工具 ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:1:4","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"打包分发 electron-builder 在CI服务器和开发机器上进行代码签名； 自动更新； 多种目标格式； DockerTo build Linux or Windows on any platform. 技巧 electron 打包之后，如何使用 F12 开启开发者工具？ ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:1:5","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"疑难杂症 在Electron项目中npm install模块之后，可能会出先版本不匹配的问题，此时需要使用Electron-rebuild重新编译一下。 npm install --save-dev electron-rebuild Every time you run \"npm install\", run this: ./node_modules/.bin/electron-rebuild On Windows if you have trouble, try: .\\node_modules.bin\\electron-rebuild.cmd 上个问题如果出问题可以使用下边的命令： ./node_modules/.bin/electron-rebuild -m . 上述命令依然失败，删除～/.electron-gyp重试。 gyp ERR! stack Error: read ECONNRESET为网络原因，在比较好的网络下解决。 pc-ble-driver-js test code dfu.js with electron module error关于module did not register的问题。 增加.npmrc在工程目录下解决，都不需要Electron-rebuild runtime = electron target = 2.0.17 disturl = https://atom.io/download/electron electron应用中使用了NFC读卡器功能，依赖的是系统的pcsc服务，此时运行代码显示空白，需要一个读卡器硬件辅助，启动读卡器服务，然后打开软件之后，不再是空白。 No 'Access-Control-Allow-Origin' error on for origin 跨域访问 // main/index.js mainWindow = new BrowserWindow({ height: 563, useContentSize: true, width: 1000, webPreferences: { webSecurity: false } }) ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:2:0","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"API ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:3:0","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":["桌面应用"],"content":"BrowserWindow 创建和控制浏览器窗口 在主进程和渲染进程调用的方式不一样 在主进程中直接调用：const {BrowserWindow} = require('electron') 在渲染进程中则需使用remote来调用：const {BrowserWindow} = require('electron').remote ","date":"2019-01-14","objectID":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/:3:1","tags":["JS","桌面应用"],"title":"使用Electron创建桌面应用","uri":"/post/js-nodejs-electron-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"VUE实例的生命周期 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:1:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"VUE实例的特殊属性和方法 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:2:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"$refs 一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:2:1","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"VUE实例属性 Vue.prototype.$appName = 'My App' 这样 $appName 就在所有的 Vue 实例（每个页面都是一个独立的实例）中可用了，甚至在实例被创建之前就可以。如果我们运行： new Vue({ beforeCreate: function () { console.log(this.$appName) } }) 则控制台会打印出 My App。就这么简单！ ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:3:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"实战技巧 防止浏览器缓存css,js静态文件 使用此方法可以在程序运行过程中，重新下载同名的静态文件。 Vue导出页面为PDF格式 Vue导出json数据到Excel电子表格 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:4:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"安装 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:5:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"使用Vue CLI 可图形界面创建VUE项目(vue ci)。 关于source map,在生产环境下，一定要关闭source map选项，这样在chrome的调试窗口source选项卡下，就不会看到项目源码。否则，在build的dist/js目录下有map文件。 使用vue cli使用的配置文件为 vue.config.js module.exports = { productionSourceMap: false } ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:5:1","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"VUE插件 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:6:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"VUEX Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 参考购物车项目 store对象中的key值按照约定，不可随意更改。 参考vuex存储和本地存储(localstorage、sessionstorage)的区别. cookie(HTML4) 4K WebStorage(HTML5) 5M或更大； 使用方法 .运算符 []运算符 setItem (key, value) —— 保存数据，以键值对的方式储存信息。 getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。 removeItem (key) —— 删除单个数据，根据键值移除对应的信息。 clear () —— 删除所有的数据 key (index) —— 获取某个索引的key sessionStorage(HTML5) 回话存储 sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 localStorage(HTML5) 本地存储 localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 总结 1.区别：vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地,永久保存；sessionstorage( 会话存储 ) ,临时保存。localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理 2.应用场景：vuex用于组件之间的传值，localstorage，sessionstorage则主要用于不同页面之间的传值。 3.永久性：当刷新页面（这里的刷新页面指的是 –\u003e F5刷新,属于清除内存了）时vuex存储的值会丢失，sessionstorage页面关闭后就清除掉了，localstorage不会。 注：很多同学觉得用localstorage可以代替vuex, 对于不变的数据确实可以，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage，sessionstorage无法做到，原因就是区别1。 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:6:1","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"VUE-ROUTER vue router带参数页面刷新或者回退参数消失的解决方法 this.$router.push({path:'',params:{},query:{}}) patams传参.路径不能使用path 只能使用name,不然获取不到传的数据.query要用path ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:6:2","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"vue-json-excel ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:6:3","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"基于VUE的扩展 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"IVIEW一套基于Vue.js的高质量UI 组件库 组件多于element-ui ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:1","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"Element一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 vue-element-admin基于 Vue2.0，配合使用 Element UI 组件库的一个前端管理后台集成解决方案。 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:2","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"Ant Design of Vue ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:3","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"vue-beauty基于 vue.js 和 ant-design样式 的PC端 UI 组件库 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:4","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"ANTUE ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:5","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"fengyuanchen/vue-barcode ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:7:6","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"基于VUE的框架 ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:8:0","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":"vue-element-admin ","date":"2019-01-14","objectID":"/post/%E5%89%8D%E7%AB%AF-vue/:8:1","tags":["VUE","前端"],"title":"VUE","uri":"/post/%E5%89%8D%E7%AB%AF-vue/"},{"categories":null,"content":" 看完这篇白话uni-app。 DCloud与vue合作，在vue.js官网提供了免费视频教程，也可以直达教程地址：https://learning.dcloud.io。 学习资源。 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:0:0","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"知识点 全局样式：在根目录下的app.vue里写入，每个页面都会加载app.vue里的样式。 如需要全局导入vue组件，即每个页面都可以直接使用而不用引用和注册的话，在项目根目录下的main.js里处理。如下是hello uni-app里的例子。 //main.js import pageHead from './components/page-head.vue' //导入 Vue.component('page-head', pageHead) //注册。注册后在每个vue的page页面里可以直接使用\u003cpage-head\u003e\u003c/page-head\u003e组件。 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:1:0","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"组件/标签的变化 以前是html标签，现在是小程序组件。具体说来： div 改成 view span、font 改成 text a 改成 navigator img 改成 image input 还在，但type属性改成了confirmtype form、button、checkbox、radio、label、textarea、canvas、video 这些还在。 select 改成 picker iframe 改成 web-view ul、li没有了，都用view替代 audio 不再推荐使用，改成api方式，背景音频api文档 其实老的HTML标签也可以在uni-app里使用，uni-app编译器会在编译时把老标签转为新标签，比如把div编译成view。但不推荐这种用法，调试H5端时容易混乱。 除了改动外，新增了一批手机端常用的新组件 scroll-view 可区域滚动视图容器 swiper 可滑动区域视图容器 icon 图标 rich-text 富文本（不可执行js，但可渲染各种文字格式和图片） progress 进度条 slider 滑块指示器 switch 开关选择器 camera 相机 live-player 直播 map 地图 cover-view 可覆盖原生组件的视图容器 cover-view需要多强调几句，uni-app的非h5端的video、map、canvas、textarea是原生组件，层级高于其他组件。如需覆盖原生组件，比如在map上加个遮罩，则需要使用cover-view组件 除了内置组件，还有很多开源的扩展组件，把常用操作都进行封装，DCloud建立了插件市场收录这些扩展组件，详见插件市场 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:1:1","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"JS的变化 运行环境变化 在uni-app的各个端中，除了h5端，其他端的js都运行在一个独立的v8引擎下，不是在浏览器中，所以浏览器的对象（浏览器专用的window、document、navigator、location对象，包括cookie等存储）无法使用。 app和小程序支持web-view组件，里面可以加载标准HTML，这种页面仍然支持浏览器专用对象window、document、navigator、location。 数据绑定模式变化 现在前端趋势是去dom化，改用mvvm模式，更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。 api变化 uni-app的api是参考小程序的 alert,confirm 改成 uni.showmodel ajax 改成 uni.request cookie、session 没有了，local.storage 改成 uni.storage uni-app在不同的端，支持条件编译，无限制的使用各端独有的api. ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:1:2","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"CSS的变化 *选择器不支持；元素选择器里没有body，改为了page。 单位方面，px无法动态适应不同宽度的屏幕，rem无法用于nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用rpx，全端支持。 uni-app推荐使用flex布局，并默认就是flex布局. 注意背景图和字体文件尽量不要大于40k。会影响性能。如果非要大于40k，需放到服务器侧远程引用或base64后引入，不能放到本地作为独立文件引用。在小程序里，其实小于40k的文件在css里也无法引用，uni-app编译器在编译时自动做了处理，把小于40k的文件编译为base64方式了。 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:1:3","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"工程结构 ┌─components uni-app组件目录 │ └─comp-a.vue 可复用的a组件 ├─hybrid 存放本地网页的目录，详见 ├─platforms 存放各平台专用页面的目录，详见 ├─pages 业务页面文件存放的目录 │ ├─index │ │ └─index.vue index页面 │ └─list │ └─list.vue list页面 ├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此 ├─wxcomponents 存放小程序组件的目录，详见 ├─utils （非必须，约定）存放自定义模块 ├─common （非必须，约定）存放样式文件 ├─api （非必须，约定）存放API ├─main.js Vue初始化入口文件 ├─App.vue 应用配置，用来配置App全局样式以及监听应用生命周期 ├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见 ├─uni.scss 全局的样式文件 └─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见 每个可显示的页面，都必须在 pages.json 中注册。如果你开发过小程序，那么pages.json类似app.json。如果你熟悉vue，这里没有vue的路由，都是在pages.json里管理。 uni-app的首页，是在pages.json里配的，page节点下第一个页面就是首页。一般在/pages/xx的目录下。 app和小程序中，为了提升体验，页面提供了原生的导航栏和底部tabbar，注意这些配置是在pages.json中做，而不是在vue页面里创建，但点击事件的监听在显示的vue页面中做。 对比小程序: 1. 原来app.json被一拆为二。页面管理，被挪入了uni-app的pages.json；非页面管理，挪入了manifest.json 2. 原来的app.js和app.wxss被合并到了app.vue中 pages.json 用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等。 类似微信小程序中app.json的页面管理部分。注意定位权限申请等原属于app.json的内容，在uni-app中是在manifest中配置。 pages 第一个为默认页。 tabBar 底部 显示的顺序为list的顺序。 globalStyle app.vue onLaunch:可以通过option获取场景值。 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:1:4","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"生命周期 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:1:5","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"框架 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:2:0","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"组件 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:3:0","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"视图容器 view 视图容器 scroll-view 可滚动视图区域 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:3:1","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"表单组件 button @tap 触发 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:3:2","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"扩展组建（uni-ui） ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:3:3","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"API ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:4:0","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"界面 交互反馈 uni.showToast(OBJECT) ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:4:1","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"设备 蓝牙 uni.openBluetoothAdapter uni.startBluetoothDevicesDiscovery uni.onBluetoothDeviceFound uni.stopBluetoothDevicesDiscovery uni.onBluetoothAdapterStateChange uni.getConnectedBluetoothDevices uni.getBluetoothDevices uni.getBluetoothAdapterState uni.closeBluetoothAdapter BLE uni.writeBLECharacteristicValue uni.readBLECharacteristicValue uni.onBLEConnectionStateChange uni.onBLECharacteristicValueChange uni.notifyBLECharacteristicValueChange uni.getBLEDeviceServices uni.getBLEDeviceCharacteristics uni.createBLEConnection uni.closeBLEConnection ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:4:2","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"实战 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:5:0","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"父子组件通信 uni. ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/:5:1","tags":["小程序"],"title":"UNIAPP","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-uniapp/"},{"categories":null,"content":"历史 HTML5成功地实现了打破IE+FLASH的垄断，但是没有达到承载优秀的移动互联网体验的地步。 APPLE发布了自己的app store，开启了移动互联网的原生应用时代。 ANDROID依靠Java技术生态，在竞争中脱颖而出。 通过给WebView扩展原生能力，不出JS API，让HTML5应用可以实现更多功能，但是性能体验是它更严重的问题（等半天白屏）。 流应用，实现了应用的边下载边运行。需要让客户端引擎（必须要有很大的装机量）提前预置在手机上。 微信根据流应用技术原理决定自立标准，自研引擎，开始了小程序。 WEPY面临一些问题，使用私有语法。 MPVUE美团前端开源，借助了VUE的技术生态，收到大量开发者的欢迎，目前支持 微信小程序、百度智能小程序，头条小程序 和 支付宝小程序。 TARO京东开发，率先支持多端开发，并将组件编译为新出的微信小程序自定义组件，提供了组件性能。支持用 React 的开发方式编写一次代码，生成能运行在微信/百度/字节跳动/支付宝小程序、H5、React Native 等平台的应用。 VUE阵营自然要迎头赶上。 uni-app支持多端，并较之前MPVUE做了一些优化。并在支持多端领域，同时发布APP和小程序。7个平台发布。 轮子上的轮子，UI库。 Taro UI实现了H5和小程序UI库的统一。不支持app端。 uni UI同时支持多家小程序、H5、app。插件大赛。 ","date":"2019-01-09","objectID":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%90%84%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%AF%94%E5%8F%8A%E4%BC%98%E7%A7%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/:1:0","tags":["小程序"],"title":"小程序生态-历史-优秀小程序","uri":"/post/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%90%84%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%AF%94%E5%8F%8A%E4%BC%98%E7%A7%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"上医保是首位 1. 每年为下一年交，截止年底。 2. 220元（郑州） ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:1:0","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"以保障优先 1. 别想又能攒钱，又有保障，应以保障优先； 2. 大病保障，几百元就可以搞定。 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:2:0","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"保障需求 风险类型 风险等级 医疗花费 保障方式 常见小毛病 小风险 几百～几千 医保 普通疾病门诊、住院 相对频繁、小风险 1~5万 小额门诊、住院医疗险 意外门诊、住院 中等风险 1~5万 儿童意外险 未达重大疾病标准的“大病” 大风险 5~50万 儿童重疾险的轻症保障、高额住院医疗险 重大疾病 大风险 超过50万 儿童重疾险、高额住院医疗险 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:3:0","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"注意事项 按中国保监会规定，除航空意外死亡及重大自然灾害意外死亡外，任何不满10周岁的被保险人，其死亡保险金额不得超过人民币20万元；已满10周岁但未满18周岁的被保险人，其死亡保险金额不得超过人民币50万元。 意外险短期的就可以，不需要长期。 配置住院医疗选择不限社保目录范围报销的产品。这样才能更好地弥补社保漏洞，发挥商业保险的价值。 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:4:0","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"产品对比 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:5:0","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"门诊险 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:5:1","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"重疾 产品名称 重大疾病保险金 少儿特定重大疾病保险金 身故保险金 轻症疾病保险金 轻症疾病豁免保险费 保障期限 保费 重疾种类 重疾次数 轻症种类 轻症次数 特色 选择 小雨伞大黄蜂少儿重疾险2号 50w，前11年保额5%复利增长 50w+额外基本保额 身故或全残返回保费 （每次）重疾保额的30% 豁免后期保险金 20年 716/年（10年） 100种 1次 50种 3次 投保人豁免 选择 小雨伞大黄蜂少儿重疾险2018（定期版） 50w 50w 返还保费 重疾保额的30% 豁免后期保险费 20年 770.2/年(10年) 60种 1次 30种 1次 附加重症医疗（50w） 不限社保范围 多次赔付 直到额度赔完为止 慧馨安少儿定期重大疾病保险-2018版Plus 50w(一次为限) 50w(一次为限) 已交保险费 15w（附加险、一次为限） 豁免后期重大疾病保险费 20年 650/年（15年） 平安儿童重大疾病保险 50w 1年 264.5 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:5:2","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"意外 产品名称 意外身故和伤残 意外医疗 免赔 保障期限 保费 选择 小雨伞小顽童少儿意外险 20w 1w(含门诊住院) 无免赔 1年 60 选择 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:5:3","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"医疗险 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:5:4","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"综合险 产品名称 意外身故和伤残 意外医疗 重大疾病 疾病身故残疾 住院医疗 疫苗接种身故和残疾 入院津贴 免赔 保障期限 保费 支持多次 儿童综合医疗保险 20w 3w(含门诊住院) 30w 10w 1w 0 100 1年 730.9 平安少儿综合保险 20w 2w+5k 30w(15项重大疾病) 20w 2w 40w 100 1年 1247.5 住院医疗为每次 ","date":"2018-12-21","objectID":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/:5:5","tags":["保险"],"title":"给孩子上保险（笔记）","uri":"/post/%E6%97%A5%E5%B8%B8-%E7%BB%99%E5%AD%A9%E5%AD%90%E4%B8%8A%E4%BF%9D%E9%99%A9%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"容器镜像 镜像中的应用尽量从环境变量获取配置参数； 退而求其次，配置文件放在一个配置文件夹中，编排的时候可以挂载文件夹。 ","date":"2018-12-21","objectID":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/:1:0","tags":["Docker","Deploy"],"title":"容器镜像服务","uri":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"阿里云的容器镜像服务 ","date":"2018-12-21","objectID":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/:2:0","tags":["Docker","Deploy"],"title":"容器镜像服务","uri":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"产品功能 1. 用户可以根据自己的业务需求，选择不同的地域创建和删除镜像仓库，提供稳定快速的镜像上传、下载服务； 2. 每个镜像仓库都提供了公网、内网、VPC网络下对应的网络地址； 3. 支持便捷的镜像安全扫描功能，展示详细的镜像层信息； 4. 提供镜像漏洞报告，展示漏洞编号、漏洞等级、修复版本等多维度漏洞信息； 5. 支持阿里云Code、GitHub、Bitbucket、自建GitLab的源代码构建源； 6. 支持自动构建，源代码变更后实现自动构建成新Docker镜像； 7. 支持海外构建，源代码在海外实现构建成新Docker镜像； 8. 整合阿里云Code及CodePipeline，实现源代码到应用编译测试后，自动构建成新镜像； 9. 整合容器服务，实现新镜像构建完成后便捷部署至容器服务集群。 10. [通过配置镜像加速器可以提升获取Docker官方镜像的速度](https://help.aliyun.com/document_detail/60750.html?spm=a2c4g.11186623.4.3.43bf1e66F2XOnU) ","date":"2018-12-21","objectID":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/:2:1","tags":["Docker","Deploy"],"title":"容器镜像服务","uri":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"操作使用 1. `一般在企业账户下设置一个子账户来管理镜像服务`。 2. 命名空间 1) 作为一些仓库的集合，推荐将一个公司或组织的仓库集中在一个命名空间下面。 以公司名称作为命名空间：aliyun、alibaba 以团队、组织作为命名空间：misaka-team 2) 目前每个主账号可以创建5个命名空间 3. 创建镜像仓库 1) 仓库作为一些镜像的集合，推荐将一个（应用或功能）不同版本的镜像放置在一个仓库中。 以软件包作为仓库名称：centos、jetty 以应用名作为仓库名称：console-web、console-service 2) 创建过程中会选择关联代码库。 3) 私有仓库，仓库是其他用户不可见的，只有有权限的账户登录才能进行下载。 4. 管理镜像仓库 目录 功能 基本信息 查看并修改此镜像的基本信息 构建 设置构建规则， 并构建；查看构建日志一般tag为发布版，master为latest班 仓库授权 支持RAM细粒度控制仓库的访问权限 webhook 提供仓库镜像的消息触发功能，当镜像上传之后主动触发用户设置的访问地址；串联镜像服务的下游流程,详见触发器管理 镜像版本 可以对镜像进行安全扫描，生成漏洞报告，并查看层信息 镜像同步 5. 部署应用 点击，可以直接前往容器服务进行部署。 6. docker基本操作 docker login -u [user] -p [pw] [registry.cn-hangzhou.aliyuncs.com] docker pull registry.cn-hangzhou.aliyuncs.com/[命名空间]/[仓库名]:[版本] docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/[命名空间]/[仓库名]:[版本] docker push registry.cn-hangzhou.aliyuncs.com/[命名空间]/[仓库名]:[版本] 7. 对上游的建议 在编写项目代码时，配置信息一般从环境变量中获取，获取不到采用默认值。 ","date":"2018-12-21","objectID":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/:2:2","tags":["Docker","Deploy"],"title":"容器镜像服务","uri":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"缺点 1. 构建失败之后，查看构建日志，很难定位到日志最后。 ","date":"2018-12-21","objectID":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/:2:3","tags":["Docker","Deploy"],"title":"容器镜像服务","uri":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"计费 1. 目前容器镜像服务处于公测期间，免费提供镜像托管、镜像构建服务以及镜像加速器服务，请放心使用。 ","date":"2018-12-21","objectID":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/:2:4","tags":["Docker","Deploy"],"title":"容器镜像服务","uri":"/post/%E8%BF%90%E7%BB%B4-9-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/"},{"categories":["项目管理"],"content":"翻译自Building Docker images with GitLab CI/CD GitLab CI/CD允许使用Docker引擎构建和测试基于Docker的项目。 **Tip:**允许使用docker-compose和其他Docker编排工具。 持续集成/部署的趋势之一: 创建应用镜像 对所创建的镜像进行测试 将镜像推到远程registry 部署到服务器 应用中可包含Dockerfile用来创建和测试镜像: docker build -t my-image dockerfiles/ docker run my-docker-image /script/to/run/tests docker tag my-image my-registry:5000/my-image docker push my-registry:5000/my-image GitLab Runner需要一些特别的配置使jobs中支持docker。 ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:0:0","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Runner配置 有三种方法在jobs中使用docker build和docker run，各有利弊。 ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:1:0","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"使用shell执行器 最简单的方法是将GitLab Runner安装成shell执行器模式。 GitLab Runner将以gitlab-runner用户执行jobs中的脚本. 安装 GitLab Runner 在安装过程中选择 shell: sudo gitlab-runner register -n \\ --url https://gitlab.com/ \\ --registration-token REGISTRATION_TOKEN \\ --executor shell \\ --description \"My Runner\" 在服务器中安装 Docker. 更多信息参考Supported installations. 将gitlab-runner用户加入到docker组中: sudo usermod -aG docker gitlab-runner 检查gitlab-runner是否可以访问Docker: sudo -u gitlab-runner -H docker info 将docker info写入.gitlab-ci.yml来检测一切是否OK: before_script:- dockerinfobuild_image:script:- dockerbuild-tmy-docker-image.- dockerrunmy-docker-image/script/to/run/tests 现在，可以使用docker命令和安装docker-compose. **Note:**通过将gitlab-runner添加到docker组，可以有效地授予gitlab-runner完全的根用户权限。更多信息可参考On Docker security: docker group considered harmful. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:1:1","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"使用docker-in-docker执行器 第二种方法是使用docker-in-docker (dind)Docker image 安装有(docker and docker-compose)，以特权模式在镜像的上下文中执行jobs脚本或命令。 步骤如下 安装GitLab Runner. 命令行注册GitLab Runner 使用 docker and privileged模式: sudo gitlab-runner register -n \\ --url https://gitlab.com/ \\ --registration-token REGISTRATION_TOKEN \\ --executor docker \\ --description \"My Docker Runner\" \\ --docker-image \"docker:stable\" \\ --docker-privileged 上边的命令将注册一个新的Runner使用docker:stable镜像（Docker提供）. 注意：使用privileged模式来执行build和service容器. 如果要使用docker-in-docker模式, 必须在你的Docker容器中使用privileged = true。 上边的命令将创建config.toml如下: [[runners]] url = \"https://gitlab.com/\" token = TOKEN executor = \"docker\" [runners.docker] tls_verify = false image = \"docker:stable\" privileged = true disable_cache = false volumes = [\"/cache\"] [runners.cache] Insecure = false 现在可以在构建脚本中使用 docker 命令 (注意需要包含docker:dind服务): image:docker:stablevariables:# When using dind service we need to instruct docker, to talk with the# daemon started inside of the service. The daemon is available with# a network connection instead of the default /var/run/docker.sock socket.## The 'docker' hostname is the alias of the service container as described at# https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#accessing-the-services## Note that if you're using Kubernetes executor, the variable should be set to# tcp://localhost:2375 because of how Kubernetes executor connects services# to the job containerDOCKER_HOST:tcp://docker:2375/# When using dind, it's wise to use the overlayfs driver for# improved performance.DOCKER_DRIVER:overlay2services:- docker:dindbefore_script:- dockerinfobuild:stage:buildscript:- dockerbuild-tmy-docker-image.- dockerrunmy-docker-image/script/to/run/tests Docker-in-Docker以上为推荐的配置，工作OK。还有一些额外的配置: By enabling --docker-privileged, you are effectively disabling all of the security mechanisms of containers and exposing your host to privilege escalation which can lead to container breakout. For more information, check out the official Docker documentation on Runtime privilege and Linux capabilities. 当使用docker-in-docker, 每一个job都运行在干净的环境中不包含历史. 并行jobs也会工作得很好因为每一个构建都会获得他们自己的Docker引擎实例，彼此之间不会冲突。但是，这也意味着jobs会运行 很慢，没有layers的缓存。 默认情况下， docker:dind 使用 --storage-driver vfs 是最慢. 可以使用另外一种storage driverUsing the overlayfs driver. 因为docker:dind容器和runner容器没有共享他们的root文件系统, job的工作目录会被挂载在子容器中。 For example, if you have files you want to share with a child container, you may create a subdirectory under /builds/$CI_PROJECT_PATH and use it as your mount point (for a more thorough explanation, check issue#41227): variables:MOUNT_POINT:/builds/$CI_PROJECT_PATH/mntscript:- mkdir-p\"$MOUNT_POINT\"- dockerrun-v\"$MOUNT_POINT:/mnt\"my-docker-image 这种方法的一个样例: https://gitlab.com/gitlab-examples/docker. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:1:2","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"使用 Docker socket 绑定 第三种方法将 /var/run/docker.sock 绑定到容器，这样在image中就可以使用docker了. 步骤如下: 安装 GitLab Runner. 命令行注册 GitLab Runner 使用 docker 和分享 /var/run/docker.sock: sudo gitlab-runner register -n \\ --url https://gitlab.com/ \\ --registration-token REGISTRATION_TOKEN \\ --executor docker \\ --description \"My Docker Runner\" \\ --docker-image \"docker:stable\" \\ --docker-volumes /var/run/docker.sock:/var/run/docker.sock The above command will register a new Runner to use the special docker:stable image which is provided by Docker. Notice that it’s using the Docker daemon of the Runner itself, and any containers spawned by docker commands will be siblings of the Runner rather than children of the runner. This may have complications and limitations that are unsuitable for your workflow. The above command will create a config.toml entry similar to this: [[runners]] url = \"https://gitlab.com/\" token = REGISTRATION_TOKEN executor = \"docker\" [runners.docker] tls_verify = false image = \"docker:stable\" privileged = false disable_cache = false volumes = [\"/var/run/docker.sock:/var/run/docker.sock\", \"/cache\"] [runners.cache] Insecure = false You can now use docker in the build script (note that you don’t need to include the docker:dind service as when using the Docker in Docker executor): image:docker:stablebefore_script:- dockerinfobuild:stage:buildscript:- dockerbuild-tmy-docker-image.- dockerrunmy-docker-image/script/to/run/tests While the above method avoids using Docker in privileged mode, you should be aware of the following implications: By sharing the docker daemon, you are effectively disabling all the security mechanisms of containers and exposing your host to privilege escalation which can lead to container breakout. For example, if a project ran docker rm -f $(docker ps -a -q) it would remove the GitLab Runner containers. Concurrent jobs may not work; if your tests create containers with specific names, they may conflict with each other. Sharing files and directories from the source repo into containers may not work as expected since volume mounting is done in the context of the host machine, not the build container, e.g.: docker run --rm -t -i -v $(pwd)/src:/home/app/src test-image:latest run_app_tests ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:1:3","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Making docker-in-docker builds faster with Docker layer caching When using docker-in-docker, Docker will download all layers of your image every time you create a build. Recent versions of Docker (Docker 1.13 and above) can use a pre-existing image as a cache during the docker build step, considerably speeding up the build process. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:2:0","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"How Docker caching works When running docker build, each command in Dockerfile results in a layer. These layers are kept around as a cache and can be reused if there haven’t been any changes. Change in one layer causes all subsequent layers to be recreated. You can specify a tagged image to be used as a cache source for the docker build command by using the --cache-from argument. Multiple images can be specified as a cache source by using multiple --cache-from arguments. Keep in mind that any image that’s used with the --cache-from argument must first be pulled (using docker pull) before it can be used as a cache source. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:2:1","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Using Docker caching Here’s a simple .gitlab-ci.yml file showing how Docker caching can be utilized: image:docker:stableservices:- docker:dindvariables:CONTAINER_IMAGE:registry.gitlab.com/$CI_PROJECT_PATHDOCKER_HOST:tcp://docker:2375DOCKER_DRIVER:overlay2before_script:- dockerlogin-ugitlab-ci-token-p$CI_JOB_TOKENregistry.gitlab.combuild:stage:buildscript:- dockerpull$CONTAINER_IMAGE:latest||true- dockerbuild--cache-from$CONTAINER_IMAGE:latest--tag$CONTAINER_IMAGE:$CI_COMMIT_SHA--tag$CONTAINER_IMAGE:latest.- dockerpush$CONTAINER_IMAGE:$CI_COMMIT_SHA- dockerpush$CONTAINER_IMAGE:latest The steps in the script section for the build stage can be summed up to: The first command tries to pull the image from the registry so that it can be used as a cache for the docker build command. The second command builds a Docker image using the pulled image as a cache (notice the --cache-from $CONTAINER_IMAGE:latest argument) if available, and tags it. The last two commands push the tagged Docker images to the container registry so that they may also be used as cache for subsequent builds. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:2:2","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Using the OverlayFS driver NOTE: Note: The shared Runners on GitLab.com use the overlay2 driver by default. By default, when using docker:dind, Docker uses the vfs storage driver which copies the filesystem on every run. This is a very disk-intensive operation which can be avoided if a different driver is used, for example overlay2. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:3:0","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Requirements Make sure a recent kernel is used, preferably \u003e= 4.2. Check whether the overlay module is loaded: sudo lsmod | grep overlay If you see no result, then it isn’t loaded. To load it use: sudo modprobe overlay If everything went fine, you need to make sure module is loaded on reboot. On Ubuntu systems, this is done by editing /etc/modules. Just add the following line into it: overlay ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:3:1","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Use driver per project You can enable the driver for each project individually by editing the project’s .gitlab-ci.yml: variables: DOCKER_DRIVER: overlay2 ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:3:2","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Use driver for every project To enable the driver for every project, you can set the environment variable for every build by adding environment in the [[runners]] section of config.toml: environment = [\"DOCKER_DRIVER=overlay2\"] If you’re running multiple Runners you will have to modify all configuration files. Notes: More information about the Runner configuration is available in the Runner documentation. For more information about using OverlayFS with Docker, you can read Use the OverlayFS storage driver. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:3:3","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Using the GitLab Container Registry Notes: This feature requires GitLab 8.8 and GitLab Runner 1.2. Starting from GitLab 8.12, if you have 2FA enabled in your account, you need to pass a personal access token instead of your password in order to login to GitLab’s Container Registry. Once you’ve built a Docker image, you can push it up to the built-in GitLab Container Registry. Some things you should be aware of: You must log in to the container registry before running commands. You can do this in the before_script if multiple jobs depend on it. Using docker build --pull fetches any changes to base images before building just in case your cache is stale. It takes slightly longer, but means you don’t get stuck without security patches to base images. Doing an explicit docker pull before each docker run fetches the latest image that was just built. This is especially important if you are using multiple runners that cache images locally. Using the git SHA in your image tag makes this less necessary since each job will be unique and you shouldn’t ever have a stale image. However, it’s still possible to have a stale image if you re-build a given commit after a dependency has changed. You don’t want to build directly to latest tag in case there are multiple jobs happening simultaneously. ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:4:0","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Authenticating to the Container Registry There are three ways to authenticate to the Container Registry via GitLab CI/CD and depend on the visibility of your project. For all projects, mostly suitable for public ones: Using the special gitlab-ci-token user: This user is created for you in order to push to the Registry connected to your project. Its password is automatically set with the $CI_JOB_TOKEN variable. This allows you to automate building and deploying your Docker images and has read/write access to the Registry. This is ephemeral, so it’s only valid for one job. You can use the following example as-is: docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY For private and internal projects: Using a personal access token: You can create and use a personal access token in case your project is private: For read (pull) access, the scope should be read_registry. For read/write (pull/push) access, use api. Replace the \u003cusername\u003e and \u003caccess_token\u003e in the following example: docker login -u \u003cusername\u003e -p \u003caccess_token\u003e $CI_REGISTRY Using the GitLab Deploy Token: You can create and use a special deploy token with your private projects. It provides read-only (pull) access to the Registry. Once created, you can use the special environment variables, and GitLab CI/CD will fill them in for you. You can use the following example as-is: docker login -u $CI_DEPLOY_USER -p $CI_DEPLOY_PASSWORD $CI_REGISTRY ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:4:1","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":["项目管理"],"content":"Container Registry examples If you’re using docker-in-docker on your Runners, this is how your .gitlab-ci.yml could look like: build:image:docker:stableservices:- docker:dindvariables:DOCKER_HOST:tcp://docker:2375DOCKER_DRIVER:overlay2stage:buildscript:- dockerlogin-ugitlab-ci-token-p$CI_JOB_TOKENregistry.example.com- dockerbuild-tregistry.example.com/group/project/image:latest.- dockerpushregistry.example.com/group/project/image:latest You can also make use of other variables to avoid hardcoding: services:- docker:dindvariables:DOCKER_HOST:tcp://docker:2375DOCKER_DRIVER:overlay2IMAGE_TAG:$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUGbefore_script:- dockerlogin-ugitlab-ci-token-p$CI_JOB_TOKEN$CI_REGISTRYbuild:stage:buildscript:- dockerbuild-t$IMAGE_TAG.- dockerpush$IMAGE_TAG Here, $CI_REGISTRY_IMAGE would be resolved to the address of the registry tied to this project. Since $CI_COMMIT_REF_NAME resolves to the branch or tag name, and your branch-name can contain forward slashes (e.g., feature/my-feature), it is safer to use $CI_COMMIT_REF_SLUG as the image tag. This is due to that image tags cannot contain forward slashes. We also declare our own variable, $IMAGE_TAG, combining the two to save us some typing in the script section. Here’s a more elaborate example that splits up the tasks into 4 pipeline stages, including two tests that run in parallel. The build is stored in the container registry and used by subsequent stages, downloading the image when needed. Changes to master also get tagged as latest and deployed using an application-specific deploy script: image:docker:stableservices:- docker:dindstages:- build- test- release- deployvariables:DOCKER_HOST:tcp://docker:2375DOCKER_DRIVER:overlay2CONTAINER_TEST_IMAGE:registry.example.com/my-group/my-project/my-image:$CI_COMMIT_REF_SLUGCONTAINER_RELEASE_IMAGE:registry.example.com/my-group/my-project/my-image:latestbefore_script:- dockerlogin-ugitlab-ci-token-p$CI_JOB_TOKENregistry.example.combuild:stage:buildscript:- dockerbuild--pull-t$CONTAINER_TEST_IMAGE.- dockerpush$CONTAINER_TEST_IMAGEtest1:stage:testscript:- dockerpull$CONTAINER_TEST_IMAGE- dockerrun$CONTAINER_TEST_IMAGE/script/to/run/teststest2:stage:testscript:- dockerpull$CONTAINER_TEST_IMAGE- dockerrun$CONTAINER_TEST_IMAGE/script/to/run/another/testrelease-image:stage:releasescript:- dockerpull$CONTAINER_TEST_IMAGE- dockertag$CONTAINER_TEST_IMAGE$CONTAINER_RELEASE_IMAGE- dockerpush$CONTAINER_RELEASE_IMAGEonly:- masterdeploy:stage:deployscript:- ./deploy.shonly:- master ","date":"2018-12-20","objectID":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/:4:2","tags":["项目管理","GIT"],"title":"使用GitLab CI/CD创建Docker镜像","uri":"/post/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7-git-gitlab-cicd%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"},{"categories":null,"content":"安装、NPM命令、PM2使用、内置对象、工程结构、框架集合","date":"2018-12-20","objectID":"/post/js-nodejs/","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"安装 ","date":"2018-12-20","objectID":"/post/js-nodejs/:1:0","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"首先安装NVM Ubuntu 安装nvm (win8及以上) 安装nvm-windows win8以下系统 在Windows的系统变量和用户变量中，均添加NVM_HOME和NVM_SYMLINK这两个名称的变量，前一个变量的值为nvm的安装路径，如C:\\Dev\\nvm，后一个变量的值为node.js的安装路径，如C:\\Dev\\nodejs。除此之外，还要确保系统变量PATH中，有%NVM_HOME%和%NVM_SYMLINK%这两个值，每个值的后面要加上英文的分号 node_mirror: http://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 将上边两行放入settings.txt文件中。 ","date":"2018-12-20","objectID":"/post/js-nodejs/:1:1","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"然后安装NODE(会自动安装npm) nvm --version nvm install 10.15.3 nvm use 10.15.3 // 源管理 npm install -g nrm nrm list nrm use taobao //尽量不适用taobao源 注：windows还需安装npm install -g node-gyp和npm install –global windows-build-tools ","date":"2018-12-20","objectID":"/post/js-nodejs/:1:2","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"使用yarn替换npm npm install yarn -g 或者Installation ","date":"2018-12-20","objectID":"/post/js-nodejs/:1:3","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"安装cnmp完全替代nmp(使用国外的项目不要使用cnpm，尽量不用) npm install cnpm -g --registry=https://registry.npm.taobao.org ","date":"2018-12-20","objectID":"/post/js-nodejs/:1:4","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"问题 electron打包出现 Error: Unresolved node modules: vue ","date":"2018-12-20","objectID":"/post/js-nodejs/:1:5","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"NPM和YARN使用 ","date":"2018-12-20","objectID":"/post/js-nodejs/:2:0","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"命令 npm - 参考手册 NPM命令 选项 功能 YARN npm info [name] 查看包所有的版本信息 npm ls [name] 查看已安装的包的版本信息 [name] -g 查看全局安装的包的版本信息 npm view [name] versions 查看包所有的版本信息 [name] version 查看包最新的版本信息 npm install -g 升级全局的本地包 yarn global add npm update [name] 升级某一个包 npm install –unsafe-perm 设置为true以在运行程序包脚本时禁止UID / GID切换 npm install –save [–save-dev] -S, –save: Package will appear in your dependencies;-D, –save-dev: Package will appear in your devDependencies;-O, –save-optional: Package will appear in your optionalDependencies. npm install –production 添加了production 参数后将仅仅 安装 package.json 中dependencies 里面的包，不会安装devDependencies 里面的 npm audit 允许开发人员分析复杂的代码，并查明特定的漏洞和缺陷 npm audit fix 检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖，而不必再自己进行跟踪和修复 npm audit fix –package-lock-only 运行audit fix，但是只更新pkglock， 不更新node_modules npm audit fix –only=prod 只更新dependencies中安装的包，跳过devDependencies中的包 npm audit fix –dry-run –json 运行命令，得到audit fix将会更新的内容，并且输出json格式的安装信息，但是并不真的安装更新 npm audit –json 得到json格式的详细检测报告 安装github工程 npm install https://github.com/huixisheng/zepto-lazyload.git#branch npx 参考npx 使用教程 调用项目内部安装的模块.一般来说，调用 Mocha ，只能在项目脚本node-modules/.bin/mocha --version和 package.json 的scripts字段里面。npx macha --version 原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。也可以调用系统命令。 除了调用项目内部模块，npx 还能避免全局安装的模块。 如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。 如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。 例: 当前目录起一个http服务。 项目的根目录下执行 node-modules/.bin/mocha --version ","date":"2018-12-20","objectID":"/post/js-nodejs/:2:1","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"package.json 作为描述文件，描述你的项目依赖哪些包。 文件内容： name # 【必须】 version # 【必须】 description # 描述信息，有助于搜索 main # 入口文件，一般都是 index.js scripts # 支持的脚本，默认是一个空的 test keywords # 关键字，有助于在人们使用 npm search 搜索时发现你的项目 author # 作者信息 license # 默认是 MIT bugs # 当前项目的一些错误信息，如果有的话 dependencies # 是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割 ","date":"2018-12-20","objectID":"/post/js-nodejs/:2:2","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"npm问题 sudo npm install 时，报错 permission denied 的解决方案 ","date":"2018-12-20","objectID":"/post/js-nodejs/:2:3","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"PM2 pm2是一个内置负载均衡的node.js应用进程管理器 npm install -g pm2 命令 功能 pm2 start server.js –name 启动一个应用，并指定名称 pm2 list 列出正在运行的应用 pm2 stop [id/name] 停止对应的应用 pm2 delete [name] 删除对应的应用 pm2 reload [name] 代码有更新，重载应用 pm2 restart [name] 重启应用 pm2 show [name] 查看相应的应用详情 ","date":"2018-12-20","objectID":"/post/js-nodejs/:3:0","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"内置对象 ","date":"2018-12-20","objectID":"/post/js-nodejs/:4:0","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"process process对象是 Node 的一个全局对象，提供当前 Node 进程的信息。它可以在脚本的任意位置使用，不必通过require命令加载。该对象部署了EventEmitter接口。 属性 描述 process.version 返回一个字符串，表示当前使用的 Node 版本，比如v7.10.0 process.env 获取系统环境变量 ","date":"2018-12-20","objectID":"/post/js-nodejs/:4:1","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"Node.js EventEmitter 创建一个模块 import EventEmitter from 'events'; class someThing extends EventEmitter{ a=null constructor (){ //初始化 super() this.a = new b(); this.a.on(\"\", ()=\u003e{ this.emit(\"\",c); }); } method (){ } } export default someThing; ","date":"2018-12-20","objectID":"/post/js-nodejs/:4:2","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"http ","date":"2018-12-20","objectID":"/post/js-nodejs/:4:3","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"NODEJS工程 ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:0","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"开始 npm init # 可在当前目录下创建一个package.json文件 npm init --yes # 可跳过回答问题步骤 自定义npm init行为 参考2018 年了，你还是只会 npm install 吗？ 定制 npm init 命令的实现方式也很简单，在 Home 目录创建一个 .npm-init.js 即可，该文件的 module.exports 即为 package.json 配置内容，需要获取用户输入时候，使用 prompt() 方法即可。 .npm-init.js 是一个常规的模块，意味着我们可以执行随便什么 node 脚本可以执行的任务。例如通过 fs 创建 README, .eslintrc 等项目必需文件，实现项目脚手架的作用。 ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:1","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"目录结构 index.js main |—-config.js ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:2","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"npm install安装依赖 npm install \u003cpackage\u003e 除了简单的指定包名, package 还可以是一个指向有效包名的 http url、git url和文件夹路径。 npm支持的git url格式\u003cprotocol\u003e://[\u003cuser\u003e[:\u003cpassword\u003e]@]\u003chostname\u003e[:\u003cport\u003e][:][/]\u003cpath\u003e[#\u003ccommit-ish\u003e | #semver:\u003csemver\u003e] ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:3","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"编写npm模块 初始化npm init； 创建入口文件; 在src中编写源代码。 在examples中编写示例。 通过.npmignore来在npm publish的时候，忽略自己不想要的文件。 放进git仓库中. 注意:使用module.exports导出模块，内部定义的函数之间如何相互调用.第一种方法：所在文件就是一个模块，定义function之后，其作用域就是整个模块。最后再module.exports={}.第二种方法：若一开始就module.exports={}中写方法，不能用this,只能用exports。全局的this就是module.exports. 注意:exports的用法:Node.js模块的接口设计模式 私有registry 将自己的私有模块放在私有registry中。 Verdaccio:A lightweight open source private npm proxy registry。 可使用docker安装。 ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:4","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"最佳实践参考 使用 npm: \u003e=5.1 版本, 保持 package-lock.json 文件默认开启配置 初始化：第一作者初始化项目时使用 npm install \u003cpackage\u003e 安装依赖包, 默认保存 ^X.Y.Z 依赖 range 到 package.json中; 提交 package.json, package-lock.json, 不要提交 node_modules 目录 初始化：项目成员首次 checkout/clone 项目代码后，执行一次 npm install 安装依赖包 不要手动修改 package-lock.json 升级依赖包: 升级小版本: 本地执行 npm update 升级到新的小版本 升级大版本: 本地执行 npm install \u003cpackage-name\u003e@\u003cversion\u003e 升级到新的大版本 也可手动修改 package.json 中版本号为要升级的版本(大于现有版本号)并指定所需的 semver, 然后执行 npm install 本地验证升级后新版本无问题后，提交新的 package.json, package-lock.json 文件 降级依赖包: 正确: npm install \u003cpackage-name\u003e@\u003cold-version\u003e 验证无问题后，提交 package.json 和 package-lock.json 文件 错误: 手动修改 package.json 中的版本号为更低版本的 semver, 这样修改并不会生效，因为再次执行 npm install 依然会安装 package-lock.json 中的锁定版本 删除依赖包: Plan A: npm uninstall \u003cpackage\u003e 并提交 package.json 和 package-lock.json Plan B: 把要卸载的包从 package.json 中 dependencies 字段删除, 然后执行 npm install 并提交 package.json 和 package-lock.json 任何时候有人提交了 package.json, package-lock.json 更新后，团队其他成员应在 svn update/git pull 拉取更新后执行 npm install 脚本安装更新后的依赖包 ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:5","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"语义化版本控制 官方文档适用于任何软件管理语义化版本 2.0.0 npm 语义化版本控制 ","date":"2018-12-20","objectID":"/post/js-nodejs/:5:6","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"框架集合 查看流行框架，参考nodeframework ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:0","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"Express *** Express是一个最小且灵活的Web应用程序框架，为Web和移动应用程序提供了一组强大的功能，它的行为就像一个中间件，可以帮助管理服务器和路由. express可能是Node.js最流行的框架，还有许多其他流行的框架都是基于Express构建的。 个人评价，express适合小型项目，不适合大型企业级项目，个人用用还可以，做为快速入门是个很好的选择，用过之后就可以考虑进入 koa 框架的道路. 优点 几乎是Node.js Web中间件的标准. 简单，简约，灵活和可扩展. 快速开发应用程序. 完全可定制. 学习曲线低. 轻松集成第三方服务和中间件. 主要关注浏览器，模板和渲染集成开箱即用 缺点 组织需要非常清楚，以避免在维护代码时出现问题 随着代码库大小的增加，重构变得非常具有挑战性 需要大量的手工劳动，因为您需要创建所有端点. 性能的最佳实践 使用gzip压缩 不要使用同步功能 正确记录（用于调试，使用特殊模块，如调试，应用程序活动使用winston或bunyan） 使用try-catch或promises正确处理异常 确保您的应用程序使用流程管理器自动重新启动，或使用systemd或upstartinit等系统 在群集中运行您的应用。您可以通过启动进程集群来大大提高Node.js应用程序的性能 缓存请求结果，以便您的应用不会重复操作以反复提供相同的请求 使用负载均衡器运行它的多个实例并分配流量，如Nginx或HAProxy 对静态资源使用反向代理。它可以处理错误页面，压缩，缓存，提供文件和负载平衡等 更多性能最佳实践. 安全的最佳实践 ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:1","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"KOA *** Koa 是一个新的 web 框架，由 Express幕后的原班人马打造，致力于成为web应用和API开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa帮你丢弃回调函数，并有力地增强错误处理. Koa并没有捆绑任何中间件而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序 KOA优点 Koa提高了互操作性，健壮性，使编写中间件变得更加愉快。 集成了大量的web API，但是没有绑定中间件 非常轻量，核心的Koa模块只有大约2K行代码 拥有非常好的用户体验 通过try / catch更好地处理错误 异步控制流，代码可读性更高 KOA缺点 Koa社区相对较小 与Express风格的中间件不兼容(目前还有遇到与其他框架兼容的中间件) 性能 Koa本身是一个非常轻量级的框架,可以构建具有出色性能的Web应用程序。代码可读性和维护性都相对较高 当然一些性能的最佳实践也是必不可少的，例如： 集群 并行运行 在代码中使用异步API 保持代码小而轻 以及使用gzip压缩 等等 安全 Koa有大量的中间件，提供相应的功能. ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:2","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"Sails **** 企业级框架 Sails 是基于 exrpess 的大而全的框架，MVC框架，旨在模拟熟悉的Ruby on Rails框架的MVC模式，但支持现代应用程序的需求。 捆绑了一个强大的ORM，即Waterline。自动生成的REST API. ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:3","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"[LoopBack] 建立在 Express 基础上的企业级 Node.js 框架，只需编写少量代码就能创建动态端到端的 REST API，一致化的模型关系和对 API 访问的权限控制. ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:4","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"[ThinkJS] **** 是国内360团队推出的一款面向未来开发的 Node.js 框架，整合了大量的项目最佳实践，让企业级开发变得如此简单、高效。框架底层基于 Koa 2.x 实现，兼容 Koa 的所有功能. ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:5","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"[Eggjs] ***** 是《阿里旗下产品》基于Node.js 和 Koa的一个Nodejs的企业级应用开发框架，它可以帮助开发团队及开发人员降低开发和维护成本。 Egg.js则是按照约定进行开发，奉行『约定优于配置』，具备提供基于Egg定制上层框架的能力、 高度可扩展的插件机制、内置多进程管理、基于Koa开发，性能优异、框架稳定，测试覆盖率高、渐进式开发、开发成本和维护成本低等特点。 ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:6","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"[Hapi] Hapi是基础功能相对丰富的框架。开发人员更专注于业务，而不是花时间构建基础架构。 配置驱动的模式，区别于传统的web服务器操作。 他还有比一个独特功能，能够在特定的IP上创建服务器，具有类似的功能onPreHandler。再需要的时候你可以拦截特地的请求做一些必要的操作 好处 提供了一个强大的插件系统，允许您快速添加新功能和修复错误 可扩展的API 对请求处理有更深层次的控制。 创建(REST)api的最佳选择，提供了路由、输入、输出验证和缓存 一次编写适配各端 详细的API参考和对文档生成的良好支持 与任何前端框架（如React，Angular和Vue.js）一起使用来创建单页面应用程序 基于配置的伪中间件 提供缓存，身份验证和输入验证 提供基于插件的扩展架构 提供非常好的企业插件，如joi，yar，catbox，boom，tv和travelogue HAPI缺点 代码结构复杂 插件不兼容，只能使用指定的插件如：catbox joi boom tv good travelogue等 端点是手动创建的，必须手动测试 重构是手动的 HAPI性能 2017年对Node框架的研究表明hapi相对于其他框架的表现最差 HAPI安全 hapi安全性主要依赖于插件 插件选择 Crumb反（XCSRF）验证插件。它适用于常规请求和CORS请求 Joi：JavaScript对象的对象模式描述语言和验证器 Hapi-rbac 用户的访问权限控制 Blankie 足够灵活的白名单作机制 Cryptiles 加密库 ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:7","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":null,"content":"nest Nest是构建高效，可扩展的 Node.js Web 应用程序的框架。 它使用现代的 JavaScript 或 TypeScript（保留与纯 JavaScript 的兼容性），并结合 OOP（面向对象编程），FP（函数式编程）和FRP（函数响应式编程）的元素。 在底层，Nest 使用了 Express，但也提供了与其他各种库的兼容，例如Fastify，可以方便地使用各种可用的第三方插件。 近几年，由于 Node.js，JavaScript 已经成为 Web 前端和后端应用程序的「通用语言」，从而产生了像Angular、React、Vue等令人耳目一新的项目，这些项目提高了开发人员的生产力，使得可以快速构建可测试的且可扩展的前端应用程序。 然而，在服务器端，虽然有很多优秀的库、helper 和 Node 工具，但是它们都没有有效地解决主要问题 - 架构。 Nest 旨在提供一个开箱即用的应用程序体系结构，允许轻松创建高度可测试，可扩展，松散耦合且易于维护的应用程序。 面向 AOP 编程 支持 typeorm Node.js 版的 spring 构建微服务应用 ","date":"2018-12-20","objectID":"/post/js-nodejs/:6:8","tags":["NODEJS","JS"],"title":"NodeJS概览及开发框架","uri":"/post/js-nodejs/"},{"categories":["自动化运维"],"content":"K8s入门","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"阅读Kubernetes 服务网格: Istio, Linkerd 和 Consul 大比较 存在的问题 目前越来越多的容器应用都是基于 Kubernetes 的，Kubernetes 已经成为了容器编排的事实标准。 微服务架构带来的影响，其中之一就是为服务的延展。就像城市周围的郊区一样，部署的小服务数量在呈现几何增长，这也是微服务带来的灾难性问题之一。 微服务的大量增加对如何统一标准化管理服务带来了非常大的挑战，比如多个服务/版本之间的路由、验证和授权、加密，以及在Kubernetes集群内的负载均衡等。 服务网格 服务网格就是来帮助解决这些问题的，甚至可以有更多功能。就像容器把应用程序从操作系统上抽象出来，服务网格的目标就是把如何处理进程间通信再抽象出来。 理解微服务最关键的一点就是要理解微服务都是严重依赖网络的。 服务网格管理服务间的网络流量。 服务网格层是在Kubernetes设施之上的，让服务间的网络通信安全可靠。 服务网格可以通过可观测性，网络和安全策略来分隔应用程序的业务逻辑。通过服务网格可以链接微服务，让微服务更安全，并且可以更好的监控微服务。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:0:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"连接 通过服务网格服务可以发现其它服务，并且可以相互通信。它可以智能的路由控制使服务间的流量和API调用。同时也可以支持高级的不部署方式，比如蓝绿发布，金丝雀或者滚动升级，甚至更多。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:1:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"安全 服务网格可以让服务间进行安全通信。可以执行安全策略来允许或者拒绝通信，比如，可以配置一个策略来拒绝来自部署环境中的客户服务访问生产服务。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:2:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"监控 服务网格可以让分布式的微服务系统具有可观测性。服务网格通常集成开箱即用的监控和追踪工具（比如 Kubernetes 中的 Prometheus 和 Jaeger），这些工具可以发现并可视化服务、流量、API延迟和跟踪之间的依赖关系。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:3:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"案例应用 参考下面的例子，来看看如何利用服务网格技术，先不管应用的伸缩性哈。通过熟悉这些知识，就可以开始在系统设计中对服务网格进行标准化，以便为将来的大规模操作放置构建块和关键组件。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:4:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"在分布式服务中改进可观测性 让你有了服务级别的可视化，追踪和监控能力。服务网格的一些关键能力极大地提高了可视化，同时提高了解决和减少问题的能力。例如，如果系统中的一个服务成为了瓶颈，一般的做法就是重试，但是这会因为瓶颈服务超时而恶化服务能力。有了服务网格，就可以很轻松的断开失败的服务，以此来禁止无用的副本，从而保持 API 的相应。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:4:1","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"蓝绿发布 有流量控制的能力。服务网格可以实现蓝绿发布，从而让应用程序的升级无需终端的安全升级。首先，暴露一小部分用户到新的版本，然后验证，最后再继续将其发布到生产中的所有实例 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:4:2","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"生产环境中的混沌测试 注入延时、故障的能力，可以帮助提升部署的鲁棒性。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:4:3","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"对接已有应用程序 如果你正在迁移现有的应用程序到基于 Kubernetes 的微服务上，可以使用服务网格作为桥接器而不用重写你的应用。可以把已有的应用程序作为 services 注册成为 Istio 的服务，然后开始逐步的迁移到 Kubernetes，而不用改变现在的服务间通信（像 DNS 路由）。这个案例和使用服务发现类似。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:4:4","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"API 网关 如果你对服务网格很感兴趣，并且打算使用，但是还没有使用 Kubernetes 的应用程序在跑，可以让你的运维团队部署服务网格来度量你的 API 使用，以此来学习使用服务网格。 开源的服务网格 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:4:5","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"Consul ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:5:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"Istio ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:6:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"Linkerd ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:7:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"三者的区别 目前为止 Istio 是 3 个技术方案中拥有最多的特性和灵活性的一个，但是要记住灵活性就意味着复杂性。 如果只是支持 Kubernetes，那么 Linkerd 或许是最好的选择。如果你想支持多种环境（包括了 Kubernetes 和 VM 环境）但是又不需要 Istio 的复杂性，那么 Consul 可能是最好的选择。 Istio 正迅速的成为 Kubernetes 上的服务网格技术标准。它是最成熟，但是部署最复杂的。 Istio和Linkerd的CPU基准测试 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/:8:0","tags":["Docker","Deploy"],"title":"Kubernetes-服务网格","uri":"/post/%E8%BF%90%E7%BB%B4-8-kubernetes%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BCservicemesh%E9%80%89%E6%8B%A9/"},{"categories":["自动化运维"],"content":"K8s入门","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"参考杜先生的博客 参考官网 参考k8s Deployment ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:0:0","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"创建集群 Kubernetes 集群由两种类型的资源组成: 1. 一个 Master 是集群的调度节点 2. Nodes 是应用程序实际运行的工作节点 Master 负责管理集群。 master 协调集群中的所有活动，例如调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新。 节点 是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。 每个工作节点都有一个 Kubelet，它是管理 节点 并与 Kubernetes Master 节点进行通信的代理。节点 上还应具有处理容器操作的工作，例如 Docker 或 rkt。一个 Kubernetes 工作集群至少有三个节点。 当您在 Kubernetes 上部署应用程序时，您可以告诉 master 启动应用程序容器。Master 调度容器在集群的 节点 上运行。 节点 使用 Master 公开的 Kubernetes API 与 Master 通信。最终用户还可以直接使用 Kubernetes 的 API 与集群交互。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:1:0","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"使用Minikube 创建Kubernetes cluster（单机版）最简单的方法 1. 安装kubectl(Kubernetes 自带的命令行客户端，可以用它来直接操作 Kubernetes)[UBUNTU] wget http://029145.oss-cn-hangzhou.aliyuncs.com/kubectl sudo chmod u+x kubectl sudo mv kubectl /usr/local/bin/ 2. 安装minikube wget http://029145.oss-cn-hangzhou.aliyuncs.com/minikube-linux-amd64 mv minikube-linux-amd64 minikube chmod u+x minikube sudo mv minikube /usr/local/bin/ 3. 下载依赖的镜像 注意： 此处的命令都必须在minikube ssh中执行。 docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0 docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0 gcr.io/google_containers/pause-amd64:3.0 docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/kube-addon-manager-amd64:v6.1 docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/kube-addon-manager-amd64:v6.1 gcr.io/google-containers/kube-addon-manager:v6.1 docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/kubedns-amd64:1.9 docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/kubedns-amd64:1.9 gcr.io/google_containers/kubedns-amd64:1.9 docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/kube-dnsmasq-amd64:1.4 docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/kube-dnsmasq-amd64:1.4 gcr.io/google_containers/kube-dnsmasq-amd64:1.4 docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/exechealthz-amd64:1.2 docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/exechealthz-amd64:1.2 gcr.io/google_containers/exechealthz-amd64:1.2 docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/kubernetes-dashboard-amd64:v1.5.0 docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/kubernetes-dashboard-amd64:v1.5.0 gcr.io/google_containers/kubernetes-dashboard-amd64:v1.5.1 4. 启动minikube minikube start \"启动\" minikube ssh \"进入minikube终端\" minikube dashboard \"在浏览器中打开dashboard\" ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:1:1","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"部署应用 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:2:0","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"创建一个Kubernetes Deployment Deployment负责创建和更新应用。创建Deployment后，Kubernetes master 会将Deployment创建好的应用实例调度到集群中的各个节点。 创建应用程序实例后，Kubernetes 部署控制器会持续监视这些实例。如果托管它的节点不可用或删除，则部署控制器将替换实例。 这提供了一种解决机器故障或维护的自愈机制。 kubectl cluster-info \"查看集群信息\" kubectl get nodes \"查看集群中的节点\" kubectl describe nodes [node-name] \"查看node的详细信息\" kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080 \"创建一个deployment\" kubectl get deployments \"列出deployments列表：DESIRED为期望的Pod数量，CURRENT为当前的数量，UP-TO-DATE为已更新的数量，AVAILABLE为已运行的数量\" kubectl describe deployments [deployment-name] \"查看deployment详细信息\" kubectl get pods \"查看pods状态信息\" kubectl describe pod [pod-name] \"查看pod详细信息\" kubectl delete pods [pod-name] \"删除pod,会发现又新建了一个\" kubectl logs [pod-name] \"查看pod中运行的容器的日志，一个pod中只运行一个容器\" kubectl exec $POD_NAME env \"在pod中执行命令\" kubectl exec -ti $POD_NAME bash \"打开pod中shell终端\" Pods运行在集群内部，运行在一个私有的隔离的网络中，内部pods和services可以访问，在网络外不可以访问。kubectl命令可以创建一个代理，将通信转发到集群范围内的私有网络。 在一个新的终端窗口 kubectl proxy \"创建一个APIserver供主机访问\" API服务器将根据pod名称为每个pod自动创建端点，这些端点也可以通过代理访问。 export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{\"\\n\"}}{{end}}') \"获取pod名称存在环境变量中\" curl http://localhost:8001/api/v1/namespaces/default/pods/kubernetes-bootcamp-4054965725-sz759/proxy/ \"可以访问pod中的应用\" 使用yaml文件创建Deployment（并将此文件加入版本控制） 1. 这是k8s官方推荐的做法 官方例子(https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml) 2. 将相关的项目放在一个文件中； 3. 不要在不必要的情况下，指定默认值； 4. 指定labels（除了在生产环境中）。 kubectl create -f deployment.yaml -record \"创建\" kubectl apply -f update-nginx-deployment.yaml \"升级\" ubectl get deployment [deployment-name] -o yaml \"根据现有的deployment生成yml\" kind:DeploymentapiVersion:extensions/v1beta1metadata:name:kubernetes-bootcamp# namespace: default# selfLink: /apis/extensions/v1beta1/namespaces/default/deployments/kubernetes-bootcamp # 不必要# uid: 21ee3d67-0750-11e9-9590-08002716e6be# resourceVersion: 142715# generation: 2# creationTimestamp: 2018-12-24T07:47:15Z# labels# run: kubernetes-bootcamp# annotations# deployment.kubernetes.io/revision : 1spec:replicas:4# minReadySeconds: 60 #滚动升级时60s后认为该pod就绪# selector# matchLabels# run : kubernetes-bootcamptemplate:metadata:#creationTimestamp: nulllabels:[可以指定标签]#run: kubernetes-bootcampspec:imagePullSecrets:- name:# secret名称containers:- name:kubernetes-bootcampimage:registry.cn-hangzhou.aliyuncs.com/js_k8s/kubernetes-bootcamp:v1ports:- containerPort:8080protocol:TCPenv:- name:LOGDNA_AGENT_KEYvalueFrom:secretKeyRef:name:logdna-agent-keykey:logdna-agent-key- name:LOGDNA_PLATFORMvalue:k8s- name:LOGDNA_EXCLUDEvalue:/var/log/containers/calico-*,/var/log/containers/ibm-kube-fluentd-*# resources:#terminationMessagePath: /dev/termination-log# imagePullPolicy: IfNotPresent# restartPolicy : Always# terminationGracePeriodSeconds: 30 #k8s将会给应用发送SIGTERM信号，可以用来正确、优雅地关闭应用,默认为30秒# dnsPolicy : ClusterFirst#securityContext:# strategy:# type: RollingUpdate# rollingUpdate: # 滚动升级配置# maxUnavailable: 1 # 滚动升级时会先启动1个pod# maxSurge: 1 # 滚动升级时允许的最大Unavailable的pod个数# status:# observedGeneration : 2# replicas : 4# updatedReplicas : 4# availableReplicas : 4# conditions:# type : Available# status : True# lastUpdateTime : 2018-12-25T06:18:35Z# lastTransitionTime : 2018-12-25T06:18:35Z# reason : MinimumReplicasAvailable# message : Deployment has minimum availability. replication controller（RC）与deployment的区别 摘自K8S中RC与Deployment的区别 Replication Controller为Kubernetes的一个核心内容，应用托管到Kubernetes之后，需要保证应用能够持续的运行，Replication Controller就是这个保证的key，主要的功能如下： 确保pod数量：它会确保Kubernetes中有指定数量的Pod在运行。如果少于指定数量的pod，Replication Controller会创建新的，反之则会删除掉多余的以保证Pod数量不变。 确保pod健康：当pod不健康，运行出错或者无法提供服务时，Replication Controller也会杀死不健康的pod，重新创建新的。 弹性伸缩 ：在业务高峰或者低峰期的时候，可以通过Replication Controller动态的调整pod的数量来提高资源的利用率。同时，配置相应的监控功能（Hroizontal Pod Autoscaler），会定时自动从监控平台获取Replication Controller关联pod的整体资源使用情况，做到自动伸缩。 滚动升级：滚动升级为一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始化升级的时候就可以及时发现和解决问题，避免问题不断扩大。 Deployment同样为Kubernetes的一个核心内容，主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:2:1","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"应用外部可见(变成一个service) kubectl get services \"查看服务列表\" kubectl expose deployment/kubernetes-bootcamp --type=\"NodePort\" --port 8080 \"使一个deployment外部可见\" kubectl describe services/kubernetes-bootcamp \"查看一个services的详细信息\" export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}') \"读取node port\" \"此后可以使用minikube ip和NODEPORT访问pod中的服务\" 使用describe命令输出的结果中，可以看到deployment和pod的labels，pod的labels包含deployment的labels，在get命令中可以使用-l参数来指定label。 kubectl label pod $POD_NAME app=v1 \"为pod新增一个label\" kubectl delete service -l run=kubernetes-bootcamp \"删除以指定label的服务\" ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:2:2","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"伸缩部署 kubectl scale deployments/[deployment name] --replicas=4 \"将pod扩展到4个，或者缩到4个\" \"将应用外部可见之后，可以看到有四个内部endpoint，对应一个外部port\" curl $(minikube ip):$NODE_PORT \"每执行依次可以看到是不同的pod提供服务，已经自动负载均衡\" ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:2:3","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"更新镜像 kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2 \"更新镜像版本\" kubectl rollout status deployments/kubernetes-bootcamp \"\" kubectl rollout undo deployments/kubernetes-bootcamp \"回退镜像版本到上一个版本（升级成功的版本）\" ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:2:4","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"Ingress An API object that manages external access to the services in a cluster, typically HTTP.Ingress can provide load balancing, SSL termination and name-based virtual hosting.提供虚拟主机配置 Ingress Controller和Ingress： Ingress 将Nginx的配置抽象成一个Ingress对象，每添加一个新的服务只需写一个新的Ingress的yaml文件即可 Ingress Controller 将新加入的Ingress转化成Nginx的配置文件并使之生效 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:3:0","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"其他 替代镜像必须在minikube ssh中执行。 使用私有仓库的镜像。 第一步：创建secret kubectl create secret docker-registry regcred --docker-server=\u003cyour-registry-server\u003e --docker-username=\u003cyour-name\u003e --docker-password=\u003cyour-pword\u003e --docker-email=\u003cyour-email\u003e 第二步：在yml文件中指定secret 在spec.template.spec.imagePullSecrets段内填入SECRET名称。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:4:0","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"K8S开源项目 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:5:0","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"KubeOperator KubeOperator 是一个开源项目，通过可视化 Web UI 在 VMware、Openstack 或者物理机上规划、部署和运营生产级别的 Kubernetes 集群。支持内网离线环境、支持 GPU、内置应用商店，已通过 CNCF 的 Kubernetes 软件一致性认证。 KubeOperator 内置 KubeApps Plus 应用商店，以支撑各种基于 K8s 的应用场景，如： CI / CD 应用场景：GitLab、Jenkins、Harbor、Sonarqube、Argo CD 等； GPU / AI 应用场景：Tensorflow、PyTorch 等; Serverless 应用场景：Knative 等； 数据库应用场景：MySQL、Redis 等; 资源需求较高。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:5:1","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":["自动化运维"],"content":"microk8s Microk8s由Canonical管理，是一种非弹性的、基于rails的单节点Kubernetes工具，主要面向离线开发、原型设计和测试。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/:5:2","tags":["Docker","Deploy"],"title":"Kubernetes实战","uri":"/post/%E8%BF%90%E7%BB%B4-7-kubernetes%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"参考：CodePipeline \u003e 产品简介 \u003e 应用场景 参考：AliyunContainerService/DevOps ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/:0:0","tags":["CI/CD","Devops"],"title":"自动化运维学习（AutoDevOps实践）","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"CodePipeline功能替代 CodePipeline使用本地Gitlab服务CE版自带的功能。完成编译构建、部署测试、生产交付。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/:1:0","tags":["CI/CD","Devops"],"title":"自动化运维学习（AutoDevOps实践）","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"阿里云镜像服务功能替代 可以将上一步生产交付的镜像文件存于本地Docker Registry中，提供拉取。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/:2:0","tags":["CI/CD","Devops"],"title":"自动化运维学习（AutoDevOps实践）","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"阿里云容器服务替代 构建私有云生产环境，得到webhook通知之后，拉取镜像，更新容器。可使用Kubernetes集群管理容器化的应用。 ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/:3:0","tags":["CI/CD","Devops"],"title":"自动化运维学习（AutoDevOps实践）","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"阿里云服务器ECS 1. 使用saltstack[GETTING STARTED WITH ALIYUN ECS](https://docs.saltstack.com/en/latest/topics/cloud/aliyun.html) ","date":"2018-12-18","objectID":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/:4:0","tags":["CI/CD","Devops"],"title":"自动化运维学习（AutoDevOps实践）","uri":"/post/%E8%BF%90%E7%BB%B4-04-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"参考你不知道的Node.js性能优化 参考Node.js 调试指南 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"使用最新版的NodeJS 对于生产环境而言，Node.js 官方推荐使用最新的 LTS 版本。 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"使用fast-json-stringify加速JSON序列化 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:2:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"提升 Promise 的性能 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:3:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"正确地编写异步代码 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:4:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"优化 V8 GC ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:5:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"正确地使用 Stream ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:6:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"C++ 扩展一定比 JavaScript 快吗？ ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:7:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"使用 node-clinic 快速定位性能问题 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:8:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"使用 alinode 监控 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:9:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"实战 使用docker+nginx+alinode+egg部署应用。 用户反应接口慢，alinode上显示CPU、内存、磁盘的负荷并不是很高。在docker内部，使用top发现内存占用很高。 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:9:1","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"设置告警 1. 注意：`必须设置告警`；这样才能及时发现问题，并保存事故现场。\r2. 截图ECS监控图；\r3. 截图alinode监控图；\r4. 保存alinode堆快cpu profile等性能数据文件；\r5. 保存应用服务器的日志文件，查看`top`信息。\r6. 保存应用的日志文件。\r ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:9:2","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"异常日志 首先将异常解决掉。 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:9:3","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"诊断内存泄漏 参考如何分析 Node.js 中的内存泄漏 . 参考快速定位线上 Node.js 内存泄漏问题. 参考Node应用内存泄漏分析方法论与实战. 内存泄漏（Memory Leak）指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢，严重的情况下导致内存达到某个极限（可能是进程的上限，如 v8 的上限；也可能是系统可提供的内存上限）会使得应用程序崩溃。 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:9:4","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"CPU分析 node进程cpu 100%问题排查. Node.js 应用故障排查手册 —— Node.js 性能平台使用指南 Node使用火焰图优化CPU爆涨 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:9:5","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"压测 ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:10:0","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"alexfernandez/loadtest ","date":"0001-01-01","objectID":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:10:1","tags":["NODE","JS"],"title":"NodeJS-性能","uri":"/post/js-nodejs-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]