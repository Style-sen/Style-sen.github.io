# JAVA-面向对象


部分内容摘自[速学堂](https://www.sxt.cn/Java_jQuery_in_action)

# 概念

## 类和对象

### 对象
1. 对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。

#### 对象创建的过程
1. 分配对象空间，并将对象成员变量初始化为0或空
2. 执行属性值的显示初始化
3. 执行构造方法
4. 返回对象的地址给相关的变量

### 类
1. 类是一个模板，它描述一类对象的行为和状态。
2. 一个JAVA文件只能有一个public类，而且类名和文件名相同。可以有多个非public类。

#### 构造方法
1. `构造方法名和类名相同`，虽然有返回值（对象的地址），不能定义返回值类型，不能在构造器中使用return返回某个值。
2. 用于对象的初始化。
3. Java通过new关键词来调用构造器，从而返回该类的实例。
4. 没有定义构造器的话，编译器会自动定义一个无参的构造函数。
5. 构造方法也是方法，也可以重载。
6. 如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。

#### 静态初始化块，用于类的初始化操作

```java
public class User3 {
    int id;        //id
    String name;   //账户名
    String pwd;   //密码
    static String company; //公司名称
    static {
        System.out.println("执行类的初始化工作");
        company = "北京尚学堂";
        printCompany();
    }  
    public static void printCompany(){
        System.out.println(company);
    }  
    public static void main(String[] args) {
        User3  u3 = new User3();
    }
}
```

### 方法
1. 方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。

### 实例变量
1. 每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。

### this\static关键字(在方法区)
1. this的本质就是“创建好的对象的地址”! `在构造方法调用前，对象已经创建`。因此，`在构造方法中也可以使用this代表“当前对象”` 。
2. 在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：
         a. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。
         b. 对于该类的所有对象来说，static成员变量只有一份。`被该类的所有对象共享`!!
         c. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)
         d. 在static方法中不可直接访问非static的成员。
3. `类方法引用在方法区、对象中的方法引用在堆，都指向方法区中类信息的方法代码。`

#### this的使用场景
1.  在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
2. `使用this关键字调用重载的构造方法`，避免相同的初始化代码。但`只能在构造方法中用，并且必须位于构造方法的第一句`。
3. this不能用于static方法中。

### 包
1. 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。
2. 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。
3. Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。
4. 如果导入两个同名的类，只能用包名+类名来显示调用相关类。
5. `静态导入(static import)是在JDK1.5新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性`。

#### 常用的包


| 包名 | 内容                                                         |
| ---- | ------------------------------------------------------------ |
|java.lang\ | 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。|
|java.awt\ | 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。|
|java.net\ | 包含执行与网络相关的操作的类。|
|java.io\ | 包含能提供多种输入/输出功能的类。|
|java.util\ | 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 |



## 内存底层

### 虚拟机内存模型
1. 每执行一个方法，都会创建一个栈帧；堆存放对象；方法区存放类信息和常量和字符串等。

### 垃圾回收机制
1. 主要是堆中对象的管理回收。
2. JVM优化主要是垃圾回收机制优化。
3. 对象创建new。
4. 发现无用的对象（没有任何变量引用的对象）；回收无用对象占用的内存空间。

#### 相关算法

##### 引用计数法
1. 每个对象有一个引用计数器，有变量引用加1，无变量引用减1.
2. 优点：算法简单。缺点是循环引用的无用对象无法识别。

##### 引用可达法（跟搜索算法）
1. 所有引用关系使用图。

#### 通用的分代垃圾回收机制
1. 按生命周期长短划分年轻代、年老代、永久代。将处于不同状态的对象放到堆中不同的区域。
2. JVM将堆内存分为Eden、Survivor和Tenured/Old空间。
3. 按照存活时间，往时间更长的区域移动。
4. JDK8之后没有永久代了。
5. MinorGC(清理年轻代，满了触发);Major（年老代）GC;Full GC（年轻代和年老代）.

#### JVM调优
1. 很大一部分工作就是对于Full GC的`调节`。
2. 触发Full GC的原因：
    a. 年老代被写满；
    b. 永久代被写满；
    c. System.gc()被显式调用，只是通知JVM（建议），尽量少用；
    d. 上一次GC之后Heap的各域分配策略动态变化。
3. 程序员无权调用垃圾回收器。
4. finalize方法，是java提供给程序员用来释放对象或资源的方法，尽量少用。

#### 以下四种情况容易造成内存泄漏
1. 创建大量无用的对象（比如大量拼接字符串，使用了string而不是stringBuilder）；
2. 静态集合类（HashMap\Vector\List）的使用；
3. 各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭；
4. 监听器的使用。

## 三大特征

### 继承

#### 需求

1. 代码复用。
2. 事物抽象。

#### 使用要点

1. 父类也称作超类、基类、派生类等。
2. Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。
3. Java中`类没有多继承，接口有多继承`。
4. `子类继承父类，可以得到父类的全部属性和方法` (除了父类的构造方法)，但`不见得可以直接访问`(比如，父类私有的属性和方法)。
5. 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。
6. instanceof是二元运算符，左边是对象，右边是类；`当对象是右面类或子类所创建对象时`，返回true；否则，返回false。

#### 方法重写
1. 子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。
2. 方法的重写需要符合下面的三个要点：
         1.“==”： 方法名、形参列表相同。
         2.“≤”：返回值类型和声明异常类型，`子类小于等于父类`。
         3.“≥”： 访问权限，`子类大于等于父类`。

#### final关键字
1. 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。
2. 修饰方法：该方法不可被子类重写。但是可以被重载!
3. 修饰类: 修饰的类不能被继承。`比如：Math、String等`。

#### 继承和组合
1. `is a`使用继承，`has a`使用组合。
2. 组合模式是将对象组合成树形结构（`定义一个类属性为一个类的实例`）以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

#### Object类
1. Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。
2. `toString()`方法.
3. “==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。
4. Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。
5. Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。
6. JDK提供的一些类，如String、Date、包装类等，重写了Object的equals方法，调用这些类的equals方法， x.equals (y) ，当x和y所引用的对象是同一类对象且属性内容相等时（并不一定是相同对象），返回 true 否则返回 false。

#### super关键字
1. super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。
2. 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。
3. 若是构造方法的`第一行代码没有显式的调用super(...)或者this(...)`;那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。

#### 继承树追溯
1. 依次上溯每个父类，查看每个父类中是否有h，直到Object；
2. 构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。

### 封装
1. 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。
2. “高内聚，低耦合”。
3.  高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。

#### 访问控制符
1. 使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。
1. `private` 表示私有，只有自己类能访问
2. default表示没有修饰符修饰，只有同一个包的类能访问
3. protected表示可以被同一个包的类以及其他包中的子类访问
4. `public`表示可以被该项目的所有包中的所有类访问

##### protected

1. 若父类和子类在同一个包中，子类可访问父类的protected成员，也可以访问父类对象的protected成员；
2. `若父类和子类不在同一个包中，子类可访问父类的protected成员，不能访问父类对象的protected成员`。

##### 使用细节(使用private和public最多)
1. 类的属性的处理:
    1. 一般使用`private`访问权限。
    2.  提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。
    3. 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。
2. `这个约定就是javabean`.

### 多态
1. 多态指的是同一个方法调用，由于对象不同可能会有不同的行为。
1. 多态是方法的多态，不是属性的多态(多态与属性无关)。
2. 多态的存在要有3个必要条件：`继承`，`方法重写`，`父类引用指向子类对象`。
3. `父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了`。
4. 多态的主要优势是提高了代码的可扩展性(避免大量的重载)，符合开闭原则。但是多态也有弊端，就是`无法调用子类特有的功能`.

#### 类型的转换
1. 父类引用指向子类对象，我们称这个过程为`向上转型，属于自动类型转换`。
2. 向上转型后的`父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法`。这时，我们就需要进行类型的`强制转换`，我们称之为向下转型!
3. 在向下转型过程中，必须将引用变量转成`真实的子类类型`(运行时类型)否则会出现类型转换异常ClassCastException。为了避免出现这种异常，我们可以使用instanceof运算符进行判断

## 特殊类

### 抽象类和抽象方法
1. 使用abstract修饰的方法，`没有方法体，只有声明`。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。
2. `包含抽象方法的类就是抽象类`。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。

#### 使用要点
1. 有抽象方法的类只能定义成抽象类
2. `抽象类不能实例化`，即不能用new来实例化抽象类。
3. `抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用`。
4. `抽象类只能用来被继承`。
5. `抽象方法必须被子类实现`。

### Java 接口
1. 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。
2. `抽象类还提供某些具体实现，接口不提供任何实现`，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。
3. 从接口的实现者角度看，接口定义了可以向外部提供的服务。
3. 从接口的调用者角度看，接口定义了实现者能提供那些服务。
5. 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，`做系统时往往就是使用“面向接口”的思想来设计系统`。
6. `接口和实现类不是父子关系，是实现规则的关系`。
7. 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。
8. `面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口`。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为`设计模式所研究的，实际上就是如何合理的去抽象`。
9. 普通类：具体实现;抽象类：具体实现，规范(抽象方法);接口：规范!

#### 定义
```java
[访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  {
    常量定义；  
    方法定义；
}
```

1. 访问修饰符：只能是public或默认。
2. 接口名：和类名采用相同命名机制。
3. extends：`接口可以多继承`。
4. 常量：`接口中的属性只能是常量`，总是：public static final 修饰。不写也是。
5. 方法：`接口中的方法只能是：public abstract。` 省略的话，也是public abstract。

#### 要点
1. 子类通过implements来实现接口中的规范。
2. 接口不能创建实例，但是`可用于声明引用变量类型`。
3. 一个类实现了接口，必须实现接口中所有的方法，并且`这些方法只能是public的`。
4. JDK7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。
5. `JDK8后，接口中也包含普通的静态方法和default（必须写default）方法`。

#### 面向接口
1. 我们必须围绕某种稳定的东西开展，才能以静制动，实现规范的高质量的项目。
2. `接口就是规范，就是项目中最稳定的东东! 面向接口编程可以让我们把握住真正核心的东西，使实现复杂多变的需求成为可能`。
3. 面向接口编程的概念比接口本身的概念要大得多。设计阶段相对比较困难，在你没有写实现时就要想好接口，接口一变就乱套了，所以`设计要比实现难`!

#### java8新特性
1. 默认方法（普通方法）必须加default。
2. 静态方法。
3. 默认方法可以调用静态方法。

### 内部类
1. 不是很常用。
2. 把一个类放在另一个类的内部定义，称为内部类(innerclasses)。
3. 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类只能使用public和default修饰。
4. 内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。

#### 内部类的作用：
    1. 内部类提供了更好的封装。`只能让外部类直接访问，不允许同一个包中的其他类直接访问`。
    2. 内部类`可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性`。
    3. 接口只是解决了多重继承的部分问题，而`内部类使得多重继承的解决方案变得更加完整`。

#### 内部类的使用场合：
    1. 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在`只为外部类提供服务的情况下`可以优先考虑使用内部类。
    2. 使用内部类`间接实现多继承`：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。

#### 内部类的分类

##### 成员内部类
1. 可以使用private、default、protected、public任意进行修饰。

###### 非静态内部类
1. 外部类里使用非静态内部类和平时使用其他类没什么不同
2. 非静态内部类对象单独属于外部类的某个对象。
3. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。
4. `非静态内部类不能有静态方法、静态属性和静态初始化块`。
5. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。
6. 成员变量访问要点：
    1. 内部类里方法的局部变量：变量名。
    2. 内部类属性：this.变量名。
    3. 外部类属性：外部类名.this.变量名。
7. 内部类的访问：
    1. 外部类中定义内部类：`new Inner()`
    2. 外部类以外的地方使用非静态内部类：`Outer.Inner  varname = new Outer().new Inner()`。

###### 静态内部类
1. `当一个静态内部类对象存在，并不一定存在对应的外部类对象`。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。
2. `静态内部类看做外部类的一个静态成员`。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。

##### 匿名内部类
1. 适合那种只需要使用一次的类。比如：键盘监听操作等等。·形参·
2. 匿名内部类没有访问修饰符。
3. 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。
```
new 父类构造器（参数列表）|实现接口（）  
    {  
     //匿名内部类的类体部分  
    }
```

##### 局部内部类
1. 定义在方法内部的，作用域只限于本方法，称为局部内部类。
2. 局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，`出了该方法就会失效`。

## 常用类

### 包装类
1. 我们在实际应用中经常需要`将基本数据转化成对象`，以便于操作。比如：将基本数据类型存储到Object[]数组或集合中的操作等等。
2. 为了解决这个不足，Java在设计类时`为每个基本数据类型设计了一个对应的类进行代表`，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。
3. 包装类均位于java.lang包
4. 这八个类名中，除了Integer和Character类以外，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写而已。
5. 这八个类中，除了Character和Boolean以外，其他的都是“数字型”，`“数字型”都是java.lang.Number的子类`。`Number类是抽象类，因此它的抽象方法，所有子类都需要提供实现`。Number类提供了抽象方法：intValue()、longValue()、floatValue()、doubleValue()，意味着所有的“数字型”包装类都可以互相转型。

#### 作用
1. 作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。
2. 包含每种基本数据类型的`相关属性`如最大值、最小值等，以及`相关的操作方法`(这些操作方法的作用是在`基本数据类型、包装类对象、字符串`之间提供相互之间的转化!)。
```java
public class Test {
    /** 测试Integer的用法，其他包装类与Integer类似 */
    void testInteger() {
        // 基本类型转化成Integer对象
        Integer int1 = new Integer(10);
        Integer int2 = Integer.valueOf(20); // 官方推荐这种写法
        // Integer对象转化成int
        int a = int1.intValue();
        // 字符串转化成Integer对象
        Integer int3 = Integer.parseInt("334");
        Integer int4 = new Integer("999");
        // Integer对象转化成字符串
        String str1 = int3.toString();
        // 一些常见int类型相关的常量
        System.out.println("int能表示的最大整数：" + Integer.MAX_VALUE); 
    }
    public static void main(String[] args) {
        Test test  = new Test();
        test.testInteger();
    }
}
```

#### 自动装箱和拆箱(编译器实现)
1. 自动装箱和拆箱就是将`基本数据类型和包装类`之间进行自动的互相转换。
```
Integer i = 5  自动执行了 Integer i = Integer.valueOf(5)
Integer i = 5;int j = i; 这样的过程就是自动拆箱。
```

2. 自动装箱过程是通过调用包装类的valueOf()方法实现的，而自动拆箱过程是通过调用包装类的 xxxValue()方法实现的(xxx代表对应的基本数据类型，如intValue()、doubleValue()等)。
3. 所以自动装箱与拆箱的功能是所谓的“编译器蜜糖(Compiler Sugar)”，虽然使用这个功能很方便，但在程序运行阶段您得了解Java的语义。

#### 包装类的缓存
1. 整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行`缓存处理，其目的是提高效率`。
2. 超过范围后，对象之间不能再使用==进行数值的比较，而是使用equals方法。

### String相关类

#### String
1. 不可变。final value
2. `substring()`会生成新的字符串。
2. 在遇到字符串常量之间的拼接时，编译器会做出优化，即`在编译期间就会完成字符串(显示常量)的拼接`。因此，在使用==进行String对象之间的比较时，我们需要特别注意
3.  String类的下述方法能创建并返回一个新的String对象: concat()、 replace()、substring()、 toLowerCase()、 toUpperCase()、trim()。
2. 提供查找功能的有关方法: endsWith()、 startsWith()、 indexOf()、lastIndexOf()。
3. 提供比较功能的方法: equals()、equalsIgnoreCase()、compareTo()。
4. 其它方法: charAt() 、length()。

#### StringBuilder
1. 可变。
1. 效率高，不做线程同步检查，线程不安全。`局部变量可用`。
2. 抽象类AbstractStringBuilder的子类。
3. 重载的public StringBuilder append(…)方法
可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。
2. 方法 public StringBuilder delete(int start,int end)
可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。
3. 方法 public StringBuilder deleteCharAt(int index)
移除此序列指定位置上的 char，仍然返回自身对象。
4. 重载的public StringBuilder insert(…)方法
 可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。
5. 方法 public StringBuilder reverse()
用于将字符序列逆序，仍然返回自身对象。
6. 方法 public String toString() 返回此序列中数据的字符串表示形式。
7. 和 String 类含义类似的方法：
```
public int indexOf(String str)
public int indexOf(String str,int fromIndex)
public String substring(int start)
public String substring(int start,int end)
public int length() 
char charAt(int index)
```

#### StringBuffer
1. 可变。
1. 效率低，做线程同步检查，线程安全。
3. 抽象类AbstractStringBuilder的子类。
4. 方法与上类似。

#### 对比
1. String s ="a"; 创建了一个字符串,s = s+"b"; 实际上原来的"a"字符串对象已经丢弃了，现在又产生了另一个字符串s+"b"(也就是"ab")。 如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的时间和空间性能，甚至会造成服务器的崩溃。
2. 相反，StringBuilder和StringBuffer类是对原字符串本身操作的，可以对字符串进行修改而不产生副本拷贝或者产生少量的副本。因此可以在循环中使用。

### 时间处理相关类

#### Date类(java.util.Date)
1. long类型表示毫秒数。
2. System.currentTimeMills() 获取当前的毫秒数。
1. Date() 分配一个Date对象，并初始化此对象为系统当前的日期和时间，可以精确到毫秒)。
2. Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间(称为“历元(epoch)”，即 1970 年 1 月 1 日 00:00:00 GMT)以来的指定毫秒数。
3. boolean after(Date when) 测试此日期是否在指定日期之后。
4. booleanbefore(Date when) 测试此日期是否在指定日期之前。
5. boolean equals(Object obj) 比较两个日期的相等性。
6. long getTime() 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。
7. String toString() 把此 Date 对象转换为以下形式的 String：dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun、 Mon、Tue、Wed、 Thu、 Fri、 Sat)。
8. `日期操作一般使用Calendar类，而字符串的转化使用DateFormat类`。

#### DateFormat类和SimpleDateFormat类
1. 把时间对象转化成指定格式的字符串。反之，把指定格式的字符串转化成时间对象。
2. DateFormat是一个抽象类，一般使用它的的子类SimpleDateFormat类来实现。

#### Calendar日历类和GregorianCalendar类
```
GregorianCalendar calendar = new GregorianCalendar(2999, 10, 9, 22, 10, 50);
        int year = calendar.get(Calendar.YEAR); // 打印：1999
        int month = calendar.get(Calendar.MONTH); // 打印：10
        int day = calendar.get(Calendar.DAY_OF_MONTH); // 打印：9
        int day2 = calendar.get(Calendar.DATE); // 打印：9
        // 日：Calendar.DATE和Calendar.DAY_OF_MONTH同义
        int date = calendar.get(Calendar.DAY_OF_WEEK); // 打印：3
calendar2.set(Calendar.YEAR, 2999);
        calendar2.set(Calendar.MONTH, Calendar.FEBRUARY); // 月份数：0-11
        calendar2.set(Calendar.DATE, 3);
        calendar2.set(Calendar.HOUR_OF_DAY, 10);
        calendar2.set(Calendar.MINUTE, 20);
        calendar2.set(Calendar.SECOND, 23);
        calendar3.add(Calendar.MONTH, -7); // 月份减7
        calendar3.add(Calendar.DATE, 7); // 增加7天
```

### Math类（ java.lang.Math）
1. 提供了一系列静态方法用于科学计算;其方法的参数和返回值类型一般为double型。
2. 如果需要更加强大的数学运算能力，计算高等数学中的相关内容，可以使用apache commons下面的Math类库。
3. Math.random()，但是通常我们需要的随机数范围并不是[0, 1)之间的double类型的数据。
3. 如果使用Math.random()计算过于复杂的话，我们可以使用例外一种方式得到随机数，即Random类，这个类是专门用来生成随机数的，并且Math.random()底层调用的就是Random的nextDouble()方法。
5. Random类位于java.util包下。

### file类（ java.io.File）
1. 读取文件、生成文件、删除文件、修改文件的属性时经常会用到本类
2. 常见构造方法：public File(String pathname)
3. 以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir（System.getProperty('user.dir')）中存储.
4. createNewFile()
5. delete()
6. mkdir() chuang'jia
7. mkdirs()

### 枚举
1. 枚举类型的定义包括枚举声明和枚举体。
```
enum  枚举名 {
      枚举体（常量列表）
}
```

2. 枚举体就是放置一些常量。
3. `所有的枚举类型隐性地继承自 java.lang.Enum`。
4. 枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。
5. 可以直接通过枚举类型名使用它们。
1. 当你需要定义一组常量时，可以使用枚举类型。
2. 尽量不要使用枚举的高级特性，事实上高级特性都可以使用普通类来实现，没有必要引入枚举，增加程序的复杂性!

### 其他

1. 工具类的构造器做好是私有化的。
2. GameUtil.class.getClassLoader().getResource(path);可以帮助我们获得程序运行类加载器，加载资源的根目录，从而获得相对资源位置。
