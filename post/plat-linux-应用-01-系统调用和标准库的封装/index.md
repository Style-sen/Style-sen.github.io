# 系统调用和标准库的封装


## 1. 多进程和多线程

### 1.1. 存储空间

1. 参考[Linux虚拟地址空间布局以及进程栈和线程栈总结](https://blog.csdn.net/freeelinux/article/details/53782986)

### 1.2. 多进程

### 1.3. 多线程

1. 线程是可结合的（joinable），或者是分离的（detached）。决定一个线程以什么样的方式来终止自己。
2. 一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。
3. 在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。
4. 要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。
5. 线程的优先级。

### 1.4. 开源实现

1. [chenshuo/muduo](https://github.com/chenshuo/muduo)Muduo is a multithreaded C++ network library based on
the reactor pattern.
2. [《Linux 多线程服务端编程：使用 muduo C++ 网络库》](https://book.douban.com/subject/20471211/)
3. [libevent/libevent](https://libevent.org/)一个用C语言编写的、轻量级的开源高性能事件通知库.

## 2. 协程

参考[什么是协程](https://zhuanlan.zhihu.com/p/172471249)

1. 百度的自动驾驶系统Apollo中使用了协程作为底层调度单元。

### 2.1. 为什么使用协程

1. 【线程太多】一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。每个线程至少会占用4M的内存空间，10000个线程会消耗39G的内存，而服务器的内存配置只有区区8G，这时候你有2种选择，一是选择增加服务器，二是选择提高代码效率。
2. 协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多（启动100个线程，每个线程上运行100个协程）。

### 2.2. 注意事项

1. 在协程中不能调用导致线程阻塞的操作。**协程只有和【异步IO】（IO密集型）结合起来，才能发挥最大的威力**。
2. 如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：
    1. 在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。【这其实和多线程没有太大区别】。
    2. 对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，【最好寄希望于编程语言原生支持】。
3. 协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。

### 2.3. 开源实现

1. [Tencent/libco](https://github.com/Tencent/libco)协程库。

