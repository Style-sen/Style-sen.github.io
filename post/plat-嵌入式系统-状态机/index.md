# 状态机


学习[状态机的三种骚操作，值得你了解](https://mp.weixin.qq.com/s/M4px8oR5M1CgWb4ucfaG9w)

## 1. 概念

1. 状态机的实现3个要素：状态、事件、响应；
2. 有限状态机，层次状态机，并行状态机。

## 2. 实现方法

### 2.1. `switch—case`法

1. 比较常用。
2. `状态嵌套事件`和`事件嵌套状态`,自行决断。
3. 【注】switch—case的原理是从上到下挨个比较，越靠后，查找耗费的时间就越长，所以要注意状态和事件在各自的 switch 语句中的安排顺序；出现频率高或者实时性要求高的状态和事件的位置应该尽量靠前。

### 2.2. 表格驱动法

1. 把事件当做纵轴，把状态当做横轴，交点[Sn , Em]则是系统在 Sn 状态下对事件 Em 的响应

    |     | S0        | S1        | S2        |
    | --- | --------- | --------- | --------- |
    | E0  | Node_S0E0 | Node_S1E0 | Node_S2E0 |
    | E1  | Node_S0E1 | Node_S1E1 | Node_S2E1 |
    | E2  | Node_S0E2 | Node_S1E2 | Node_S2E2 |
    | E3  | Node_S0E3 | Node_S1E3 | Node_S2E3 |

2. Node_SnEm 叫做状态机节点，在 Sn状态下对事件 Em 的响应。这里所说的响应包含两个方面：输出动作和状态迁移。

    ```c
    struct fsm_node
    {
        void (*fpAction)(void* pEvnt);//函数指针，pEvent事件的内容
        INT8U u8NxtStat;
    };
    ```

3. 表格反映在 C 语言代码里就是一个二维数组，第 1 维就是状态机的状态（枚举），第 2维就是统一分类的事件（枚举），而数组的元素则是上述结构体常量。
4. 【优点】效率提高，相对于switch-case方法。【缺点】可读性差，而且无法根据条件不同切换到不同的状态。
5. `压缩表格驱动法`压缩表格驱动法使用了一维数组作为驱动表格，数组的下标即是状态机的各个状态。节点函数对所有事件起作用，让动作封装函数返回一个状态， 并把这个状态作为状态机新的状态。

    ```c
    struct fsm_node /*压缩状态机节点结构体*/
    {
     INT8U (*fpAction)(void* pEvnt); /*事件处理函数指针（内部就是switch-case）,返回一个状态*/
     INT8U u8StatChk; /*状态校验， 程序在引用函数指针 fpAction 之前， 先检查当前状态和当前节点成员 u8CurStat 的值是否一致，一致则认为状态合法，事件正常响应，如果不一致，则认为当前状态非法，转至意外处理，最大限度保证程序运行的安全。*/
    };
    //也可以判断当前状态是否是这个数组的index
    ```

6. `压缩表格驱动法是相当优秀的，它既有表格驱动法的简洁、高效、标准，又有 switch—case 法的直白、灵活、多变，相互取长补短，相得益彰`。

### 2.3. 函数指针法

1. 前边方法用一个全局的整型变量来记录状态值，然后再查驱动表格找函数地址，直接用一个全局的函数指针来记录状态。
2. 函数的返回值不再是整型的状态值， 而是下一个动作封装函数的函数地址， 函数返回后， 框架代码再把这个函数地址存储到全局函数指针变量中。
3. 不建议使用，很难判断函数指针是否合法。

