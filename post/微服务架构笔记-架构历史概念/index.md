# 微服务架构笔记-架构历史及架构


# 演化

## 云原生

参考[云原生架构概述](http://dockone.io/article/2991)
参考[云原生应用：更快交付，降低风险，拓展业务](https://pivotal.io/cn/cloud-native)

### CNCF组织

1. 在讲云原生之前，我们先了解一下CNCF，即云原生计算基金会，2015年由谷歌牵头成立，基金会成员目前已有一百多企业与机构，包括亚马逊、微软。思科等巨头。
2. 目前CNCF所托管的应用已达14个，其公布的[Cloud Native Landscape](https://landscape.cncf.io/)，给出了云原生生态的参考体系。

### 云原生

1. CNCF给出了云原生应用的三大特征：

    a. 容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用，简化云原生应用程序的维护。在容器中运行应用程序和进程，并作为应用程序部署的独立单元，实现高水平资源隔离。
    b. 动态管理：通过集中式的编排调度系统来动态的管理和调度。
    c. 面向微服务：明确服务间的依赖，互相解耦。

2. 云原生包含了一组应用的模式，用于帮助企业快速，持续，可靠，规模化地交付业务软件。云原生由微服务架构，DevOps 和以容器为代表的敏捷基础架构组成。

### The Twelve Factors

1. 12-Factors经常被直译为12要素，也被称为12原则，12原则由公有云PaaS的先驱Heroku于2012年提出（https://12factor.net/），目的是告诉开发者如何利用云平台提供的便利来开发更具可靠性和扩展性、更加易于维护的云原生应用。具体如下：

    a. 基准代码
    a. 显式声明依赖关系
    a. 在环境中存储配置
    a. 把后端服务当作附加资源
    a. 严格分离构建、发布和运行
    a. 无状态进程
    a. 通过端口绑定提供服务
    a. 通过进程模型进行扩展
    a. 快速启动和优雅终止
    a. 开发环境与线上环境等价
    a. 日志作为事件流
    a. 管理进程

2. 另外还有补充的三点：

    a. API声明管理
    a. 认证和授权
    a. 监控与告警

3. 距离12原则的提出已有五年多，12原则的有些细节可能已经不那么跟得上时代，也有人批评12原则的提出从一开始就有过于依赖Heroku自身特性的倾向。不过不管怎么说，12原则依旧是业界最为系统的云原生应用开发指南。


## 无服务(serverless)

参考[什么是Serverless无服务器架构？](https://www.jdon.com/soa/serverless.html)

# 架构体系

## 服务发现

参考[微服务中的服务发现](https://www.jianshu.com/p/1bf9a46efe7a)

1. 服务实例需要动态分配网络地址，而且，一组服务实例可能会因为自动扩展、失败或者升级发生动态变化，因此 你的客户端代码应该使用更加精细的服务发现机制。

### 客户端发现模式

1. 服务实例的网络地址在服务启动的时候被登记到服务注册表中 ，当实例终止服务时从服务注册表中移除。服务实例的注册一般是通过心跳机制阶段性的进行刷新。
2. `优点`：该模式除了服务注册表之外没有其他的活动部分了，相对来说还是简单直接的，而且，由于客户端知道相关的可用服务实例，那么就可以使用更加智能的，特定于应用的负载均衡机制，比如一致性哈希（客户端和负载均衡在同一个主机）。
3. `缺点`：客户端与服务注册表紧耦合了，你必须为每一种消费服务的客户端对应的编程语言和框架实现服务发现逻辑。

### 服务端发现模式

1. 客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。和客户端发现一样，服务实例通过服务注册表进行服务的注册和注销。
2. `优点`：服务发现的细节对客户端来说是抽象的，客户端仅需向负载均衡器发送请求即可。一些部署环境已经提供了该功能。比如K8S。
3. `缺点`：除非部署环境已经提供了负载均衡器，否则这又是一个需要额外设置和管理的可高可用的系统组件。

### 服务注册表

1. 服务注册表 是服务发现的关键部分，它是一个包含服务实例网络地址的的数据库。一个服务注册表需要`高可用`和`实时更新`，客户端可以缓存从服务注册表获取的网络地址。然而，这样的话缓存的信息最终会过期，客户端不能再根据该信息发现服务实例。因此，服务注册表对集群中的服务实例使用复制协议来维护一致性。

### 服务的注册和注销

#### 服务实例自己注册自己(self-registration 模式)

1. 服务实例自己负责通过服务注册表对自己进行注册和注销，另外如果有必要的话，服务实例可以通过发送心跳请求防止注册过期.
2. `优点`:相对简单，而且不强制使用其他的系统组件。
3. `缺点`:它使得服务实例和服务注册表强耦合 ，你必须在每一个使用服务的客户端编程语言和架构代码中实现注册逻辑。

#### 系统的其他组件管理服务实例的注册(third-party registration 模式)

1. 服务实例本身并不负责通过服务注册表注册自己，相反的，通过另一个被称作 service registrar系统组件来处理注册。 service registrar通过轮询或者订阅事件来检测一些运行实例的变化，当它检测到一个新的可用服务实例时就把该实例注册到服务注册表中去，service registrar还负责注销已经被终止的服务实例.
2. `优势`:使得服务从服务注册表中被解耦，你不必为开发者使用的每种开发语言和框架实现服务注册的逻辑，相反，服务实例的注册被一个专有服务以集中式的方式处理。
3. `缺点`:它被内置在部署环境中，不然这又是一个需要被设置和管理的高可用系统组件。

## 
