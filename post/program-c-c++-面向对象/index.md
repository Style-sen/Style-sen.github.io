# C++面向对象


## 1. class

### 1.1. 规范

1. `类名首字母都大写`

### 1.2. 访问权限

#### 1.2.1. public
  
1. 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员

#### 1.2.2. private（默认）

1. 基类中的 private 成员不能在派生类中使用，仍然可以被继承（派生类也有这些成员，只是不可以在自己的成员函数中直接访问和使用，必须要要调用基类的成员函数获取和修改）。

#### 1.2.3. protected

1. 声明为 protected 的成员在类外也不能通过对象访问，但是在它的派生类内部可以访问

#### 1.2.4. 实现private和protected的外部调用

1. 一般用于消息系统注册函数（基类调用子类的方法）。

```c++
#include "stdio.h"

struct func_struct;

class A
{
private:
    static func_struct func;

protected:
    void echo(void)
    {
        printf("hello world");
    }

public:
    func_struct *get()
    {
        return &func;
    }
};

typedef void (A::*TEST)(void);

struct func_struct
{
    TEST func;
};

func_struct A::func = {&A::echo};

int main()
{
    A a;
    const func_struct *m_ptr = a.get();
    ((&a)->*(m_ptr->func))();
}
```

### 1.3. 抽象和封装

### 1.4. 成员

#### 1.4.1. 成员变量

1. 大都以m_开头
2. 一般为private
3. [类的成员变量应该使用引用类型、指针类型还是对应类型对象呢？](https://blog.csdn.net/bumingchun/article/details/112755993)

```markdown
1. 因为引用类型必须在初始化列表初始化，并且不能被重新赋值，使用较少。
2. 指针类型适合在以下几种情况下使用：
    当成员变量要使用多态时，将成员变量定义成指针。
    当成员变量是可选的，在有些情况下不会使用，可以将成员变量定义成指针，节省空间。
    当成员变量是一个很大的对象时，将成员定义成指针，避免栈溢出，linux默认栈大小可以通过ulimit -s查看，默认为8Mb。
    当成员变量对应的资源不是对象独有，而是多个对象共同所有。
    ？？构造函数具有参数。
3. 其他情况直接定义指定类型对象较好，无需进行内存管理，无需担心空指针。
```

#### 1.4.2. 成员函数

##### 1.4.2.1. 构造函数

1. `只有在编译器需要默认构造函数来完成编译任务的时候，编译器才会为没有任何构造函数的类合成一个默认构造函数，或者是把这些操作插入到已有的构造函数中去`。参考[C++ 合成默认构造函数的真相](https://www.cnblogs.com/QG-whz/p/4676481.html)

    ```markdown
    编译器需要默认构造函数的四种情况，总结起来就是:
    a) 调用对象成员或基类的默认构造函数。
    b) 为对象初始化虚表指针与虚基类指针。
    ```

2. 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。

```markdown
1. 是个构造器;
2. 是个默认且隐含的类型转换操作符。(在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。)
```

##### 1.4.2.2. “=”会隐式调用拷贝构造函数

1. 使用explicit声明 才能避免隐式调用

##### 1.4.2.3. 带默认值参数的构造函数和无参数的构造函数不能共存，会有编译错误

##### 1.4.2.4. 继承

1. 【基类构造函数将会被自动调用】，用于初始化派生类从基类继承过来的成员变量，而派生类中新增的成员则需要从新定义构造函数用于初始化了
2. 在派生类的构造函数中不指定对应的基类的构造函数，这个时候调用的是基类的默认构造函数(即含有默认参数值或不带参数的构造函数)
3. 在派生类的构造函数中指定要调用的基类的构造函数，并将派生类构造函数的部分参数值传递给基类构造函数。
4. 除非基类有默认的构造函数，否则必须采用【显式调用】。

##### 1.4.2.5. 构造函数后加冒号【:】是初始化表达式

1. 初始化const成员(括号赋值)
2. 初始化引用成员
3. 调用基类的构造函数，而它拥有一组参数时
4. 调用成员类的构造函数，而它拥有一组参数时

##### 1.4.2.6. 拷贝构造函数

1. 复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，【参数类型是本类的引用】。
2. 复制构造函数的参数可以是 const 引用，也可以是非 const 引用(一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。)
3. 不写复制构造函数，【编译器就会自动生成复制构造函数】。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”.

    ```c++
    Complex cl(1, 2);
    Complex c2 (cl);  //用复制构造函数初始化c2
    ```

4. 如果编写了复制构造函数，则默认复制构造函数就不存在了
5. 复制构造函数被调用的三种情况

    ```markdown
    1. 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用
        Complex c2(c1);
        Complex c2 = c1;
    2. 如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。【类似传值调用】
        a. 以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。
        b. 如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。
    3. 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。【类似函数返回】
        a. 有些编译器出于程序执行效率的考虑，编译的时候进行了优化，函数返回值对象就不用复制构造函数初始化了，这并不符合 C++ 的标准
    ```

##### 1.4.2.7. get开头

##### 1.4.2.8. set开头

##### 1.4.2.9. 非静态、非虚的普通成员函数指针不能直接调用，必须绑定一个类对象

##### 1.4.2.10. 重载

1. 同一个类中（同一个作用域中/在类的内部）
2. 【一组函数名相同】，【函数的参数列表不同（参数的个数、类型、顺序）】，函数有无 virtual 关键字都可以
3. 返回值的类型不会影响重载
4. const属性相同
5. `typeof`是类型重命名，类型是相同的。

##### 1.4.2.11. 重写

1. 虚函数重写（会发生多态）
2. 非虚函数重写（重定义的一种形式）
3. 条件

```markdown
    1. 函数的返回类型、方法名、参数列表完全相同
    2. 必须发生在不同的作用域中（基类与派生类中）
    3. 基类中有 virtual 关键字声明，派生类中可有可无，不能有 static （虚函数重写）
```

##### 1.4.2.12. 重定义（隐藏）

1. 子类重新定义父类中有相同名称的函数 ( 不包括虚函数重写 )
2. 条件

    ```markdown
        1. 必须发生在不同的作用域中（基类与派生类中）
        2. 函数名相同
        3. 返回值可以不同
        4. 参数列表不同，此时，无论基类中的同名函数有无 virtual 关键字，【基类中的同名函数都会被隐藏】
        5. 参数列表相同，此时，基类中的同名函数没有 virtual 关键字，则基类中的同名函数将会被隐藏 --- 非虚函数重写
    ```

3. 可以通过作用域分辨符(::)访问被隐藏的父类中的同名成员
4. 不可以直接通过子类对象访问父类成员；
注：`同名覆盖规则适用于类的成员变量与成员函数`

### 1.5. Friend Classes（functions）（友元类或者函数）

#### 1.5.1. 在一个类中指明其他的类（或者）函数能够直接访问该类中的private和protected成员

#### 1.5.2. 友元按类型分为三种：普通非类成员函数作为友元,类的成员函数作为友元，类作为友元

#### 1.5.3. 友元不能被继承

#### 1.5.4. 友元不具有传递性

#### 1.5.5. 如果想要指定两个类都有成员函数作为对方的友元，那么必须第2个类是第一个类的友元

#### 1.5.6. 可以互为友元

### 1.6. 创建对象

1. 在栈上创建对象`Student stu;`.
2. 在堆上创建对象`Student *pstu = new Student;`.

### 1.7. 多态

#### 1.7.1. 虚基类

##### 1.7.1.1. 在c++中，派生类可以继承多个基类。问题在于：如果这多个基类又是继承自同一个基类时，那么派生类是不是需要多次继承这“同一个基类”中的内容？虚基类可以解决这个问题。

1. 虚基类可以使得从多个类（它们继承自一个类）中派生出的对象只继承一个对象。

#### 1.7.2. 纯虚函数

1. 若一个类的成员函数被声明为纯虚函数，则意味着该类是ABC(Abstract Base Class，抽象基类)，即只能被继承，而不能用来声明对象。纯虚函数通常需要在类中声明的后面加上关键词“=0”。
2. 当然，声明为纯虚函数并不意味着在实现文件中不可对其进行定义，只是意味着不可用抽象基类实现一个具体的对象。

#### 1.7.3. 虚函数

1. 重写不同于重载。我对重载的理解是：同一个类，内部的同名函数具有不同的参数列表称为重载；重写则是派生类对基类同名函数的“本地改造”，要求函数特征标完全相同。当然，返回值类型不一定相同（可能会出现返回类型协变的特殊情况）。
2. 一个基类的指针或者引用可以指向或者引用派生类的对象。同时，派生类可以重写基类中的成员函数。
3. 在基类中将被重写的成员函数设置为【虚函数】，其含义是：当通过基类的指针或者引用调用该成员函数时，将根据指针指向的对象类型确定调用的函数，而非指针的类型。【否则默认会调用基类的方法】
4. 将基类与派生类的同名方法区分开
5. 虚函数的使用将导致类对象占用更大的内存空间。
6. 只需将基类中的成员函数声明为虚函数即可，派生类中重写的virtual函数【自动成为虚函数】；
7. 基类中的析构函数必须为虚函数，否则会出现对象释放错误

### 1.8. 继承

## 方案

### 两个类如何相互调用

1. 类A和类B相互引用比较麻烦的根本原因在于：定义A的时候，A的里面有B，所以就需要去查看B的占空间大小，但是查看的时候又发现需要知道A的占空间大小，从而造成死循环。
2. 两个类相互引用，一个用对象、include；另一个用指针、前置声明、create手动new。手动new的过程不能在构造函数中进行，同时需要知道另一个类的完整定义（include）。

```c++

///<A.h>
class B;///<前置声明>
class A{
    B *b_;///<此处只能用指针或者引用>
}
///<A.cpp>
#include "A.h"
#include "B.h" ///<次文件中要调用b_所以此处需要inlcude B 的头文件>
void A::create(){
    b_ = new B();
}
///<B.h>
#include "A.h"
class B{
    A a_;///<此处可用对象>
}
```

