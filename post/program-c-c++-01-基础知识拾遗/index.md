# PROGRAM C C++ 基础知识拾遗


## 1. 语言版本

1. 目前最广泛使用的C语言版本是 ANSI / ISO C(C89,C90)，最经典的C语言教材是《C程序设计语言(The C Programming Language) 第二版》，【几乎所有的开发工具都支持 ANSI / ISO C 标准】。1999年发布的 ISO/IEC 9899:1999标准，通常被成为C99，C99并没有得到广泛的支持。
2. [C++ compiler support](https://en.cppreference.com/w/cpp/compiler_support)

## 2. 语法

1. 程序的入口：`int main(int argc, const char * argv[])`；`argc`参数表示了命令行中参数的个数;`argv`指针，数组的长度即为参数个数.
2. 在c语言标准中，加法与减法运算对于地址的操作（适用&获得地址和指针变量）和对于值的操作是不同的。
3. 当一个加法运算，加号两边的操作数一个是指针，另一个是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再和指针的值相加；当一个减法运算，减号左边的操作数是一个指针，右边的操作数是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再被指针的值减去；当一个减法运算，减号两边的操作数都是地址时，则这两个地址的数据类型必须一致（如都是int *类型），否则无法通过编译。减法运算的结果为地址值的差，再除以该地址的数据类型的大小（如sizeof(int)）。

### 2.1. [`static`](https://www.runoob.com/w3cnote/cpp-static-usage.html)

1. 在修饰变量的时候，`static` 修饰的静态局部变量只执行初始化一次【在编译阶段】，而且延长了局部变量的生命周期，直到程序运行结束以后才释放,【不能被其他函数调用】。
2. `static` 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
3. `static` 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。`static` 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
4. 不想被释放的时候，可以使用`static`修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 `static` 修饰。
5. 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 `static`）。
6. 【注】：`全局变量一个进程只有一个`。

#### 2.1.1. C++

1. 被 static 修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要 new 出一个类来;
2. 被 static 修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要 new 出一个类来;
3. 被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。`在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。`【注】`静态成员在一个进程中共享，多个进程间独立。`
4. 静态成员变量不能在类的内部初始化，**【在类的内部只是声明，定义必须在类外,定义时不能加上static关键字】**。定义时可以指定初始值,也可以不指定,不指定时系统默认其初始值为0.
5. 类的对象可以使用静态成员函数和非静态成员函数。
6. 如果类有一个静态成员指针变量，在进程中执行new或malloc操作分配了内存，进程退出前并不需要调用new或malloc，因为`系统会自动进行释放`。

### 2.2. `const`

#### 2.2.1. C++

1. `const`成员变量是属于对象的，其生命周期就是对象的生命周期，在这个生命周期中其值是不可改变的。
2. 非`static`的`const`成员变量*不能在类的内部初始化*，在类的内部只是声明，**只能通过构造函数的初始化列表进行初始化**,并且必须进行初始化。
3. 为`static`的`const`成员变量，应遵循`static`初始化原则，在类外进行初始化.
4. `【常变量只能初始化不能赋值】`，所以在构造函数中赋值，或者使用自定义的成员函数赋值都是错误的。

### 2.3. 函数

1. 【传址调用】指针作为参数在函数中传递的时候，它的实质依然是值传递，形参只是实参的一份拷贝，他们分别属于不同的两个指针变量。两个指针变量的地址肯定是不一样的，值是一样的，指向相同的内存。`void funcAddr(int *a_Fml)`
2. 【引用调用】形参是实参的引用，实参与形参拥有相同的地址。系统对传过来的参数没有拷贝，不会有任何额外开销，直接使用原始变量的内存空间。所以说，引用调用是比传址更高效的调用方式。`void funcRef(int &a_Fml)`

### 2.4. 冒号(:)

1. `struct`中bit位的定义。

#### 2.4.1. C++

1. 构造函数后加冒号是初始化表达式.

### 2.5. restrict

1. 它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.如 int *restrict ptr, ptr 指向的内存单元只能被 ptr 访问到，任何同样指向这个内存单元的其他指针都是未定义的，直白点就是无效指针。

### 2.6. struct

#### 2.6.1. C++

1. c++中允许在结构体当中定义函数，它的用法和类的用法很像，不过与类有一个区别在于，struct中定义的函数和变量都是默认为public的，但class中的则是默认为private。

### 2.7. volatile

1. 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化,防止优化编译器把变量从内存装入 CPU 寄存器中，系统总是重新从它所在的内存读取数据，从而可以提供对特殊地址（一个寄存器变量或者表示一个端口数据）的稳定访问。
2. 适用场景：【1】内嵌汇编操纵栈：这种方式属于编译无法识别的变量改变，【2】另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。

```shell
1) 中断服务程序中修改的供其它程序检测的变量需要加 volatile；
2) 多任务环境下各任务间共享的标志应该加 volatile；
3) 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；
```

### 2.8. `typedef`

1. 定义一个新类型。

#### 2.8.1. `C++`

1. [typedef定义类成员函数指针](https://blog.csdn.net/weixin_34167043/article/details/92634545).

```c++
#include <iostream>
class foo
{
public:
    int g (int x, int y) { return x + y ; }
};
typedef int (foo::*memberf_pointer)(int, int);//是一个指向函数的指针，而且这个指针指向的函数必须是类foo的成员函数
int main()
{
    foo f ;
    memberf_pointer mp = &foo::g;//如何赋值
    std::cout << (f.*mp) (5, 8) << std::endl;//如何调用
}
```

### `goto`

1. 尽量避免使用`goto`.
2. 可以考虑使用goto的情形：(1)从多重循环中直接跳出(2)出错时清除资源(3)可增加程序的清晰度。
3. 使用goto语句只能goto到同一函数内，而不能从一个函数里goto到另外一个函数里。
4. 使用goto语句在同一函数内进行goto时，goto的起点应是函数内一段小功能的结束处，goto的目的label处应是函数内另外一段小功能的开始处。
5. 不能从一段复杂的执行状态中的位置goto到另外一个位置，比如，从多重嵌套的循环判断中跳出去就是不允许的。
6. 应该避免向两个方向跳转.

### 2.9. C++特有

#### 2.9.1. 异常

1. throw 关键字除了可以用在函数体中抛出异常；
2. throw 用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。

```C
double func (char param) throw (int);
double func (char param) throw (int, char, exception);
double func (char param) throw ();
```

#### 2.9.2. Lambda 函数与表达式

#### 2.9.3. 命名空间（namespace）

1. C语言中所有的全局标识符共享一个作用域；C++中提出了命名空间的概念；

```c++

namespace Name
{
    namespace Internal
    {
    /*...*/
    }
    /*...*/
}

使用整个命名空间：using namespace name;    后续代码正在使用指定命名空间中的名称
使用命名空间中的变量：using name::variable
使用默认命名空间中的变量:  ::variable
```

## 3. 库

### 3.1. 动态库

1. 动态库只加载1份，但是其中的全局变量和静态变量会在每个进程中有1份，是独立的。

